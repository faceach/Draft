<html lang="zh" xml:lang="zh" xmlns="http://www.w3.org/1999/xhtml" xmlns:web="http://schemas.live.com/Web/"><head><script type="text/javascript">//<![CDATA[
si_ST=new Date;
//]]></script><!--pc--><title>记住我的车停在楼下。 - 必应</title><meta content="text/html; charset=utf-8" http-equiv="content-type"><meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><meta name="mobileoptimized" content="0"><link href="/search?format=rss&amp;speech=1&amp;input=2&amp;cc=cn&amp;setlang=zh-cn&amp;mkt=zh-cn&amp;uncrunched=1&amp;remindercox" rel="alternate" title="XML" type="text/xml"><link href="/search?format=rss&amp;speech=1&amp;input=2&amp;cc=cn&amp;setlang=zh-cn&amp;mkt=zh-cn&amp;uncrunched=1&amp;remindercox" rel="alternate" title="RSS" type="application/rss+xml"><link href="/sa/simg/bing_p_rr_teal_min.ico" rel="shortcut icon"><script type="text/javascript">//<![CDATA[
_G={ST:(si_ST?si_ST:new Date),Mkt:"zh-CN",RTL:false,Ver:"25",IG:"c6310a13bb7957fbc90e66b4e705fd78",EventID:"04D81438156E457FB07546DC975522CE",V:"web",P:"SERP",DA:"HK2",SUIH:"5uJdo0uiXAimTZR2QoEwuw",gpUrl:"\/fd\/ls\/GLinkPing.aspx?"};_G.lsUrl="/fd/ls/l?IG="+_G.IG;curUrl="https:\/\/cn.bing.com\/speech_render";_G.XLS="\/threshold\/xls.aspx";;_G.nclid='A0499920163756F9C2B5027F543BB1DC';///<reference path="..\..\..\answers\services\Shared\Content\Content\script\Declarations\Shared.d.ts"/>
if (!window.onerror) {
    // Chrome recently started passing in 5th argument as errorObject that contains error stack
    window.onerror = function (message, url, lineNumber, columnNumber, errorObject) {
        var undefined = "undefined";
        var logData;
        if (typeof errorObject === undefined && typeof event !== undefined && event) {
            // on IE and Edge, errorObject argument is not set, but the same data is available in event.error
            errorObject = event["error"];
        }
        if (typeof message === "object" && message.srcElement && message.srcElement.src) {
            //BUGBUG: 628140 -  JS Script Error Inst:  Investigate why we never hit the supposed special error 
            //                  handler for Chrome
            //Chrome passes only a ScriptError Object to the onerror function.
            logData = { ScriptSrc: message.srcElement.src };
            if (sj_evt) {
                sj_evt.fire("ErrorInstrumentation", JSON.stringify(logData));
            }
        }
        else {
            if (typeof SharedLogHelper !== undefined) {
                //for others we get a message, url and a line number.
                SharedLogHelper.LogError(url, message.toString(), errorObject, lineNumber, columnNumber);
            }
            else {
                window.addEventListener("load", function () { return SharedLogHelper.LogError(url, message.toString(), errorObject, lineNumber, columnNumber); });
            }
        }
    };
}
;
//]]></script><style type="text/css">/* Prevent pinch and zoom and double tap zoom */
html,body
{
    -ms-content-zooming: none;
}
/* File cannot be completely empty or else RMS will fail */
a{}/* File cannot be completely empty or else RMS will fail */
a{}/* THBRAND Combined Asset Start */

.sw_plus,
.sw_up,
.sw_down,
.sw_st,
.sw_sth,
.sw_ste,
.sw_tpcbk,
.sw_play,
.sw_playd,
/* disabled */ .sw_playa,
/* active */ .sw_playp/* paused */ {
  background-image: url(/sa/simg/sw_mg_l_4f_m_g_cn.png);
  background-repeat: no-repeat;
  background-size: 320px 38px;
}
/* Add icon */

.sw_plus {
  background-position: -216px 0;
  height: 10px;
  width: 10px;
}
.sw_play,
/*Play icon*/ .sw_playa,
/* active */ .sw_playd,
/* disabled */ .sw_playp/* paused */ {
  height: 16px;
  width: 16px;
}
.sw_play {
  background-position: -228px 0;
}
.sw_playa,
.sw_playd {
  background-position: -246px 0;
}
.sw_playp {
  background-position: -264px 0;
}
.sw_up,
/* Up (collapse) */ .sw_down/* down (expand) */ {
  height: 14px;
  width: 14px;
}
.sw_down {
  background-position: -184px 0;
}
.sw_up {
  background-position: -152px 0;
}
*:active > .sw_up,
*:focus > .sw_up {
  background-position: -168px 0;
}
*:active > .sw_down,
*:focus > .sw_down {
  background-position: -200px 0;
}
/* rating star */

.sw_st,
/* full gold */ .sw_sth,
/* left half star */ .sw_ste/* empty (light grey) */ {
  height: 12px;
  width: 12px;
  display: inline-block;
  padding-right: 1px;
}
.sw_st {
  background-position: -238px -22px;
}
.sw_sth {
  background-position: -266px -22px;
}
.sw_ste {
  background-position: -252px -22px;
}
.sw_tpcbk {
  background-position: -124px 0px;
}
/* START COLORS */

html,
body {
  background-color: white;
}
#b_results > .b_pag/* Task 1249184 : [Mobile 1st][wholepage] Paginiation - Remove legacy style after change ajax pagination */ {
  background-color: white;
}
body,
.b_corActList,
.b_corActList a,
.b_corActList a:visited,
.b_promoteText,
.b_action {
  color: black;
}
input[type="text"] {
  color: #404040;
  border-color: #bbbbbb;
}
input[type="text"]:focus {
  color: black;
  border-color: #404040;
}
#b_pole .b_ans {
  background-color: white;
}
#b_results,
#b_results .b_defaultText,
.cbl/* label in Factrow */ {
  color: black;
}
.sb_pag a.sb_pagS,
/* Task 1249184 : [Mobile 1st][wholepage] Paginiation - Remove legacy style after change ajax pagination */ #b_results > li,
#b_content > .sml/* Morepage pagination */ {
  background-color: white;
}
.sb_pagS {
  border-color: #cccccc;
}
#b_results > .b_ad {
  color: #303030;
  background-color: #f9fcf7;
}
.b_ad a {
  color: #0078d7;
}
.b_ad a:visited {
  color: #600090;
}
#b_results p {
  color: black;
}
a,
#b_results .b_no a {
  color: black;
}
a:visited,
#b_results > li a:visited,
#sb_feedback:visited {
  color: #600090;
}
cite,
#b_results cite.sb_crmb a,
/* Even breadcrumb links in the cite tag need to respect its color */ #b_results cite a.sb_metalink/* Even attribution links in the cite tag need to respect its color */ {
  color: #767676;
}
.b_factrow,
.b_attribution,
.b_focusLabel,
.b_secondaryFocus,
.b_secondaryText,
.b_demoteText,
.b_footnote,
.b_dropdown,
.b_footnote .cbl,
.b_meta,
.b_entitySubTitle,
#b_results .b_footnote a,
#b_results .b_footnote a:visited {
  color: #767676;
}
/* footer */

footer {
  color: #767676;
  background-color: white;
}
footer a,
footer a:visited,
footer span {
  color: #767676;
}
/* end of footer */

/*secondary text styles*/

.sb_meta,
label {
  color: #767676;
}
.s_btn.brd.b_highlighted {
  background: #0078d7;
  border-color: #0078d7;
}
input.b_highlighted:focus,
#b_results .s_btn.b_highlighted a:visited,
#b_results .s_btn.b_highlighted a,
#b_results .s_btn.b_highlighted/* #b_results is needed to fix a bug that the button text color remains blue when the background turns blue in highlighted mode, and it is to revert "#b_results>li a { color:blue}" */ {
  color: white;
}
select {
  background-color: white;
}
.b_subModule,
.b_suppModule {
  border-bottom-color: #eeeeee;
}
/* Primary alteration in spell suggest */

#b_results .b_pAlt {
  color: #d90026;
}
.b_alert,
#b_results .b_no .b_alert {
  color: #d90026;
}
#b_results .b_alert {
  color: #d90026;
}
.pushpin {
  background: #4499ff;
  color: white;
}
.b_posText {
  color: #d90026;
}
.b_negText {
  color: #339900;
}
.b_dropdown {
  background-color: white;
}
/* Override for High Contrast White */

@media screen and (-ms-high-contrast: active) {
  /* Apply to everything except to a-tag . This is effectively what Windows itself does */
  
  *:not(a) {
    background-color/* bingcss-ignore: need explicit override for accessibility */: Window;
    color/* bingcss-ignore: need explicit override for accessibility */: WindowText;
  }
  a *:not(a) {
    color/* bingcss-ignore: need explicit override for accessibility */: -ms-hotlight;
  }
  a[disabled],
  a[disabled] * {
    color/* bingcss-ignore: need explicit override for accessibility */: GrayText;
  }
  /* Apply to buttons. */
  
  .cbtn a,
  .upsellcardbuttons a,
  input[type='submit'],
  input[type='button'] {
    background-color/* bingcss-ignore: need explicit override for accessibility */: Window;
    border/* bingcss-ignore: need explicit override for accessibility */: 1px solid WindowText;
  }
}
/* END COLORS */

/* set font-faces for Segoe UI typography */

@font-face {
    font-family: Segoe;
    font-weight: 200;
    src: local("Segoe UI Light"), local("Segoe WP Light");
}
@font-face {
    font-family: Segoe;
    font-weight: 300;
    src: local("Segoe UI Semilight"), local("Segoe WP Semilight");
}
@font-face {
    font-family: Segoe;
    font-weight: normal;
    src: local("Segoe UI"), local("Segoe WP");
}
@font-face {
    font-family: Segoe;
    font-weight: 600;
    src: local("Segoe UI Semibold"), local("Segoe WP Semibold");
}
@font-face {
    font-family: Segoe;
    font-weight: 700;
    src: local("Segoe UI Bold"), local("Segoe WP Bold");
}
/* register with SegoeFontFaces in bundle */

body {
  font-weight: normal;
  /* Regular variant */
  font-size: 15px;
  line-height: 20px;
}
cite {
  font-style: normal;
}
.b_groupLabel,
.b_strong,
strong,
.b_no h4,
.pushpin,
.cardLabel {
  font-weight: 600;
  /* Semibold variant */

}
h1,
h2,
.b_secondaryFocus,
.b_focusTextExtraSmall,
.b_mText {
  font-size: 18px;
  line-height: 26px;
  font-weight: normal;
  /* Regular variant */

}
h3,
h4,
h5 {
  font-size: 15px;
  line-height: 22px;
  font-weight: normal;
  /* Regular variant */

}
.b_groupLabel {
  font-size: 13px;
  line-height: 18px;
}
.b_anno {
  font-size: 20px;
  line-height: 24px;
  font-weight: normal;
  /* Regular variant */

}
select,
.s_btn.b_highlighted a,
input[type="text"],
.cbtn input {
  /* we need to override the default css in each browser, e.g. http://www.iecss.com/ */
  font-size: 15px;
}
#fti3,
#ftrLnks,
#id_rwds_b,
.b_focusLabel,
.b_footnote,
.b_meta,
.b_corActList,
.pushpin,
.cardLabel,
.sb_count {
  font-size: 13px;
  line-height: 16px;
}
/*Focus text styles*/

.b_xlText {
  font-size: 18px;
}
.b_focusTextSmall,
.b_focusTextMedium,
.b_focusTextLarge {
  font-weight: 300;
  /* Semilight variant */

}
.b_focusTextSmall {
  font-size: 24px;
  line-height: 28px;
}
.b_focusTextMedium {
  font-size: 34px;
  line-height: 40px;
}
.b_focusTextLarge {
  font-size: 46px;
  line-height: 56px;
}
cite,
.nowrap {
  white-space: nowrap;
}
a,
#b_results .b_rs li a {
  text-decoration: none;
}
#sp_requery a {
  font-style: italic;
}
th {
  font-weight: normal;
  /* Regular variant */

}
.b_ad {
  line-height: 20px;
}
sup,
sub {
  line-height: normal;
}
.sb_pag a {
  text-decoration: none;
  text-align: center;
  font-size: 16px;
}
a.sb_pagP,
a.sb_pagN {
  text-decoration: none;
  white-space: nowrap;
}
.sb_pagIconN .sw_next,
.sb_pagIconP .sw_prev {
  font-family: "Segoe MDL2 Assets";
}
body,
input,
textarea,
button,
select,
option {
  font-family: Segoe, Arial, sans-serif;
}
body:-ms-lang(am, ti),
input:-ms-lang(am, ti),
textarea:-ms-lang(am, ti),
button:-ms-lang(am, ti),
select:-ms-lang(am, ti),
option:-ms-lang(am, ti) {
  font-family: Ebrima, Segoe, Arial, sans-serif;
}
body:-ms-lang(as, bn, gu, hi, kn, kok, ml, mr, ne, or, pa, si, ta, te),
input:-ms-lang(as, bn, gu, hi, kn, kok, ml, mr, ne, or, pa, si, ta, te),
textarea:-ms-lang(as, bn, gu, hi, kn, kok, ml, mr, ne, or, pa, si, ta, te),
button:-ms-lang(as, bn, gu, hi, kn, kok, ml, mr, ne, or, pa, si, ta, te),
select:-ms-lang(as, bn, gu, hi, kn, kok, ml, mr, ne, or, pa, si, ta, te),
option:-ms-lang(as, bn, gu, hi, kn, kok, ml, mr, ne, or, pa, si, ta, te) {
  font-family: "Nirmala UI", Segoe, Arial, sans-serif;
}
body:-ms-lang(chr-CHER-US),
input:-ms-lang(chr-CHER-US),
textarea:-ms-lang(chr-CHER-US),
button:-ms-lang(chr-CHER-US),
select:-ms-lang(chr-CHER-US),
option:-ms-lang(chr-CHER-US) {
  font-family: Gadugi, Segoe, Arial, sans-serif;
}
body:-ms-lang(ja),
input:-ms-lang(ja),
textarea:-ms-lang(ja),
button:-ms-lang(ja),
select:-ms-lang(ja),
option:-ms-lang(ja) {
  font-family: "Yu Gothic UI", Segoe, Arial, sans-serif;
}
body:-ms-lang(ko),
input:-ms-lang(ko),
textarea:-ms-lang(ko),
button:-ms-lang(ko),
select:-ms-lang(ko),
option:-ms-lang(ko) {
  font-family: "Malgun Gothic", Segoe, Arial, sans-serif;
}
body:-ms-lang(th, km, lo),
input:-ms-lang(th, km, lo),
textarea:-ms-lang(th, km, lo),
button:-ms-lang(th, km, lo),
select:-ms-lang(th, km, lo),
option:-ms-lang(th, km, lo) {
  font-family: "Leelawadee UI", Segoe, Arial, sans-serif;
}
body:-ms-lang(zh-CN, zh-Hans, zh-SG),
input:-ms-lang(zh-CN, zh-Hans, zh-SG),
textarea:-ms-lang(zh-CN, zh-Hans, zh-SG),
button:-ms-lang(zh-CN, zh-Hans, zh-SG),
select:-ms-lang(zh-CN, zh-Hans, zh-SG),
option:-ms-lang(zh-CN, zh-Hans, zh-SG) {
  font-family: "Microsoft YaHei UI", Segoe, Arial, sans-serif;
}
body:-ms-lang(zh-HK, zh-TW, zh-Hant, zh-MO),
input:-ms-lang(zh-HK, zh-TW, zh-Hant, zh-MO),
textarea:-ms-lang(zh-HK, zh-TW, zh-Hant, zh-MO),
button:-ms-lang(zh-HK, zh-TW, zh-Hant, zh-MO),
select:-ms-lang(zh-HK, zh-TW, zh-Hant, zh-MO),
option:-ms-lang(zh-HK, zh-TW, zh-Hant, zh-MO) {
  font-family: "Microsoft JhengHei UI", Segoe, Arial, sans-serif;
}
/* begin basic page values */

html,
body,
h1,
h2,
h3,
h4,
h5,
h6,
p,
img,
ol,
ul,
li,
form,
table,
tr,
th,
td,
blockquote {
  border: 0;
  border-collapse: collapse;
  border-spacing: 0;
  list-style: none;
  margin: 0;
  padding/* bingcss-ignore TFS: 641967 - Fix existing whitelist files to be complaint with CSS Cop rules */: 0;
}
html {
  -ms-content-zooming: none;
  -ms-user-select: none;
  cursor: default;
}
/* This ensures that any words that we will not fit in the width are wrapped */

/* We first try to hyphenate it, and only if that fails we break the word */

body {
  word-wrap: break-word;
  overflow-x: hidden;
  /* no left and right movement */
  -webkit-text-size-adjust: none;
  /* no text adjustment on phone rotation */

}
/* end basic page values */

header#b_header:not(:empty):not(.b_hide) ~ #b_content {
  margin-top: 45px;
}
.b_footnote {
  padding-bottom: 4px;
}
.b_imagePair .cico + .b_footnote,
img + .b_footnote {
  padding-top/* bingcss-ignore: we need to add padding between the image and the footnote */: 4px;
  padding-bottom: 0;
}
.b_hList {
  padding-bottom: 12px;
}
input[type="text"] {
  -webkit-appearance: none;
  margin: 0 0 20px 0;
  padding: 0 10px;
  height: 38px;
  border-width: 1px;
  border-style: solid;
  border-radius: 0;
  max-width: 100%;
  min-width: 50px;
}
h2,
.b_focusLabel {
  padding-bottom: 4px;
}
h4,
label,
.b_attribution,
.b_groupLabel,
.b_label,
.b_poiPair,
.b_secondaryFocus,
.b_sSpace,
.b_focusTextExtraSmall,
.b_focusTextSmall,
.b_focusTextMedium,
.b_focusTextLarge {
  padding-bottom: 4px;
}
h2 a,
h3 a,
h4 a,
h5 a,
.b_rs a,
label {
  display: block;
}
.inline label {
  display: inline;
}
#sp_requery a {
  display: inline-block;
}
.b_lBMargin,
h2.b_entityTitle {
  padding-bottom: 12px;
}
.b_entitySubTitle {
  margin-top: -8px;
}
.b_rich {
  padding: 4px 0 12px;
}
.b_rich > *:last-child,
.b_caption > *:last-child {
  padding-bottom: 0;
  margin-bottom: 0;
}
.b_caption {
  padding-bottom: 24px;
}
.b_factrow {
  display: -webkit-box;
  -webkit-box-orient: vertical;
}
.b_attribution {
  width: 100%;
}
.b_attribution,
.b_factrow {
  overflow: hidden;
  text-overflow: ellipsis;
}
.b_factrow {
  padding-bottom: 3px;
}
.b_dataList > li > *,
.b_imagePair .b_attribution > *,
.b_factrow > * {
  display: inline;
}
.b_anno {
  padding: 0 8px 24px 0;
}
.b_anno + .b_rich,
.b_anno + h2 + .b_rich {
  padding-top/* bingcss-ignore: Need to eat the top padding from b_rich */: 0;
}
.b_vPanel > div,
.b_vList > li {
  padding-bottom: 12px;
}
.b_vPanel.b_loose > div,
.b_vList.b_loose > li {
  padding-bottom: 24px;
}
.b_vPanel.b_narrow > div,
.b_vList.b_narrow > li {
  padding-bottom: 4px;
}
#b_results > li.si_pp,
.sb_hbop,
.b_hide,
#fRmsDefer,
#b_error,
#b_loadingmsg,
.sw_prev,
.sw_next {
  display: none;
}
/* begin vertical lists */

.b_rich > *:last-child,
.b_rich > .b_vList > li:last-child,
.b_rich > .b_vPanel > div:last-child,
.b_vPanel .b_vList > li:last-child,
.b_vList .b_vPanel > div:last-child,
.b_hList .b_vList > li:last-child,
.b_hList .b_vPanel > div:last-child,
.b_vList > li > *:last-child:not(a),
/* the last non-link child of vertical list items should have no bottom padding */ .b_vList:last-child > li:last-child,
/* if the vList is within another container, and is the last child, then the last element of the vlist should have no padding*/ .b_vPanel > div > *:last-child:not(a),
/* the last non-link child of vertical stack panel items should have no bottom padding */ .b_subModule > *:last-child,
.b_subModule .b_vPanel > *:last-child,
.b_subModule > .b_vList:last-child > *:last-child,
.b_suppModule > *:last-child,
.b_suppModule .b_vPanel > *:last-child,
.b_infocardContent > .b_vList:last-child > *:last-child,
.b_infocardContent > *:last-child,
.sa_uc > .b_vList > li:last-child,
.sa_uc > .b_vList > li:last-child > .b_vList:last-child > li:last-child,
.b_ans > .b_vList > li:last-child,
.b_vlist2col li:last-child,
.b_ans > *:last-child,
.b_algo > *:last-child,
.b_corActList:last-child {
  padding-bottom: 0;
}
.b_vlist2col > ul {
  min-width: 40%;
  display: inline-block;
  word-wrap: break-word;
  vertical-align: top;
  padding-bottom: 12px;
}
.b_vlist2col > ul:first-child {
  padding-right: 28px;
}
.b_vlist2col:last-child {
  margin-bottom: -12px;
  /* When a 2col list is the last child it should have no bottom padding. Use neg margin to override the child UL bottom padding. 
                                                  Can't just remove the UL bottom padding because we can't know if the content is in 2 columns or wrapped down to one. */

}
.b_vlist2col li {
  padding-bottom: 12px;
}
/* end vertical lists */

/* horizontal stack panel */

.b_hPanel > span:not(:last-child),
.b_hList > li:not(:last-child) {
  padding-right: 12px;
}
.b_hPanel.b_loose > span:not(:last-child),
.b_hList.b_loose > li:not(:last-child) {
  padding-right: 24px;
}
.b_hPanel.b_narrow > span:not(:last-child),
.b_hList.b_narrow > li:not(:last-child) {
  padding-right: 4px;
}
.b_hList > li {
  vertical-align: top;
}
.b_suffix {
  padding-left: 12px;
  /* intentionally matches horizontal stack panel spacing */

}
/* begin image/content horizontal pair */

.b_imagePair img {
  vertical-align: bottom;
}
.b_imagePair {
  display: flex;
}
.b_imagePair > * {
  flex-shrink: 0;
}
.b_imagePair > *:last-child,
.b_imagePair.reverse > *:first-child {
  flex: 0 1 100%;
}
.b_imagePair.reverse > *:last-child {
  flex: 0 0 auto;
}
.b_imagePair.reverse > *:only-child {
  flex: 0 1 100%;
}
.b_imagePair > *:last-child {
  margin-left: 12px;
}
.b_imagePair > *:only-child {
  flex: 0 1 100%;
  margin-left: 0;
  /* Override the margin back to 0 in case the first element is the last element */

}
/* vm=vertial middle. This can be used in control/component/views to vertically middle align the content of the element who uses this class. */

.b_vmparent {
  align-items: center;
}
/* end image/content horizontal pair */

button,
.button {
  /* The width and style are intentionally set separate so the color is not overridden */
  border-width: 3px;
  border-style: solid;
  padding/* bingcss-ignore TFS: 641967 - Fix existing whitelist files to be complaint with CSS Cop rules */: 8px 18px 12px;
}
.b_hPanel > span,
.b_footnote .cico,
.b_hList > li,
.b_title div,
.csrc/*csrc - Mobile Common Star Rating Control*/ {
  display: inline-block;
}
.b_hPanel > span {
  vertical-align: middle;
}
.b_title h2/* inline title prefix and suffix */ {
  display: inline;
}
.b_title .b_imagePair .rms_img {
  margin-top: 3px;
  /* align with the title */

}
.b_relative {
  position: relative;
}
.b_footnote .cico {
  padding-left: 10px;
}
#b_error div {
  padding-bottom: 20px;
}
/* floats */

.b_mhdr h2,
.b_float {
  float: left;
}
.b_floatR {
  float: right;
}
/* end floats */

.b_rTxt {
  text-align: right;
}
.b_cTxt {
  text-align: center;
}
.b_jTxt {
  text-align: justify;
}
select::-ms-expand {
  display: none;
}
select {
  padding-left: 10px;
  margin-bottom: 20px;
  height: 40px;
  border-radius: 0;
  vertical-align: middle;
  border: 1px solid #cccccc;
}
.b_moreLink {
  padding-bottom: 24px;
  display: block;
}
.b_moreLink .b_symb {
  vertical-align: middle;
  float: right;
}
.b_mhdr .b_floatR {
  margin-top/* bingcss-ignore: vertically align floated text in module header */: 4px;
}
.b_mhdr .b_moreLink {
  padding-bottom: 0;
}
.b_factrow:after {
  content: "";
}
/* results stack */

#b_results > li,
#b_pole .b_ans {
  padding/* bingcss-ignore:  Top padding is OK before first element in a container */: 12px 12px;
}
#b_results > li .b_fullb,
#b_pole .b_ans .b_fullb {
  margin-left: -12px;
  margin-right: -12px;
}
#b_pole .b_ans .b_fullb:first-child {
  margin-top/* bingcss-ignore: full bleed needs to eat the parent's top margin. */: -12px;
}
#b_results > li:not(:first-child) {
  border-top: 1px solid #eeeeee;
}
#b_pole .b_ans {
  margin-bottom: 4px;
}
#b_results > .b_ans,
#b_pole .b_ans {
  padding-bottom: 24px;
}
/* Uses a direct descendent selector because Spartan Insights nests a "SERP" in a single answer response and mistakenly labels all algos as answers.  Look for sptn_webresults in *.spark to see more. */

#b_results > .b_ans + .b_algo,
#b_results > .b_ans + .b_ans,
#b_results > .b_algo + .b_ans,
#b_results > .b_nav + .b_algo {
  margin-top/* bingcss-ignore:  Top margin is OK between ans+ans and ans+algo and algo+ans */: 4px;
  border-top: 8px solid #eeeeee;
}
#b_results > li > *:last-child,
.b_caption > *:last-child,
.vlist > li:last-child,
.b_vPanel > li:last-child,
.lft > *:last-child {
  margin-bottom: 0;
  padding-bottom: 0;
}
#b_results > .b_pag/* Task 1249184 : [Mobile 1st][wholepage] Paginiation - Remove legacy style after change ajax pagination */ {
  padding/* bingcss-ignore:  Top padding is OK before first element in a container */: 12px;
}
#b_tween/* Task 1249184 : [Mobile 1st][wholepage] Paginiation - Remove legacy style after change ajax pagination */ {
  padding/* bingcss-ignore:  Top padding is OK before first element in a container */: 8px 10px;
  margin: 0 12px;
}
/* end of results stack */

/* related search and deeplink */

#b_results > li > .b_rs,
/*override the rule of #b_results > li > *:last-child which default is 0*/ #b_results > li .b_deep/*override the rule of #b_results > li > *:last-child which default is 0*/ {
  margin-bottom: -12px;
}
.b_deep li > a,
.b_deep li > span > a {
  width: 110px;
  text-overflow: ellipsis;
  display: block;
  white-space: nowrap;
  overflow: hidden;
}
.b_rs > .b_rich {
  padding-bottom: 0;
}
/* end of related search */

.clrfix:after,
/* Task 1249184 : [Mobile 1st][wholepage] Paginiation - Remove legacy style after change ajax pagination */ .crch:after,
.b_imagePair:after,
.b_clearfix:after,
.sb_vdl:after {
  clear: both;
  content: '.';
  display: block;
  visibility: hidden;
  height: 0;
}
/* footer styles */

#ftrLnks li {
  display: inline-block;
  padding: 0 20px 15px 0;
}
#ftrLnks > *:last-child {
  padding-right: 0;
}
footer {
  padding/* bingcss-ignore:  Top padding is OK before first element in a container */: 15px 0 10px 10px;
}
/* begin table */

table {
  width: 100%;
}
th,
td {
  vertical-align: top;
  padding: 0 0 12px 12px;
}
th:first-child,
td:first-child {
  padding-left: 0;
}
th {
  text-align: left;
}
.b_caption > table:last-child tr:last-child td,
.b_caption > .b_vPanel:last-child > div:last-child > table:last-child tr:last-child td {
  padding-bottom: 0;
}
/* end table */

#fti3 {
  margin-bottom: 12px;
}
#id_rwds_b {
  margin-bottom: 20px;
  display: inline-block;
}
/*Label item styles*/

.b_label {
  padding-right: 4px;
}
/*Dropdown filter item styles*/

.b_dropdown {
  border: 1px solid #e1e0df;
  position: absolute;
  z-index: 6;
}
/*SubModule and SupplementaryModule*/

.b_subModule,
.b_suppModule {
  border-bottom-width: 1px;
  border-bottom-style: solid;
}
.b_subModule {
  padding-bottom: 24px;
  margin-bottom: 12px;
}
.b_suppModule {
  padding-bottom: 24px;
}
.b_subModule:last-child,
.b_suppModule:last-child {
  padding-bottom: 0;
  margin-bottom: 0;
  border-bottom: none;
}
/*End SubModule and SupplementaryModule*/

.nowrap {
  white-space: nowrap;
}
.pushpin {
  border-radius: 9px;
  text-align: center;
  width: 16px;
  height: 16px;
  margin-top: 2px;
  padding-bottom: 0;
  /* override label padding */
  line-height: 16px;
}
#b_results .b_no {
  margin-bottom: 80px;
}
.b_no h1,
.b_no h4,
.b_no li {
  padding-bottom: 10px;
}
.b_factrow .csrc {
  margin-right: 4px;
}
.sw_next,
.sw_prev {
  display: none;
}
.sb_pagIconN,
.sb_pagIconP {
  padding/* bingcss-ignore: to enlarge the click area, need top padding to center the icon */: 8px;
  margin-top/* bingcss-ignore: make sure next/prev icosn align with other pages */: 2px;
}
/*Entity Card*/

.b_infocardTop .b_entitySubTitle {
  padding-bottom: 4px;
}
/* BUGBUG 5346224: Use stack panel for rich facts of local entity card to get rid of b_xBottom styles */

.b_mBottom {
  padding-bottom: 4px;
}
.b_lBottom {
  padding-bottom: 8px;
}
.b_xxlBottom {
  padding-bottom: 16px;
}
.b_xxxlBottom {
  padding-bottom: 20px;
}
.wpc_tp .b_lBottom,
#b_pole .b_lBottom {
  padding-bottom: 12px;
}
.wpc_tp .b_swipable {
  margin-bottom: 12px;
}
/*Entity Card*/

.b_meta {
  padding-bottom: 4px;
}
/*Cortana Actions*/

.b_corActList {
  display: flex;
  padding-bottom: 24px;
}
.b_corActList li {
  display: inline-flex;
  flex: 1;
  text-align: center;
  padding: 0;
}
.b_corActList li:only-child {
  flex: none;
}
.b_corActList li:only-child a > * {
  display: inline-block;
  vertical-align: middle;
}
.b_corActList li:only-child a :first-child {
  margin-right: 8px;
}
.b_corActList li:not(:first-child) {
  border-left: 1px solid #eeeeee;
}
.b_corActList a {
  width: 100%;
}
.b_corActList li:not(:only-child) a > :first-child {
  margin-left: auto;
  margin-right: auto;
  display: block;
  margin-bottom: 8px;
}
.b_hList.b_corActList .cico {
  padding: 0;
}
/*End Cortana Actions*/

@media screen and (min-width: 641px) {
  .b_imagePair > *:last-child {
    margin-left: 24px;
  }
  .b_hList {
    padding-bottom: 24px;
  }
  .b_hPanel > span:not(:last-child),
  .b_hList > li:not(:last-child) {
    padding-right: 24px;
  }
  #b_pole .b_ans,
  #b_results > li,
  #b_results > .b_pag {
    padding-left: 24px;
    padding-right: 24px;
  }
  #b_results > li .b_fullb,
  #b_pole .b_ans .b_fullb {
    margin-left: -24px;
    margin-right: -24px;
  }
}
.sb_pag {
  clear: both;
  overflow: hidden;
}
.sb_pag > li {
  float: left;
  margin: 0;
  padding: 0;
  max-width: 160px;
}
.sb_pag a {
  margin: 0 12px 0 0;
  box-sizing: border-box;
  display: inline-block;
  padding/*bingcss-ignore: top padding by design in spec*/: 12px;
  cursor: pointer;
}
.sb_pagS {
  border-width: 1px;
  border-style: solid;
}
.sb_pag a:last-child {
  margin: 0;
}
a.sb_pagN .sb_pagIconN,
a.sb_pagP .sb_pagIconP {
  padding: 0;
  margin-top: 0;
}
.sb_pagIconN .sw_next,
.sb_pagIconP .sw_prev {
  display: inline-block;
  margin-top/*bingcss-ignore: fix to center icon*/: 2px;
}
.e_mhdr .b_symb {
  float: none;
}
.b_flexboxSpacer {
  flex: 1 auto;
}
.b_progressBar {
  height: 4px;
  width: 100%;
}
/*This file is intentionally left empty*/
z
{
    a:1;
}.b_snippet {
  font-size: 15px;
  line-height: 22px;
  padding-bottom: 4px;
}
h2 a,
h2 a:visited {
  color: black;
}
.b_focusTextLarge {
  font-size: 40px;
  line-height: 48px;
}
.b_focusTextMedium {
  font-size: 24px;
  line-height: 34px;
}
.b_focusTextSmall {
  font-size: 18px;
  line-height: 26px;
}
.b_focusTextExtraSmall {
  font-size: 15px;
  line-height: 22px;
}
.b_secondaryFocus {
  font-size: 18px;
  line-height: 26px;
}
.b_moreChevron:after {
  content: '';
  padding-left: 0;
}
.b_meta {
  padding: 0 0 4px 0;
}
.b_focusLabel {
  padding-bottom: 4px;
}
.b_dList > li > * {
  display: inline-flex;
}
h4 {
  color: black;
}
/*This file is intentionally left empty*/
z
{
    a:1;
}#b_results > li strong {
  color: #cc0000;
  font-weight: normal;
}
#b_results > li a {
  color: #0078d7;
}
.b_title .b_imagePair {
  display: flex;
}
.b_title .b_imagePair > *:last-child {
  margin-left: 5px;
}
.msn_answer_content .b_vList .b_imagePair {
  border-top: solid 1px #e1e1e1;
  padding/* bingcss-ignore keep the same style with mobile */: 10px 0;
}
.msn_answer_content .b_vList .b_imagePair h4 {
  padding-bottom: 0;
}
.msn_answer_content .b_vList > li:last-child .b_imagePair {
  border-bottom: solid 1px #e1e1e1;
}
.msn_answer_content .b_vList > li {
  padding-bottom: 0;
}
/*This file is intentionally left empty*/
z
{
    a:1;
}/* header colors for mobile threshold */

.b_scopebar {
  background-color: #eeeeee;
}
.b_scopebar,
.b_scopebar a,
.b_scopebar a:visited,
.b_mystuff:before,
#b_header .b_symb {
  color: #767676;
}
.b_scopebar li.b_active a,
.b_scopebar li.b_active a:visited,
.b_scopebar span {
  border-color: #f84e29;
  color: black;
}
.b_scopebar a,
.b_scopebar span
{
    text-decoration: none;
    text-transform:uppercase;
}

.b_mystuff
{
    font-size:12px;
    line-height: 16px;
    height: 18px;
}

.b_mystuff:before
{
    font-size:16px;
    vertical-align: middle;
}

.b_scopebar a
{
    text-transform: capitalize;
}/* Scopebar styles */

#b_header:not(:empty) {
  border-bottom: 1px solid #cccccc;
  position: fixed;
  top: 0;
  width: 100%;
  z-index/* bingcss-ignore: to keep consistent with legacy mobile */: 1000;
}
#b_header .b_symb {
  float: left;
  margin: 10px 10px 0 10px;
}
.b_scopebar li {
  margin: 0 10px;
  /* Use margin for sides instead of padding so the active bottom border displays correctly. */
  display: inline-flex;
}
.b_scopebar li:last-child,
.b_mystuff {
  margin-right: 12px;
  flex: none;
}
.b_scopebar li:first-child {
  margin-left: 12px;
}
.b_scopebar ul {
  overflow-x: auto;
  white-space: nowrap;
  -ms-overflow-style: none;
}
.b_scopebar a,
.b_scopebar span,
.b_mystuff {
  padding/* bingcss-ignore: vertically align with padding */: 12px 0;
}
.b_scopebar li.b_active a,
.b_scopebar li.b_active span {
  padding-bottom: 10px;
  border-bottom-width: 2px;
  border-bottom-style: solid;
}
@media screen and (min-width: 641px) {
  #b_header nav li:first-child {
    margin-left: 0;
  }
  #b_header nav li:last-child {
    margin-right: 0;
  }
  #b_header nav,
  header nav {
    padding: 0 24px;
  }
}
.b_mystuff {
  display: block;
  text-align: right;
}
.b_mystuff:before {
  padding-right: 12px;
}
.linkAction {
  padding-bottom: 24px;
}
/*This file is intentionally left empty*/
z
{
    a:1;
}.b_accentColor,.b_accentColor strong,strong.b_accentColor,strong .b_accentColor,.qcard a,#sb_feedback,.b_anno,.appifyCaptionAccent,#b_results a.b_accentColor,#b_results a.b_accentColor:visited{color:#08517b;}.b_accentColorStroke{stroke:#08517b;}.b_accentColorFill{fill:#08517b;}input[type="text"]:focus{border-color:#08517b;}.b_accentColorBackground,select:active,.cbtn.b_highlighted input.b_accentColorBackground{background-color:#08517b;}.b_accentColorBorder{border-color:#08517b;}select{color:#08517b;}select::-ms-expand{color:#08517b;}.b_moreLink,.b_moreLink:visited,#b_results .b_moreLink,#b_results .b_moreLink:visited{color:#08517b;}.sml,.sml a,.sml a:visited,.btm_sml a,.btm_sml a:visited{color:#08517b;}</style><link rel="stylesheet" href="/rms/rms%20answers%20Web%20CoreStyles$CortanaMDLSymbols/nc/e5a3fa08/48324069.css" type="text/css"><style type="text/css">/* Square - Medium Icon 24 x 24 */

.square_mi {
  width: 24px;
  height: 24px;
  font-size: 24px;
  line-height: 24px;
}
/* End Square - Medium Icon*/

</style><style type="text/css">.b_select{background-color:#b4cad7;border-color:#08517b;}</style><script type="text/javascript">//<![CDATA[
// Declaring Feature Team ID for Win8App Error Handling
// <feature  id="8"  />
var amd;
(function (amd) {
    var defineMap = {};
    var cache = {};
    var initialized = false;
    function define(moduleName, dependencies, callback) {
        if (!defineMap[moduleName]) {
            defineMap[moduleName] = {
                dependencies: dependencies,
                callback: callback
            };
            // Invoke this module as it is registered
            require(moduleName);
        }
    }
    function require(requestedModuleName) {
        if (!requestedModuleName) {
            // Initialize all the modules and return the cache
            if (!initialized) {
                for (var moduleName in defineMap) {
                    requireModule(moduleName);
                }
                initialized = true;
            }
            return cache;
        }
        else if (requestedModuleName) {
            // Initialize just the module asked for
            return requireModule(requestedModuleName);
        }
    }
    function requireModule(moduleName) {
        // This should break the recursion in case of circular dependency
        if (cache[moduleName]) {
            return cache[moduleName];
        }
        // If the module has a define entry
        if (defineMap.hasOwnProperty(moduleName)) {
            // Create this module
            var moduleDetails = defineMap[moduleName];
            var deps = moduleDetails.dependencies;
            var callback = moduleDetails.callback;
            // add req and exports as first two dependencies
            var req = require;
            var exports = {};
            var dependencies = [req, exports];
            if (deps.length < 2) {
                throw "invalid usage";
            }
            else if (deps.length > 2) {
                // Recursively fetch dependencies
                var dependentModules = deps.slice(2, deps.length);
                for (var i = 0; i < dependentModules.length; i++) {
                    dependencies.push(requireModule(dependentModules[i]));
                }
            }
            // Call the callback -- this should add objects to exports
            // This means we do not support the callback itself returning an object.
            // It should be simple to support that. For now, STRADA generates
            // exports syntax.
            callback.apply(this, dependencies);
            // Cache the module
            cache[moduleName] = exports;
            return exports;
        }
    }
    amd.define = define;
    amd.require = require;
})(amd || (amd = {}));
var define = amd.define;
var require = amd.require;
;/// <reference path='../Declarations/Threshold.Utilities.d.ts' />
/// <reference path="../../../../../Threshold/src/Content/Script/Declarations/SearchAppWrapper.d.ts" />
// BUGBUG: TFS 780914: TypeScript throws build error when two ts file declare the same variable
var _w = window, _d = document, sb_ie = window["ActiveXObject"] !== undefined, sb_i6 = sb_ie && !_w["XMLHttpRequest"], _ge = function (id) { return _d.getElementById(id); }, sb_st = function (code, delay) { return setTimeout(code, delay); }, sb_rst = sb_st, sb_ct = function (id) {
    clearTimeout(id);
}, sb_gt = function () { return new Date().getTime(); }, sj_gx;
_w["sj_ce"] = function (tagName, id, cssClass) {
    var el = _d.createElement(tagName);
    if (id) {
        el.id = id;
    }
    if (cssClass) {
        el.className = cssClass;
    }
    return el;
};
// Under certain circumstances the clientCookies script
// fails to get added from frontdoor. Declaring sk_merge
// if it isn't already defined.
if (!_w["sk_merge"]) {
    _w["sk_merge"] = function (cookieHeader) {
        _d.cookie = cookieHeader;
    };
}
var AjaxWrapperThreshold = (function () {
    function AjaxWrapperThreshold() {
    }
    AjaxWrapperThreshold.applyMethodThatRequiresOpened = function (xhrObject, method, originalArguments) {
        /* send and setRequestHeader can only be done on xhr requests that are currently opened: http://www.w3.org/TR/2009/WD-XMLHttpRequest-20090820/#opened-state */
        if (xhrObject.readyState == xhrObject.OPENED) {
            method.apply(xhrObject, originalArguments);
            return true;
        }
        return false;
    };
    AjaxWrapperThreshold.wrapSend = function (originalObject, originalMethod) {
        var wrappedMethod = function () {
            var originalArguments = arguments;
            if (!AjaxWrapperThreshold.isRequestBlocked(originalObject) && originalObject.readyState == originalObject.OPENED) {
                // If we're sending to bing, we need to append custom client headers.
                // Some old Threshold app webviews do not have a SearchAppWrapper.  Those can just make the XHR call directly and hope for the best.
                if (typeof ThresholdUtilities !== "undefined" && SearchAppWrapper && SearchAppWrapper.CortanaApp && AjaxWrapperThreshold.hostIsBing(originalObject.url)) {
                    ThresholdUtilities.getCortanaHeaders(function (headers) {
                        if (headers) {
                            var xhrHeaders = originalObject[AjaxWrapperThreshold.headersLocation];
                            for (var headerName in headers) {
                                if (headers.hasOwnProperty(headerName) && (headerName.substring(0, 2) === "X-" || AjaxWrapperThreshold.copyableHeaders.indexOf(headerName) >= 0)) {
                                    if (!xhrHeaders[headerName]) {
                                        originalObject.setRequestHeader(headerName, headers[headerName]);
                                    }
                                }
                            }
                        }
                        AjaxWrapperThreshold.setFlightHeaders(originalObject);
                        AjaxWrapperThreshold.applyMethodThatRequiresOpened(originalObject, originalMethod, originalArguments);
                    });
                }
                else {
                    if (AjaxWrapperThreshold.hostIsBing(originalObject.url)) {
                        AjaxWrapperThreshold.setFlightHeaders(originalObject);
                    }
                    AjaxWrapperThreshold.applyMethodThatRequiresOpened(originalObject, originalMethod, originalArguments);
                }
            }
            else {
                // If we need to block the send we simulate that we did it successfully so no retries are triggered.
                Object.defineProperties(originalObject, {
                    "readyState": { get: function () {
                        return 4;
                    } },
                    "status": { get: function () {
                        return 200;
                    } },
                    "responseText": { get: function () {
                        return "";
                    } },
                    "responseBody": { get: function () {
                        return "";
                    } }
                });
                if (originalObject.onreadystatechange) {
                    originalObject.onreadystatechange.apply(originalObject, null);
                }
            }
        };
        return wrappedMethod;
    };
    AjaxWrapperThreshold.wrapOpen = function (originalObject, originalMethod) {
        var wrappedMethod = function () {
            // We always pass through open calls, but we record the url on the object.
            originalObject.url = arguments[1];
            originalMethod.apply(originalObject, arguments);
        };
        return wrappedMethod;
    };
    AjaxWrapperThreshold.wrapSetRequestHeader = function (originalObject, originalMethod) {
        return function (headerKey, headerValue) {
            var successfulApply = AjaxWrapperThreshold.applyMethodThatRequiresOpened(originalObject, originalMethod, arguments);
            if (successfulApply) {
                var originalObjectHeaders = originalObject[AjaxWrapperThreshold.headersLocation];
                if (originalObjectHeaders[headerKey]) {
                    originalObjectHeaders[headerKey].push(headerValue);
                }
                else {
                    originalObjectHeaders[headerKey] = [headerValue];
                }
            }
            return successfulApply;
        };
    };
    AjaxWrapperThreshold.hostIsBing = function (url) {
        // Assume it's Bing if we can't prove otherwise
        var returnValue = true;
        AjaxWrapperThreshold.testAnchor.href = url;
        var hostName = AjaxWrapperThreshold.testAnchor.hostname;
        if (hostName && hostName.indexOf(".") > 0) {
            var matchedAnyHost = false;
            for (var i in this.bingHosts) {
                if (hostName.indexOf(this.bingHosts[i]) > 0) {
                    matchedAnyHost = true;
                    break;
                }
            }
            if (!matchedAnyHost) {
                returnValue = false;
            }
        }
        return returnValue;
    };
    AjaxWrapperThreshold.blockRequestWrapper = function (originalObject) {
        var _this = this;
        return function () {
            return _this.isRequestBlocked(originalObject);
        };
    };
    AjaxWrapperThreshold.isRequestBlocked = function (originalObject) {
        return typeof SearchAppWrapper !== "undefined" && SearchAppWrapper && SearchAppWrapper.CortanaApp && !SearchAppWrapper.CortanaApp.isBingEnabled && AjaxWrapperThreshold.hostIsBing(originalObject.url);
    };
    AjaxWrapperThreshold.createAjaxWrapper = function () {
        var wrappedObject = new XMLHttpRequest();
        wrappedObject[this.headersLocation] = {};
        wrappedObject.send = this.wrapSend(wrappedObject, wrappedObject.send);
        wrappedObject.open = this.wrapOpen(wrappedObject, wrappedObject.open);
        wrappedObject.setRequestHeader = this.wrapSetRequestHeader(wrappedObject, wrappedObject.setRequestHeader);
        wrappedObject.isRequestBlocked = this.blockRequestWrapper(wrappedObject);
        return wrappedObject;
    };
    AjaxWrapperThreshold.setFlightHeaders = function (request) {
        // set http headers for setting external flights
        if (typeof (_CachedFlights) !== "undefined" && _CachedFlights.sort) {
            var headersSet = request[AjaxWrapperThreshold.headersLocation];
            if (!headersSet[AjaxWrapperThreshold.externalExpType]) {
                request.setRequestHeader(AjaxWrapperThreshold.externalExpType, "JointCoord");
            }
            if (!headersSet[AjaxWrapperThreshold.externalExp]) {
                request.setRequestHeader(AjaxWrapperThreshold.externalExp, _CachedFlights.sort().join(","));
            }
        }
    };
    AjaxWrapperThreshold.bingHosts = [".bing.com", ".staging-bing-int.com", ".working-bing-int.com", ".bing-int.com", ".bing-exp.com"];
    AjaxWrapperThreshold.testAnchor = document.createElement("a");
    AjaxWrapperThreshold.externalExpType = "X-MSEdge-ExternalExpType";
    AjaxWrapperThreshold.externalExp = "X-MSEdge-ExternalExp";
    AjaxWrapperThreshold.headersLocation = "headers";
    AjaxWrapperThreshold.copyableHeaders = ["Authorization"];
    return AjaxWrapperThreshold;
})();
sj_gx = function () { return AjaxWrapperThreshold.createAjaxWrapper(); };
;///<reference path="..\Declarations\Shared.d.ts"/>
function lb() {
    _w["si_sendCReq"] && sb_st(_w["si_sendCReq"], 800);
    // look for any other scripts that needs to be called/initialized, and call them
    // we need a cleaner way to allow other scripts to register for a callback during onload
    // initialization (Bug 94997)
    _w["lbc"] && _w["lbc"]();
}
;///<reference path="..\Declarations\Shared.d.ts"/>
// This files modifies appendChild function to check if a SCRIPT tag is being appended.
// If yes and the script tag does not have a src attribute i.e. it is an inlined script
// then a "//@ sourceURL=BingDynamicScriptX.js" comment is added to the script so that
// modern browsers can parse it and add it to the javascript sources in debug window.
(function () {
    var scriptCount = 0;
    var scriptPrefix = "//@ sourceURL=BingDynamicScript";
    var scriptSuffix = ".js\n";
    if (window["Element"] && Element.prototype && window.location.pathname.indexOf("/mapspreview") !== 0) {
        var appendChild = Element.prototype.appendChild;
        Element.prototype.appendChild = function (elem) {
            if (elem && elem.tagName === "SCRIPT" && !elem.src && elem.textContent) {
                // Adding the sourceURL comment to the beginning of the file in case someone already
                // has this logic for their specific file then the latest one will take effect
                elem.textContent = scriptPrefix + scriptCount + scriptSuffix + elem.textContent;
                scriptCount++;
            }
            return appendChild.apply(this, arguments);
        };
    }
})();
;
//]]></script><script type="text/javascript" src="/rms/BingCore.Bundle/nj/0d3e0b8b/a508bb67.js?bu=rms+answers+Shared+BingCore%24ClientInstV2%24DuplicateXlsDefaultConfig%2cBingCore%24ClientInstV2%24SharedLocalStorageConfigDefault%2cBingCore%24shared%2cBingCore%24env.override%2cBingCore%24event.custom.fix%2cBingCore%24event.native%2cBingCore%24dom%2cBingCore%24cookies_parser%2cBingCore%24XHRPrefetch%24rmsajax_xhrprefetch%2cBingCore%24ClientInstV2%24InstrumentationConfigDefault%2cBingCore%24ClientInstV2%24LogUploadCapFeatureDisabled%2cBingCore%24ClientInstV2%24ClientInstConfigSeparateOfflineQueue%2cBingCore%24ClientInstV2%24clientinst_xls%2cEmpty%2cBingCore%24CoreUtilities%2cBingCore%24ClientInstV2%24LogHelper%2cBingCore%24ClientInstV2%24VisibilityChangeEventHelper%2cBingCore%24Animation%2cBingCore%24fadeAnimation%2cBingCore%24framework%2cBingCore%24ShowWebView%2cBingCore%24ClientInstV2%24LogOfflineFalseConfig%2cEmpty"></script><script type="text/javascript">//<![CDATA[
var SloppyClickHandler;
(function (SloppyClickHandler) {
    var listTag = ["LI", "TR"];
    var tableTag = ["TR"];
    var anchorTag = ["A"];
    var inputTag = ["INPUT", "SELECT"];
    var getElementsByTagName = "getElementsByTagName";
    var notTargetElementClass = "b_noTarget";
    var poleContainerClassName = "b_poleContent";
    var space = " ";
    function findCardFromElement(element) {
        var link = getParentContainer(element, anchorTag);
        var returnObject = { element: element, card: link, link: link, containsLink: true };
        var input = getParentContainer(element, inputTag);
        if (!input) {
            var card = getParentContainer(element, listTag, poleContainerClassName);
            if (card) {
                // If there's only one viable link in the entire LI then we'll use it by default
                var viableLink = findLinkInAnchorTags(card);
                // If the link is not found in the table, try again at levels above it
                // Won't work for nested tables or lists
                if (!viableLink && tableTag.indexOf(card.tagName) >= 0) {
                    card = getParentContainer(card.parentNode, listTag, poleContainerClassName);
                    viableLink = findLinkInAnchorTags(card);
                }
                // If there's more than one link we still need to see if there's a header common control.  If there's a single
                // header control we're willing to shift the click to that.
                if (!viableLink && card && _w['TCH']) {
                    var reservedTags = _w['TCH'].rTags;
                    for (var i = 0; i < reservedTags.length; i++) {
                        viableLink = getViableLinkFromList(card[getElementsByTagName](reservedTags[i]));
                        if (viableLink) {
                            break;
                        }
                    }
                }
                if (viableLink && (!link || viableLink === link)) {
                    returnObject = { element: element, card: card, link: viableLink, containsLink: true };
                }
            }
        }
        else {
            returnObject = null;
        }
        // Don't return anything if we don't have a link.
        if (returnObject && !returnObject.link) {
            returnObject = null;
        }
        // If we have a link, but it's the same as or a parent of our source element we mark the object as non-clickable.
        // Clicking is not required here as normal event bubbling will work.
        // But we do need to track the object still, as it is animatable.
        if (returnObject && (containsElement(returnObject.link, element) || returnObject.link === returnObject.element)) {
            returnObject.containsLink = false;
        }
        return returnObject;
    }
    SloppyClickHandler.findCardFromElement = findCardFromElement;
    var containsElement = function (parent, element) {
        if (element) {
            var candidates = parent[getElementsByTagName](element.tagName);
            for (var i = 0; i < candidates.length; i++) {
                if (candidates[i] === element) {
                    return true;
                }
            }
        }
        return false;
    };
    var getViableLinkFromList = function (elements) {
        var viableLink = null;
        for (var i = 0; i < elements.length; i++) {
            var possibleLink = findLinkInAnchorTags(elements[i]);
            if (possibleLink) {
                if (!viableLink) {
                    viableLink = possibleLink;
                }
                else if (possibleLink.href !== viableLink.href) {
                    // We found more than one heading with a viable link - the click is ambiguous so there is no click.
                    viableLink = null;
                    break;
                }
            }
            else if (elements[i][getElementsByTagName](anchorTag).length > 1) {
                // A single header has more than one link, and they're not viable - we're confused so we stop.
                viableLink = null;
                break;
            }
        }
        return viableLink;
    };
    var isViableLink = function (element) { return element && element.className.indexOf(notTargetElementClass) < 0; };
    var findLinkInAnchorTags = function (element) {
        var viableLink = null;
        if (element) {
            var anchorTags = element[getElementsByTagName](anchorTag);
            var anchorTagCount = anchorTags.length;
            var linksMatch = true;
            var matchingLink = null;
            var firstLinkUrl = null;
            for (var i = 0; i < anchorTagCount; i++) {
                /* Only compare the viable links */
                if (isViableLink(anchorTags[i])) {
                    if (!firstLinkUrl) {
                        matchingLink = anchorTags[i];
                        firstLinkUrl = anchorTags[i].href;
                    }
                    else if (firstLinkUrl !== anchorTags[i].href) {
                        linksMatch = false;
                        break;
                    }
                }
            }
            /* We need to have found at least one viable link */
            if (linksMatch && firstLinkUrl) {
                viableLink = matchingLink;
            }
        }
        return viableLink;
    };
    var getParentContainer = function (target, tags, className) {
        for (; target !== document && target; target = target.parentNode) {
            if (target) {
                for (var i = 0; i < tags.length; ++i) {
                    if (target.tagName === tags[i] || (className && target.className && (space + target.className + space).indexOf(space + className + space) >= 0)) {
                        return target;
                    }
                }
            }
        }
    };
})(SloppyClickHandler || (SloppyClickHandler = {}));
;///<reference path="..\Declarations\Shared.d.ts"/>
///<reference path="..\..\..\..\..\Web\Content\Content\Script\Declarations\SloppyClickHandler.d.ts"/>
// See Hyperlink and FdHyperlink at the FD for what this all means
// BUGBUG: TFS 780914: TypeScript throws build error when two ts file declare the same variable
_w["si_ct"] = function (el, noRecurse, evt) {
    var getAttribute = "getAttribute", ct, ctf, found;
    try {
        for (; el !== document.body; el = el.parentNode) {
            // The 'h' or '_ct' attribute contains the payload for the click tracking function
            // Stop on the first anchor with an 'h' attribute or the first element found with a '_ct' attribute present
            ct = (el.tagName == "A" && el[getAttribute]("h")) || el[getAttribute]("_ct") || el[getAttribute]("data-h");
            if (ct) {
                // The '_ctf' attribute contains the name of the overriden global click
                // tracking function which is optional, default is si_T
                ctf = el[getAttribute]("_ctf");
                var clickType = -1;
                if (evt != null && evt.button != null) {
                    clickType = evt.button;
                }
                if (!ctf || !_w[ctf]) {
                    ctf = "si_T";
                }
                // Try to fire the gping by calling the click-tracking function with the 'ct' payload and the clicked element
                _w[ctf] && _w[ctf]('&' + ct, el, evt, clickType);
                break;
            }
            if (noRecurse)
                break;
        }
    }
    catch (ignored) {
    }
    return true;
};
(function () {
    function leftClickHandler(evt) {
        _w["si_ct"](sb_ie ? _w.event.srcElement : evt.target, false, _w.event || evt);
    }
    function rightClickHandler(evt) {
        var clickedObject = _w["SloppyClickHandler"] ? SloppyClickHandler.findCardFromElement(sj_et(evt)) : null;
        var target = (clickedObject && clickedObject.link) ? clickedObject.link : (sb_ie ? _w.event.srcElement : evt.target);
        _w["si_ct"](target, false, _w.event || evt);
    }
    if (_w["_G"]) {
        _G["si_ct_e"] = "click";
    }
    // sj_be: Indicates bubble-phase handler (supported on all browsers as opposed to capture which IE doesn't support)
    sj_be(document, "click", leftClickHandler, false);
    sj_be(document, "contextmenu", rightClickHandler, false);
})();
;var wlc_d = 1500, wlc_t =63601558713;;var perf;
(function (perf) {
    var perfKeyArray = [
        "redirectStart",
        "redirectEnd",
        "fetchStart",
        "domainLookupStart",
        "domainLookupEnd",
        "connectStart",
        "secureConnectionStart",
        "connectEnd",
        "requestStart",
        "responseStart",
        "responseEnd",
        "domLoading",
        "domInteractive",
        "domContentLoadedEventStart",
        "domContentLoadedEventEnd",
        "domComplete",
        "loadEventStart",
        "loadEventEnd",
        "unloadEventStart",
        "unloadEventEnd",
        "firstChunkEnd",
        "secondChunkStart",
        "htmlEnd",
        "pageEnd",
        "msFirstPaint"
    ];
    var versionString = "v:1.1";
    // For now the key compression is based on array index. The assumption is 
    // that this is a fixed list that will not change often and tightly contolled.
    // This is not very flexible as any addition in between can essentially
    // break the reporting side. Two possible solutions to try would be to
    // have the keyMap logged in nif. Advantage of this would be it is easy to
    // maintain but the disadvantage is no real time reporting. The other way
    // to have a package that defines the keyMap. Advantage is the keyMap can 
    // be consumed by multiple sources but the disadvantage is it would need 
    // version control.
    var perfKeyMap = {};
    var i;
    for (i = 0; i < perfKeyArray.length; i++) {
        perfKeyMap[perfKeyArray[i]] = i;
    }
    function compressKey(key) {
        return perfKeyMap.hasOwnProperty(key) ? perfKeyMap[key] : key;
    }
    function typeToString(type) {
        var typeString = "S";
        if (type == 0 /* Mark */) {
            typeString = "P";
        }
        else if (type == 2 /* Measure */) {
            typeString = "M";
        }
        return typeString;
    }
    // Creates an array of strings that are essentially are of the form "${key}:${value}"
    function compress(q) {
        var data = [];
        var typeArrays = {}, typeArray;
        for (var i = 0; i < q.length; i++) {
            var obj = q[i];
            var value = obj.v, qType = obj.t, key = obj.k;
            if (qType === 0 /* Mark */) {
                key = compressKey(key);
                value = value.toString(36);
            }
            if (qType === 3 /* None */) {
                data.push("" + key + ":" + value);
            }
            else {
                typeArray = typeArrays[qType] = typeArrays[qType] || [];
                typeArray.push("" + key + ":" + value);
            }
        }
        for (var t in typeArrays) {
            if (typeArrays.hasOwnProperty(t)) {
                typeArray = typeArrays[t];
                data.push("" + typeToString(t) + ":\"" + typeArray.join(",") + "\"");
            }
        }
        data.push(versionString);
        return data;
    }
    perf.compress = compress;
})(perf || (perf = {}));
;///<reference path="..\..\..\..\..\Shared\Content\Content\script\Declarations\Shared.d.ts"/>
window["perf"] = window["perf"] || {};
(function (perf) {
    perf.log = function (perfData, time) {
        var data = perf.compress(perfData);
        data.push("T:\"CI.Perf\",FID:\"CI\",Name:\"PerfV2\"");
        var url = "/fd/ls/lsp.aspx?";
        var sendBeacon = "sendBeacon";
        // if eventData contains the raw string "]]>", it'll end the CDATA section prematurely
        var eventXML = "<E><T>Event.ClientInst</T><IG>" + _G.IG + "</IG><TS>" + time + "</TS><D><![CDATA[{" + data.join(",") + "}]]></D></E>";
        var xml = "<ClientInstRequest><Events>" + eventXML + "</Events><STS>" + time + "</STS></ClientInstRequest>";
        if (!_w.navigator || !navigator[sendBeacon] || !navigator[sendBeacon](url, xml)) {
            var request = sj_gx();
            request.open("POST", url, true);
            request.setRequestHeader("Content-Type", "text/xml");
            request.send(xml);
        }
    };
})(window["perf"]);
;///<reference path="..\..\..\..\..\Shared\Content\Content\script\Declarations\Shared.d.ts"/>
var perf;
(function (perf) {
    var perfName = "performance";
    var hasPerformanceObject = !!_w[perfName];
    var perfObj = _w[perfName];
    var highResTimeAvailable = hasPerformanceObject && !!perfObj.now;
    var roundOf = Math.round;
    var q = [];
    // The data is only flushed after the first time flush is called.
    // We bind flush to onload so that pings are restricted to before onload.
    var firstFlushCalled = false;
    var navigationStart;
    var startTimestamp;
    if (hasPerformanceObject) {
        navigationStart = startTimestamp = perfObj.timing.navigationStart;
    }
    else {
        startTimestamp = _w["si_ST"] ? _w["si_ST"] : +new Date();
    }
    function createUniqueId() {
        return roundOf(Math.random() * 10000);
    }
    var uniqueId = createUniqueId();
    function getTime() {
        if (highResTimeAvailable) {
            return roundOf(perfObj.now()) + navigationStart;
        }
        else {
            return +new Date;
        }
    }
    function queue(key, value, qType) {
        if (q.length === 0 && firstFlushCalled) {
            sb_st(flush, 1000);
        }
        q.push({ k: key, v: value, t: qType });
    }
    function setStartTime(time) {
        if (!firstFlushCalled) {
            startTimestamp = time;
        }
        return !firstFlushCalled;
    }
    perf.setStartTime = setStartTime;
    function mark(key, value) {
        if (!value) {
            value = getTime();
        }
        queue(key, value, 0 /* Mark */);
    }
    perf.mark = mark;
    function record(key, value) {
        queue(key, value, 1 /* Record */);
    }
    perf.record = record;
    function flush() {
        if (q.length) {
            for (var i = 0; i < q.length; i++) {
                var obj = q[i];
                if (obj.t === 0 /* Mark */) {
                    obj.v -= startTimestamp;
                }
            }
            q.push({ k: "id", v: uniqueId, t: 3 /* None */ });
            perf.log(q, getTime());
            q = [];
            firstFlushCalled = true;
        }
    }
    perf.flush = flush;
    function reset() {
        startTimestamp = getTime();
        uniqueId = createUniqueId();
        firstFlushCalled = false;
        sj_evt.bind("onP1", flush);
    }
    perf.reset = reset;
    sj_be(window, "load", flush, false);
    sj_be(window, "beforeunload", flush, false);
})(perf || (perf = {}));
;///<reference path="..\..\..\..\..\..\Shared\Content\Content\script\Declarations\Shared.d.ts"/>
// Performance ping instrumentation for browsers supporting the W3C Web Timing API.
// si_PP() is the PerformancePing function used to report back performance data.
// currentTime - a javascript Date object
// state - "A" for abandoned, "L" for load.
// This function is called after pageload. However, some verticals may
// choose to call it at a different time, after setting the sb_ppCPL (custom page load) flag
_w.si_PP = function (currentTime, state, ajaxRequest) {
    // Only fire one perf ping
    if (_G.PPS) {
        return;
    }
    // Include the impression GUID (IG)
    // The DATA field contains a JSON blob of the event.
    // pp is the name of the event.
    // S is the status to report, from parameter b.
    // PC is the elapsed time between when the <BODY> tag is opened (_G.PCT) and the start time
    // FC is the elapsed time between when the first chunk is complete (_G.FCT) and the start time.
    //    For non-CTE rendering, the value is -1
    // BC is the elapsed time between when the second chunk arrives (_G.BCT) and the start time.
    //    If there is no second chunk, the timer is inserted right after _G.PPCT
    // BS is the elapsed time between right before the BOP scripts are inserted (_G.BST) and the start time
    // H is the elapsed time between when the HTML finished being downloaded and the last inline script got executed (_G.HT), and the start time
    // FE is the elapsed time between the beginning of the first embeded image chunk and the start time, if there are embedded image chunks
    //    Otherwise, the value is -1
    // LE is the elapsed time between the end of last embedded image chunk and the start time, if there are embedded image chunks
    //    Otherwise, the value is -1
    // C1 and C2 are custom ppMetrics, available in each vertical to be overridden with vertical specific elapsed times from the start time.
    //    To use, a page can simply set
    //           _G.C1T=new Date()
    // BP is the elapsed time between when the pageLoad event begins (_G.BPT) and the start time.
    // KP is the page's KeyPoint - the point the page's owner has decided is key to users.
    //    For example, on the SERP, this could be when web results and top answers are loaded, but not BOP answers.
    //    To use, insert the following in-lined JS to the place of interest
    //           _G.KPT=new Date()
    // CT is the total client elapsed time to "Page Load", calculated from the difference between the currentTime parameter and _G.ST
    // IL is the numbers of images
    // If CID is explicitly specified in the response
    //    it should be included in our instrumention as well
    // Collect a small number of PerfPing Metrics
    // --------------------------------------------------
    var key;
    var ppMetrics = ['FC', 'BC', 'H', 'BP', null];
    while (key = ppMetrics.shift()) {
        ppMetrics.push('"' + key + '":' + (_G[key + 'T'] ? _G[key + 'T'] - _G.ST : -1));
    }
    // --------------------------------------------------
    var w3cTimings = ajaxRequest || (_w.performance && _w.performance.timing);
    var w3cPayload = null;
    if (w3cTimings) {
        var w3cFields = [
            "unloadEventStart",
            "unloadEventEnd",
            "redirectStart",
            "redirectEnd",
            "fetchStart",
            "domainLookupStart",
            "domainLookupEnd",
            "connectStart",
            "connectEnd",
            "secureConnectionStart",
            "requestStart",
            "responseStart",
            "domLoading",
            "domInteractive",
            "domContentLoadedEventStart",
            "domContentLoadedEventEnd",
            "domComplete",
            "loadEventStart",
            "loadEventEnd",
            "msFirstPaint",
            "responseEnd",
            ""
        ];
        // Check that navigationStart is a number >= 0
        var navigationStart = w3cTimings.navigationStart;
        if (navigationStart >= 0) {
            var i, t, mask, prev;
            for (mask = prev = i = 0; key = w3cFields.shift(); i++) {
                t = w3cTimings[key];
                if (t > 0) {
                    mask |= 1 << i;
                    t -= navigationStart;
                    w3cFields.push(t === prev ? '' : (t - prev).toString(16));
                    prev = t;
                }
            }
            var navigation = "navigation";
            w3cPayload = ',"w3c":"' + mask.toString(16) + "," + w3cFields.join() + '","nav":' + (navigation in w3cTimings ? w3cTimings[navigation] : performance[navigation].type);
        }
    }
    // NOTE: Any changes to the following part of the string 'DATA={"pp":{' should be communicated to lsdmft because
    //       they could break some features dependent on PP.
    var payLoad = '{"pp":{"S":"' + (state || 'L') + '",' + ppMetrics.join(',') + ',"CT":' + (currentTime - _G.ST) + ',"IL":' + _d.images.length + '}' + (_G.C1 ? ',' + _G.C1 : '') + (w3cPayload !== null ? w3cPayload : '') + '}';
    if (_w['Log2']) {
        Log2.LogEvent("CPT", JSON.parse(payLoad), null, null, null, null, null, null);
    }
    else {
        _G.PPImg = new Image();
        _G.PPImg.src = _G.lsUrl + '&Type=Event.CPT&DATA=' + payLoad + (_G.P ? '&P=' + _G.P : '');
    }
    _G.PPS = 1; // flag set if perfping has fired
    sb_st(function () {
        sj_evt.fire('onPP');
        sj_evt.fire(_w.p1);
    }, 1);
};
// Bind onbefore unload so we can capture the cases of people leaving the page before
// it has loaded (called the abandon state, denoted as 'A').
// Note that onbeforeunload is bound to directly because this should be just about the very first script executing on the page,
// so we don't have to worry about tromping on an existing event handler.
_w.onbeforeunload = function () {
    si_PP(new Date, 'A');
};
;///<reference path="..\..\..\answers\services\Shared\Content\Content\script\Declarations\Shared.d.ts"/>
(function (perfping) {
    if (document.querySelector) {
        var logText = [];
        var customField = "ad";
        function run() {
            var start = sb_gt();
            var de = document.documentElement;
            var body = document.body;
            var adsHeight = -1;
            var adsTop = -1;
            var fold = de.clientHeight;
            var selectors = ["#b_results .b_ad", ".sb_adsWv2", ".ads"];
            // Do not attempt to log anything if body itself is missing
            if (!body)
                return;
            for (var i = 0; i < selectors.length; i++) {
                var selector = selectors[i];
                var ads = document.querySelector(selector);
                if (ads && ads.offsetTop < fold) {
                    adsHeight = ads.offsetHeight;
                    adsTop = ads.offsetTop;
                    break;
                }
            }
            // Data in following order: Ads Top, Ads Height, Viewport Width, Viewport Height, Page Width, Page Height, Cost
            logText = [adsTop, adsHeight, de.clientWidth, fold, body.offsetWidth, body.offsetHeight, sb_gt() - start];
        }
        // Adding payload to perf-ping
        if (perfping) {
            var fn = perfping.onbeforefire;
            perfping.onbeforefire = function () {
                if (fn)
                    fn();
                run();
                perfping.mark(customField, logText);
            };
        }
        else {
            var fn = si_PP;
            si_PP = function () {
                run();
                var customLog = '"' + customField + '":[' + logText.join() + ']';
                _G.C1 = _G.C1 ? _G.C1 + ',' + customLog : customLog;
                fn.apply(null, [].slice.apply(arguments));
            };
        }
    }
})(_w["pp"]);
;///<reference path="..\..\..\..\..\..\Shared\Content\Content\script\Declarations\Shared.d.ts"/>
(function (fn) {
    function extractTimestampParam(qs, key) {
        var param = '&' + key + '=';
        var pos = qs.indexOf(param);
        if (pos < 0) {
            return -1;
        }
        var offset = pos + param.length;
        var ts = qs.substr(offset);
        return parseInt(ts, 10);
    }
    _w.si_PP = function (currentTime, state) {
        var t = _w.performance && _w.performance.timing;
        if (t) {
            var data = '"NS":"' + t.navigationStart + '"';
            var location = window.location;
            var qs = window.location && location.search;
            if (qs) {
                var st = extractTimestampParam(qs, "sbts");
                if (!st || st < 0) {
                    var nclidts = extractTimestampParam(qs, "nclidts");
                    var tsms = extractTimestampParam(qs, "tsms");
                    if (nclidts > 0 && tsms >= 0) {
                        st = (nclidts * 1000) + tsms;
                    }
                }
                if (st > 0) {
                    data += ',"E2E_PLT":"' + (t.loadEventEnd - st) + '"';
                    // 
                    // Attempt to remove the timestamp parameters from the URL for the following reasons:
                    // (1) User refreshes the page 
                    // (2) Navigates forward and then uses the back button
                    // (3) User adds the page as a bookmark
                    // 
                    // In these cases the timestamps from the first impression are used in the E2E PLT calculation as well as the
                    // browser launch time calculation which yields unusable times. There is currently no way to properly sanitize
                    // all instances of these values. It also decreases perf coverage for those affected impressions.
                    if (window.history && history.replaceState) {
                        var historyUrl = location.href.replace(/(&(sbts|nclidts|tsms)=\d+)/g, "");
                        if (historyUrl !== location.href) {
                            history.replaceState(null, null, historyUrl);
                        }
                    }
                }
            }
            _G.C1 = _G.C1 ? _G.C1 + ',' + data : data;
        }
        if (fn) {
            fn(currentTime, state);
        }
    };
})(_w.si_PP);
;// BoxModel Rules
// Format: [x, y, includeChildren]
// E.g. "#b_tween": [100, 140, 1] ==>
//          Look for #b_tween and validate that it's (x,y) matches (100,140)
//          And, since third parameter is 1, also grab coordinates for all children elements
// Value of -1 for x or y coordinate indicates wildcard, i.e., no validation on that particular coordinate
var BM = BM || {};
BM.rules = {
    ".b_scopebar": [-1, -1, 0],
    ".b_scopebar ul": [-1, -1, 1],
    "#b_results": [-1, -1, 1],
    ".b_hList": [-1, -1, 1],
    ".b_flex": [-1, -1, 1],
    ".b_flex span": [-1, -1, 0],
    "img,div[data-src]": [-1, -1, 0],
    "#root": [-1, -1, 1],
    ".suggestion": [-1, -1, 0],
    "#topResult": [-1, -1, 0],
    ".groupHeader": [-1, -1, 0]
};
;var BM = BM || {};
(function (BM) {
    var items = {};
    var unloads = {};
    var computes = {};
    function wireup(moduleID, q) {
        if (!(moduleID in items))
            items[moduleID] = [];
        if (q.compute && !(moduleID in computes))
            computes[moduleID] = q.compute;
        if (q.unload && !(moduleID in unloads))
            unloads[moduleID] = q.unload;
        if (q.load)
            q.load();
    }
    function enqueue(moduleID, item) {
        items[moduleID].push({ t: getElapsedTime(), i: item });
    }
    function dequeue(moduleID) {
        if (moduleID in unloads)
            unloads[moduleID]();
        if (moduleID in items)
            return items[moduleID];
    }
    function trigger() {
        for (var moduleID in computes) {
            computes[moduleID]();
        }
    }
    function getElapsedTime() {
        return window.performance && performance.now ? Math.round(performance.now()) : (new Date()) - window["si_ST"];
    }
    BM.wireup = wireup;
    BM.enqueue = enqueue;
    BM.dequeue = dequeue;
    BM.trigger = trigger;
})(BM);
;///<reference path="..\queue.ts"/>
(function (BM) {
    var moduleID = "V";
    // Viewport computation
    function compute() {
        var de = document.documentElement;
        var body = document.body;
        var screenWidth = "innerWidth" in window ? window.innerWidth : de.clientWidth;
        var screenHeight = "innerHeight" in window ? window.innerHeight : de.clientHeight;
        var screenLeft = window["pageXOffset"] || de.scrollLeft;
        var screenTop = window["pageYOffset"] || de.scrollTop;
        var state = document["visibilityState"] || "default";
        BM.enqueue(moduleID, { x: screenLeft, y: screenTop, w: screenWidth, h: screenHeight, dw: body.clientWidth, dh: body.clientHeight, v: state });
    }
    // Initialize queue
    BM.wireup(moduleID, { load: null, compute: compute, unload: null });
})(BM);
;///<reference path="..\queue.ts"/>
(function (BM) {
    var moduleID = "L";
    // Viewport computation
    function compute() {
        // Bail out if querySelector API doesn't exist
        // Eventually, post page load, we will log the error via core framework
        if (!document.querySelector || !document.querySelectorAll) {
            return;
        }
        var nodes = [];
        var rules = BM.rules;
        for (var selector in rules) {
            var rule = rules[selector];
            selector += !!rule[2] ? " >*" : "";
            var elements = document.querySelectorAll(selector);
            for (var e = 0; e < elements.length; e++) {
                var el = elements[e];
                var x = 0, y = 0, w = el.offsetWidth, h = el.offsetHeight;
                do {
                    x += el.offsetLeft;
                    y += el.offsetTop;
                } while (el = el.offsetParent);
                nodes.push({ _e: elements[e], x: x, y: y, w: w, h: h });
            }
        }
        BM.enqueue(moduleID, nodes);
    }
    // Initialize queue
    BM.wireup(moduleID, { load: null, compute: compute, unload: null });
})(BM);
;///<reference path="..\queue.ts"/>
(function (BM) {
    var moduleID = "EVT";
    // Storing events for later reference
    var events = ["click", "mousedown", "mouseup", "touchstart", "touchend", "mousemove", "touchmove", "scroll", "keydown", "resize"];
    function load() {
        eventManager(sj_be, enqueue);
    }
    function enqueue(evt) {
        // Do not attempt to queue if evt is not natively supported by the browser
        // In older versions of IE, it's possible to lookup _w.event synchronously 
        // but it doesn't work when you try to queue the reference and use it later
        // As per stackoverflow: http://stackoverflow.com/questions/3531751/member-not-found-ie-error-ie-6-7-8-9
        // As a possible future work item, it's possible to get around this by making a copy in another variable for IE8 & IE9
        if (evt) {
            BM.enqueue(moduleID, evt);
        }
        return true;
    }
    function unload() {
        eventManager(sj_ue, enqueue);
    }
    function eventManager(api, handler) {
        for (var i = 0; i < events.length; i++) {
            var evt = events[i];
            api(evt === "resize" ? window : document, window.navigator.pointerEnabled ? evt.replace("mouse", "pointer") : evt, handler, false);
        }
    }
    // Initialize queue with a callback to teardown event bindings later
    BM.wireup(moduleID, { load: load, compute: null, unload: unload });
})(BM);
;_TC={SP:"search,images,images\/search,videos\/search,local,local\/fetchlocalpivot,local\/fetchlocalelv,news,news\/search,devicecontent,people411,meetingprep,tasklineth\/search,stores,profile\/interests\/v2,account\/permissions,cabs\/search,cabs\/searchasync,cabs\/book,cabs\/driver,cabs\/driverupdate,events\/search,showtimesth,showmoremoviesth,themebasedlocalrecommendation\/search,transitline,transitstop,morescholarinfo\/search,financemywatchlist\/search,trainschedule,billpay,nearbyshowmore\/search,skywalk\/seemore,UserDataDictionary\/search,cortanalocal\/placesearch,\/interesttracking,\/interesttracking\/packagetracking,\/entityexplore", BP:"videos\/search?view=detail", NW:false};;
//]]></script></head><body onload="if(_w.lb)lb();" style="display: block;"><header id="b_header" class="peek"><span class="b_symb b_cortanaMDL2  cipg vatb square_mi"></span><nav class="b_scopebar" role="navigation" data-bm="0"><ul><li class="b_active" data-bm="1"><a href="/search?q=%e8%ae%b0%e4%bd%8f%e6%88%91%e7%9a%84%e8%bd%a6%e5%81%9c%e5%9c%a8%e6%a5%bc%e4%b8%8b%e3%80%82&amp;FORM=HDRSC1" h="ID=SERP,5019.1">网页</a></li><li data-bm="2"><a href="/images/search?q=%e8%ae%b0%e4%bd%8f%e6%88%91%e7%9a%84%e8%bd%a6%e5%81%9c%e5%9c%a8%e6%a5%bc%e4%b8%8b%e3%80%82&amp;FORM=HDRSC2" h="ID=SERP,5020.1">图片</a></li><li data-bm="3"><a href="/videos/search?q=%e8%ae%b0%e4%bd%8f%e6%88%91%e7%9a%84%e8%bd%a6%e5%81%9c%e5%9c%a8%e6%a5%bc%e4%b8%8b%e3%80%82&amp;FORM=HDRSC3" h="ID=SERP,5021.1">视频</a></li><li data-bm="4"><a href="/dict/search?intlF=0&amp;q=%e8%ae%b0%e4%bd%8f%e6%88%91%e7%9a%84%e8%bd%a6%e5%81%9c%e5%9c%a8%e6%a5%bc%e4%b8%8b%e3%80%82&amp;FORM=HDRSC4" h="ID=SERP,5022.1">词典</a></li></ul></nav></header><script type="text/javascript">//<![CDATA[
/***********************************************************
 * winjs-promise.js start
 **********************************************************/
var globalHolder = { WinJS: { Namespace: {}}};

/***********************************************************
 * base.js
 **********************************************************/
(function baseInit(global, undefined) {
    "use strict";

    function initializeProperties(target, members, prefix) {
        var keys = Object.keys(members);
        var properties;
        var i, len;
        for (i = 0, len = keys.length; i < len; i++) {
            var key = keys[i];
            var enumerable = key.charCodeAt(0) !== /*_*/95;
            var member = members[key];
            if (member && typeof member === 'object') {
                if (member.value !== undefined || typeof member.get === 'function' || typeof member.set === 'function') {
                    if (member.enumerable === undefined) {
                        member.enumerable = enumerable;
                    }
                    if (prefix && member.setName && typeof member.setName === 'function') {
                        member.setName(prefix + "." + key)
                    }
                    properties = properties || {};
                    properties[key] = member;
                    continue;
                }
            }
            if (!enumerable) {
                properties = properties || {};
                properties[key] = { value: member, enumerable: enumerable, configurable: true, writable: true }
                continue;
            }
            target[key] = member;
        }
        if (properties) {
            Object.defineProperties(target, properties);
        }
    }

    (function (rootNamespace) {

        // Create the rootNamespace in the global namespace
        if (!global[rootNamespace]) {
            global[rootNamespace] = Object.create(Object.prototype);
        }

        // Cache the rootNamespace we just created in a local variable
        var _rootNamespace = global[rootNamespace];
        if (!_rootNamespace.Namespace) {
            _rootNamespace.Namespace = Object.create(Object.prototype);
        }

        function defineWithParent(parentNamespace, name, members) {
            /// <signature helpKeyword="WinJS.Namespace.defineWithParent">
            /// <summary locid="WinJS.Namespace.defineWithParent">
            /// Defines a new namespace with the specified name under the specified parent namespace.
            /// </summary>
            /// <param name="parentNamespace" type="Object" locid="WinJS.Namespace.defineWithParent_p:parentNamespace">
            /// The parent namespace.
            /// </param>
            /// <param name="name" type="String" locid="WinJS.Namespace.defineWithParent_p:name">
            /// The name of the new namespace.
            /// </param>
            /// <param name="members" type="Object" locid="WinJS.Namespace.defineWithParent_p:members">
            /// The members of the new namespace.
            /// </param>
            /// <returns type="Object" locid="WinJS.Namespace.defineWithParent_returnValue">
            /// The newly-defined namespace.
            /// </returns>
            /// </signature>
            var currentNamespace = parentNamespace || {};

            if (name) {
                var namespaceFragments = name.split(".");
                for (var i = 0, len = namespaceFragments.length; i < len; i++) {
                    var namespaceName = namespaceFragments[i];
                    if (!currentNamespace[namespaceName]) {
                        Object.defineProperty(currentNamespace, namespaceName,
                            { value: {}, writable: false, enumerable: true, configurable: true }
                        );
                    }
                    currentNamespace = currentNamespace[namespaceName];
                }
            }

            if (members) {
                initializeProperties(currentNamespace, members, name || "<ANONYMOUS>");
            }

            return currentNamespace;
        }

        function define(name, members) {
            /// <signature helpKeyword="WinJS.Namespace.define">
            /// <summary locid="WinJS.Namespace.define">
            /// Defines a new namespace with the specified name.
            /// </summary>
            /// <param name="name" type="String" locid="WinJS.Namespace.define_p:name">
            /// The name of the namespace. This could be a dot-separated name for nested namespaces.
            /// </param>
            /// <param name="members" type="Object" locid="WinJS.Namespace.define_p:members">
            /// The members of the new namespace.
            /// </param>
            /// <returns type="Object" locid="WinJS.Namespace.define_returnValue">
            /// The newly-defined namespace.
            /// </returns>
            /// </signature>
            return defineWithParent(global, name, members);
        }

        var LazyStates = {
            uninitialized: 1,
            working: 2,
            initialized: 3,
        };

        function lazy(f) {
            if (typeof f === "string") {
                var target = f;
                f = function () {
                    return WinJS.Utilities.getMember(target);
                };
            }
            var name;
            var state = LazyStates.uninitialized;
            var result;
            return {
                setName: function (value) {
                    name = value;
                },
                get: function () {
                    switch (state) {
                        case LazyStates.initialized:
                            return result;

                        case LazyStates.uninitialized:
                            state = LazyStates.working;
                            try {
                                msWriteProfilerMark("WinJS.Namespace._lazy:" + name + ",StartTM");
                                result = f();
                            } finally {
                                msWriteProfilerMark("WinJS.Namespace._lazy:" + name + ",StopTM");
                                state = LazyStates.uninitialized;
                            }
                            f = null;
                            state = LazyStates.initialized;
                            return result;

                        case LazyStates.working:
                            throw "Illegal: reentrancy on initialization";

                        default:
                            throw "Illegal";
                    }
                },
                set: function (value) {
                    switch (state) {
                        case LazyStates.working:
                            throw "Illegal: reentrancy on initialization";
                        
                        default:
                            state = LazyStates.initialized;
                            result = value;
                            break;
                    }
                },
                enumerable: true,
                configurable: true,
            }
        }

        // Establish members of the "WinJS.Namespace" namespace
        Object.defineProperties(_rootNamespace.Namespace, {

            defineWithParent: { value: defineWithParent, writable: true, enumerable: true, configurable: true },

            define: { value: define, writable: true, enumerable: true, configurable: true },

            _lazy: { value: lazy, writable: true, enumerable: true, configurable: true },

        });

    })("WinJS");

    (function (WinJS) {

        function define(constructor, instanceMembers, staticMembers) {
            /// <signature helpKeyword="WinJS.Class.define">
            /// <summary locid="WinJS.Class.define">
            /// Defines a class using the given constructor and the specified instance members.
            /// </summary>
            /// <param name="constructor" type="Function" locid="WinJS.Class.define_p:constructor">
            /// A constructor function that is used to instantiate this class.
            /// </param>
            /// <param name="instanceMembers" type="Object" locid="WinJS.Class.define_p:instanceMembers">
            /// The set of instance fields, properties, and methods made available on the class.
            /// </param>
            /// <param name="staticMembers" type="Object" locid="WinJS.Class.define_p:staticMembers">
            /// The set of static fields, properties, and methods made available on the class.
            /// </param>
            /// <returns type="Function" locid="WinJS.Class.define_returnValue">
            /// The newly-defined class.
            /// </returns>
            /// </signature>
            constructor = constructor || function () { };
            WinJS.Utilities.markSupportedForProcessing(constructor);
            if (instanceMembers) {
                initializeProperties(constructor.prototype, instanceMembers);
            }
            if (staticMembers) {
                initializeProperties(constructor, staticMembers);
            }
            return constructor;
        }

        function derive(baseClass, constructor, instanceMembers, staticMembers) {
            /// <signature helpKeyword="WinJS.Class.derive">
            /// <summary locid="WinJS.Class.derive">
            /// Creates a sub-class based on the supplied baseClass parameter, using prototypal inheritance.
            /// </summary>
            /// <param name="baseClass" type="Function" locid="WinJS.Class.derive_p:baseClass">
            /// The class to inherit from.
            /// </param>
            /// <param name="constructor" type="Function" locid="WinJS.Class.derive_p:constructor">
            /// A constructor function that is used to instantiate this class.
            /// </param>
            /// <param name="instanceMembers" type="Object" locid="WinJS.Class.derive_p:instanceMembers">
            /// The set of instance fields, properties, and methods to be made available on the class.
            /// </param>
            /// <param name="staticMembers" type="Object" locid="WinJS.Class.derive_p:staticMembers">
            /// The set of static fields, properties, and methods to be made available on the class.
            /// </param>
            /// <returns type="Function" locid="WinJS.Class.derive_returnValue">
            /// The newly-defined class.
            /// </returns>
            /// </signature>
            if (baseClass) {
                constructor = constructor || function () { };
                var basePrototype = baseClass.prototype;
                constructor.prototype = Object.create(basePrototype);
                WinJS.Utilities.markSupportedForProcessing(constructor);
                Object.defineProperty(constructor.prototype, "constructor", { value: constructor, writable: true, configurable: true, enumerable: true });
                if (instanceMembers) {
                    initializeProperties(constructor.prototype, instanceMembers);
                }
                if (staticMembers) {
                    initializeProperties(constructor, staticMembers);
                }
                return constructor;
            } else {
                return define(constructor, instanceMembers, staticMembers);
            }
        }

        function mix(constructor) {
            /// <signature helpKeyword="WinJS.Class.mix">
            /// <summary locid="WinJS.Class.mix">
            /// Defines a class using the given constructor and the union of the set of instance members
            /// specified by all the mixin objects. The mixin parameter list is of variable length.
            /// </summary>
            /// <param name="constructor" locid="WinJS.Class.mix_p:constructor">
            /// A constructor function that is used to instantiate this class.
            /// </param>
            /// <returns type="Function" locid="WinJS.Class.mix_returnValue">
            /// The newly-defined class.
            /// </returns>
            /// </signature>
            constructor = constructor || function () { };
            var i, len;
            for (i = 1, len = arguments.length; i < len; i++) {
                initializeProperties(constructor.prototype, arguments[i]);
            }
            return constructor;
        }

        // Establish members of "WinJS.Class" namespace
        WinJS.Namespace.define("WinJS.Class", {
            define: define,
            derive: derive,
            mix: mix
        });

    })(WinJS);

})(this);

 /***********************************************************
 * baseUtils.js
 **********************************************************/
 (function baseUtilsInit(global, WinJS) {
    "use strict";

    var hasWinRT = !!global.Windows;

    var strings = {
        get notSupportedForProcessing() { return WinJS.Resources._getWinJSString("base/notSupportedForProcessing").value; }
    };

    function nop(v) {
        return v;
    }

    function getMemberFiltered(name, root, filter) {
        return name.split(".").reduce(function (currentNamespace, name) {
            if (currentNamespace) {
                return filter(currentNamespace[name]);
            }
            return null;
        }, root);
    }

    // Establish members of "WinJS.Utilities" namespace
    WinJS.Namespace.define("WinJS.Utilities", {
        // Used for mocking in tests
        _setHasWinRT: {
            value: function (value) {
                hasWinRT = value;
            },
            configurable: false,
            writable: false,
            enumerable: false
        },

        /// <field type="Boolean" locid="WinJS.Utilities.hasWinRT" helpKeyword="WinJS.Utilities.hasWinRT">Determine if WinRT is accessible in this script context.</field>
        hasWinRT: {
            get: function () { return hasWinRT; },
            configurable: false,
            enumerable: true
        },

        _getMemberFiltered: getMemberFiltered,

        getMember: function (name, root) {
            /// <signature helpKeyword="WinJS.Utilities.getMember">
            /// <summary locid="WinJS.Utilities.getMember">
            /// Gets the leaf-level type or namespace specified by the name parameter.
            /// </summary>
            /// <param name="name" locid="WinJS.Utilities.getMember_p:name">
            /// The name of the member.
            /// </param>
            /// <param name="root" locid="WinJS.Utilities.getMember_p:root">
            /// The root to start in. Defaults to the global object.
            /// </param>
            /// <returns type="Object" locid="WinJS.Utilities.getMember_returnValue">
            /// The leaf-level type or namespace in the specified parent namespace.
            /// </returns>
            /// </signature>
            if (!name) {
                return null;
            }
            return getMemberFiltered(name, root || global, nop);
        },

        ready: function (callback, async) {
            /// <signature helpKeyword="WinJS.Utilities.ready">
            /// <summary locid="WinJS.Utilities.ready">
            /// Ensures that the specified function executes only after the DOMContentLoaded event has fired
            /// for the current page.
            /// </summary>
            /// <returns type="WinJS.Promise" locid="WinJS.Utilities.ready_returnValue">A promise that completes after DOMContentLoaded has occurred.</returns>
            /// <param name="callback" optional="true" locid="WinJS.Utilities.ready_p:callback">
            /// A function that executes after DOMContentLoaded has occurred.
            /// </param>
            /// <param name="async" optional="true" locid="WinJS.Utilities.ready_p:async">
            /// If true, the callback is executed asynchronously.
            /// </param>
            /// </signature>
            return new WinJS.Promise(function (c, e) {
                function complete() {
                    if (callback) {
                        try {
                            callback();
                            c();
                        }
                        catch (err) {
                            e(err);
                        }
                    }
                    else {
                        c();
                    }
                }

                var readyState = WinJS.Utilities.testReadyState;
                if (!readyState) {
                    if (global.document) {
                        readyState = document.readyState;
                    }
                    else {
                        readyState = "complete";
                    }
                }
                if (readyState === "complete" || (global.document && document.body !== null)) {
                    if (async) {
                        WinJS.Utilities.Scheduler.schedule(function () {
                            complete();
                        }, WinJS.Utilities.Scheduler.Priority.normal, null, "WinJS.Utilities.ready");
                    }
                    else {
                        complete();
                    }
                }
                else {
                    global.addEventListener("DOMContentLoaded", complete, false);
                }
            });
        },

        /// <field type="Boolean" locid="WinJS.Utilities.strictProcessing" helpKeyword="WinJS.Utilities.strictProcessing">Determines if strict declarative processing is enabled in this script context.</field>
        strictProcessing: {
            get: function () { return true; },
            configurable: false,
            enumerable: true,
        },

        markSupportedForProcessing: {
            value: function (func) {
                /// <signature helpKeyword="WinJS.Utilities.markSupportedForProcessing">
                /// <summary locid="WinJS.Utilities.markSupportedForProcessing">
                /// Marks a function as being compatible with declarative processing, such as WinJS.UI.processAll
                /// or WinJS.Binding.processAll.
                /// </summary>
                /// <param name="func" type="Function" locid="WinJS.Utilities.markSupportedForProcessing_p:func">
                /// The function to be marked as compatible with declarative processing.
                /// </param>
                /// <returns type="Function" locid="WinJS.Utilities.markSupportedForProcessing_returnValue">
                /// The input function.
                /// </returns>
                /// </signature>
                func.supportedForProcessing = true;
                return func;
            },
            configurable: false,
            writable: false,
            enumerable: true
        },

        requireSupportedForProcessing: {
            value: function (value) {
                /// <signature helpKeyword="WinJS.Utilities.requireSupportedForProcessing">
                /// <summary locid="WinJS.Utilities.requireSupportedForProcessing">
                /// Asserts that the value is compatible with declarative processing, such as WinJS.UI.processAll
                /// or WinJS.Binding.processAll. If it is not compatible an exception will be thrown.
                /// </summary>
                /// <param name="value" type="Object" locid="WinJS.Utilities.requireSupportedForProcessing_p:value">
                /// The value to be tested for compatibility with declarative processing. If the
                /// value is a function it must be marked with a property 'supportedForProcessing'
                /// with a value of true.
                /// </param>
                /// <returns type="Object" locid="WinJS.Utilities.requireSupportedForProcessing_returnValue">
                /// The input value.
                /// </returns>
                /// </signature>
                var supportedForProcessing = true;

                supportedForProcessing = supportedForProcessing && !(value === global);
                supportedForProcessing = supportedForProcessing && !(value === global.location);
                supportedForProcessing = supportedForProcessing && !(value instanceof HTMLIFrameElement);
                supportedForProcessing = supportedForProcessing && !(typeof value === "function" && !value.supportedForProcessing);

                switch (global.frames.length) {
                    case 0:
                        break;

                    case 1:
                        supportedForProcessing = supportedForProcessing && !(value === global.frames[0]);
                        break;

                    default:
                        for (var i = 0, len = global.frames.length; supportedForProcessing && i < len; i++) {
                            supportedForProcessing = supportedForProcessing && !(value === global.frames[i]);
                        }
                        break;
                }

                if (supportedForProcessing) {
                    return value;
                }

                throw new WinJS.ErrorFromName("WinJS.Utilities.requireSupportedForProcessing", WinJS.Resources._formatString(strings.notSupportedForProcessing, value));
            },
            configurable: false,
            writable: false,
            enumerable: true
        },

        _shallowCopy: function _shallowCopy(a) {
            // Shallow copy a single object.
            return this._mergeAll([a]);
        },

        _merge: function _merge(a, b) {
            // Merge 2 objects together into a new object
            return this._mergeAll([a, b]);
        },

        _mergeAll: function _mergeAll(list) {
            // Merge a list of objects together
            var o = {};
            list.forEach(function (part) {
                Object.keys(part).forEach(function (k) {
                    o[k] = part[k];
                });
            });
            return o;
        },
        
        _getProfilerMarkIdentifier: function (element) {
            var profilerMarkIdentifier = "";
            if (element.id) {
                profilerMarkIdentifier += " id='" + element.id + "'";
            }
            if (element.className) {
                profilerMarkIdentifier += " class='" + element.className + "'";
            }
            return profilerMarkIdentifier;
        }
    });

    WinJS.Namespace.define("WinJS", {
        validation: false,

        strictProcessing: {
            value: function () {
                /// <signature helpKeyword="WinJS.strictProcessing">
                /// <summary locid="WinJS.strictProcessing">
                /// Strict processing is always enforced, this method has no effect.
                /// </summary>
                /// </signature>
            },
            configurable: false,
            writable: false,
            enumerable: false
        },
    });
})(this, WinJS);

 /***********************************************************
 * errors.js
 **********************************************************/
(function errorsInit(global, WinJS) {
    "use strict";


    WinJS.Namespace.define("WinJS", {
        // ErrorFromName establishes a simple pattern for returning error codes.
        //
        ErrorFromName: WinJS.Class.derive(Error, function (name, message) {
            /// <signature helpKeyword="WinJS.ErrorFromName">
            /// <summary locid="WinJS.ErrorFromName">
            /// Creates an Error object with the specified name and message properties.
            /// </summary>
            /// <param name="name" type="String" locid="WinJS.ErrorFromName_p:name">The name of this error. The name is meant to be consumed programmatically and should not be localized.</param>
            /// <param name="message" type="String" optional="true" locid="WinJS.ErrorFromName_p:message">The message for this error. The message is meant to be consumed by humans and should be localized.</param>
            /// <returns type="Error" locid="WinJS.ErrorFromName_returnValue">Error instance with .name and .message properties populated</returns>
            /// </signature>
            this.name = name;
            this.message = message || name;
        }, {
            /* empty */
        }, {
            supportedForProcessing: false,
        })
    });

})(this, WinJS);



 /***********************************************************
 * events.js
 **********************************************************/
 (function eventsInit(WinJS, undefined) {
    "use strict";


    function createEventProperty(name) {
        var eventPropStateName = "_on" + name + "state";

        return {
            get: function () {
                var state = this[eventPropStateName];
                return state && state.userHandler;
            },
            set: function (handler) {
                var state = this[eventPropStateName];
                if (handler) {
                    if (!state) {
                        state = { wrapper: function (evt) { return state.userHandler(evt); }, userHandler: handler };
                        Object.defineProperty(this, eventPropStateName, { value: state, enumerable: false, writable:true, configurable: true });
                        this.addEventListener(name, state.wrapper, false);
                    }
                    state.userHandler = handler;
                } else if (state) {
                    this.removeEventListener(name, state.wrapper, false);
                    this[eventPropStateName] = null;
                }
            },
            enumerable: true
        }
    }

    function createEventProperties(events) {
        /// <signature helpKeyword="WinJS.Utilities.createEventProperties">
        /// <summary locid="WinJS.Utilities.createEventProperties">
        /// Creates an object that has one property for each name passed to the function.
        /// </summary>
        /// <param name="events" locid="WinJS.Utilities.createEventProperties_p:events">
        /// A variable list of property names.
        /// </param>
        /// <returns type="Object" locid="WinJS.Utilities.createEventProperties_returnValue">
        /// The object with the specified properties. The names of the properties are prefixed with 'on'.
        /// </returns>
        /// </signature>
        var props = {};
        for (var i = 0, len = arguments.length; i < len; i++) {
            var name = arguments[i];
            props["on" + name] = createEventProperty(name);
        }
        return props;
    }

    var EventMixinEvent = WinJS.Class.define(
        function EventMixinEvent_ctor(type, detail, target) {
            this.detail = detail;
            this.target = target;
            this.timeStamp = Date.now();
            this.type = type;
        },
        {
            bubbles: { value: false, writable: false },
            cancelable: { value: false, writable: false },
            currentTarget: {
                get: function () { return this.target; }
            },
            defaultPrevented: {
                get: function () { return this._preventDefaultCalled; }
            },
            trusted: { value: false, writable: false },
            eventPhase: { value: 0, writable: false },
            target: null,
            timeStamp: null,
            type: null,

            preventDefault: function () {
                this._preventDefaultCalled = true;
            },
            stopImmediatePropagation: function () {
                this._stopImmediatePropagationCalled = true;
            },
            stopPropagation: function () {
            }
        }, {
            supportedForProcessing: false,
        }
    );

    var eventMixin = {
        _listeners: null,

        addEventListener: function (type, listener, useCapture) {
            /// <signature helpKeyword="WinJS.Utilities.eventMixin.addEventListener">
            /// <summary locid="WinJS.Utilities.eventMixin.addEventListener">
            /// Adds an event listener to the control.
            /// </summary>
            /// <param name="type" locid="WinJS.Utilities.eventMixin.addEventListener_p:type">
            /// The type (name) of the event.
            /// </param>
            /// <param name="listener" locid="WinJS.Utilities.eventMixin.addEventListener_p:listener">
            /// The listener to invoke when the event is raised.
            /// </param>
            /// <param name="useCapture" locid="WinJS.Utilities.eventMixin.addEventListener_p:useCapture">
            /// if true initiates capture, otherwise false.
            /// </param>
            /// </signature>
            useCapture = useCapture || false;
            this._listeners = this._listeners || {};
            var eventListeners = (this._listeners[type] = this._listeners[type] || []);
            for (var i = 0, len = eventListeners.length; i < len; i++) {
                var l = eventListeners[i];
                if (l.useCapture === useCapture && l.listener === listener) {
                    return;
                }
            }
            eventListeners.push({ listener: listener, useCapture: useCapture });
        },
        dispatchEvent: function (type, details) {
            /// <signature helpKeyword="WinJS.Utilities.eventMixin.dispatchEvent">
            /// <summary locid="WinJS.Utilities.eventMixin.dispatchEvent">
            /// Raises an event of the specified type and with the specified additional properties.
            /// </summary>
            /// <param name="type" locid="WinJS.Utilities.eventMixin.dispatchEvent_p:type">
            /// The type (name) of the event.
            /// </param>
            /// <param name="details" locid="WinJS.Utilities.eventMixin.dispatchEvent_p:details">
            /// The set of additional properties to be attached to the event object when the event is raised.
            /// </param>
            /// <returns type="Boolean" locid="WinJS.Utilities.eventMixin.dispatchEvent_returnValue">
            /// true if preventDefault was called on the event.
            /// </returns>
            /// </signature>
            var listeners = this._listeners && this._listeners[type];
            if (listeners) {
                var eventValue = new EventMixinEvent(type, details, this);
                // Need to copy the array to protect against people unregistering while we are dispatching
                listeners = listeners.slice(0, listeners.length);
                for (var i = 0, len = listeners.length; i < len && !eventValue._stopImmediatePropagationCalled; i++) {
                    listeners[i].listener(eventValue);
                }
                return eventValue.defaultPrevented || false;
            }
            return false;
        },
        removeEventListener: function (type, listener, useCapture) {
            /// <signature helpKeyword="WinJS.Utilities.eventMixin.removeEventListener">
            /// <summary locid="WinJS.Utilities.eventMixin.removeEventListener">
            /// Removes an event listener from the control.
            /// </summary>
            /// <param name="type" locid="WinJS.Utilities.eventMixin.removeEventListener_p:type">
            /// The type (name) of the event.
            /// </param>
            /// <param name="listener" locid="WinJS.Utilities.eventMixin.removeEventListener_p:listener">
            /// The listener to remove.
            /// </param>
            /// <param name="useCapture" locid="WinJS.Utilities.eventMixin.removeEventListener_p:useCapture">
            /// Specifies whether to initiate capture.
            /// </param>
            /// </signature>
            useCapture = useCapture || false;
            var listeners = this._listeners && this._listeners[type];
            if (listeners) {
                for (var i = 0, len = listeners.length; i < len; i++) {
                    var l = listeners[i];
                    if (l.listener === listener && l.useCapture === useCapture) {
                        listeners.splice(i, 1);
                        if (listeners.length === 0) {
                            delete this._listeners[type];
                        }
                        // Only want to remove one element for each call to removeEventListener
                        break;
                    }
                }
            }
        }
    };

    WinJS.Namespace.define("WinJS.Utilities", {
        _createEventProperty: createEventProperty,
        createEventProperties: createEventProperties,
        eventMixin: eventMixin
    });

})(WinJS);
 
  /***********************************************************
 * promise.js
 **********************************************************/
 (function promiseInit(global, undefined) {
    "use strict";

    var ListenerType = WinJS.Class.mix(WinJS.Class.define(null, { /*empty*/ }, { supportedForProcessing: false }), WinJS.Utilities.eventMixin);
    var promiseEventListeners = new ListenerType();
    // make sure there is a listeners collection so that we can do a more trivial check below
    promiseEventListeners._listeners = {};
    var errorET = "error";
    var canceledName = "Canceled";
    var tagWithStack = false;
    var tag = {
        promise: 0x01,
        thenPromise: 0x02,
        errorPromise: 0x04,
        exceptionPromise: 0x08,
        completePromise: 0x10,
    };
    tag.all = tag.promise | tag.thenPromise | tag.errorPromise | tag.exceptionPromise | tag.completePromise;

    //
    // Global error counter, for each error which enters the system we increment this once and then
    // the error number travels with the error as it traverses the tree of potential handlers.
    //
    // When someone has registered to be told about errors (WinJS.Promise.callonerror) promises
    // which are in error will get tagged with a ._errorId field. This tagged field is the
    // contract by which nested promises with errors will be identified as chaining for the
    // purposes of the callonerror semantics. If a nested promise in error is encountered without
    // a ._errorId it will be assumed to be foreign and treated as an interop boundary and
    // a new error id will be minted.
    //
    var error_number = 1;

    //
    // The state machine has a interesting hiccup in it with regards to notification, in order
    // to flatten out notification and avoid recursion for synchronous completion we have an
    // explicit set of *_notify states which are responsible for notifying their entire tree
    // of children. They can do this because they know that immediate children are always
    // ThenPromise instances and we can therefore reach into their state to access the
    // _listeners collection.
    //
    // So, what happens is that a Promise will be fulfilled through the _completed or _error
    // messages at which point it will enter a *_notify state and be responsible for to move
    // its children into an (as appropriate) success or error state and also notify that child's
    // listeners of the state transition, until leaf notes are reached.
    //

    var state_created,              // -> working
        state_working,              // -> error | error_notify | success | success_notify | canceled | waiting
        state_waiting,              // -> error | error_notify | success | success_notify | waiting_canceled
        state_waiting_canceled,     // -> error | error_notify | success | success_notify | canceling
        state_canceled,             // -> error | error_notify | success | success_notify | canceling
        state_canceling,            // -> error_notify
        state_success_notify,       // -> success
        state_success,              // -> .
        state_error_notify,         // -> error
        state_error;                // -> .

    // Noop function, used in the various states to indicate that they don't support a given
    // message. Named with the somewhat cute name '_' because it reads really well in the states.

    function _() { }

    // Initial state
    //
    state_created = {
        name: "created",
        enter: function (promise) {
            promise._setState(state_working);
        },
        cancel: _,
        done: _,
        then: _,
        _completed: _,
        _error: _,
        _notify: _,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Ready state, waiting for a message (completed/error/progress), able to be canceled
    //
    state_working = {
        name: "working",
        enter: _,
        cancel: function (promise) {
            promise._setState(state_canceled);
        },
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Waiting state, if a promise is completed with a value which is itself a promise
    // (has a then() method) it signs up to be informed when that child promise is
    // fulfilled at which point it will be fulfilled with that value.
    //
    state_waiting = {
        name: "waiting",
        enter: function (promise) {
            var waitedUpon = promise._value;
            // We can special case our own intermediate promises which are not in a 
            //  terminal state by just pushing this promise as a listener without 
            //  having to create new indirection functions
            if (waitedUpon instanceof ThenPromise &&
                waitedUpon._state !== state_error &&
                waitedUpon._state !== state_success) {
                pushListener(waitedUpon, { promise: promise });
            } else {
                var error = function (value) {
                    if (waitedUpon._errorId) {
                        promise._chainedError(value, waitedUpon);
                    } else {
                        // Because this is an interop boundary we want to indicate that this 
                        //  error has been handled by the promise infrastructure before we
                        //  begin a new handling chain.
                        //
                        callonerror(promise, value, detailsForHandledError, waitedUpon, error);
                        promise._error(value);
                    }
                };
                error.handlesOnError = true;
                waitedUpon.then(
                    promise._completed.bind(promise),
                    error,
                    promise._progress.bind(promise)
                );
            }
        },
        cancel: function (promise) {
            promise._setState(state_waiting_canceled);
        },
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Waiting canceled state, when a promise has been in a waiting state and receives a
    // request to cancel its pending work it will forward that request to the child promise
    // and then waits to be informed of the result. This promise moves itself into the
    // canceling state but understands that the child promise may instead push it to a
    // different state.
    //
    state_waiting_canceled = {
        name: "waiting_canceled",
        enter: function (promise) {
            // Initiate a transition to canceling. Triggering a cancel on the promise
            // that we are waiting upon may result in a different state transition
            // before the state machine pump runs again.
            promise._setState(state_canceling);
            var waitedUpon = promise._value;
            if (waitedUpon.cancel) {
                waitedUpon.cancel();
            }
        },
        cancel: _,
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Canceled state, moves to the canceling state and then tells the promise to do
    // whatever it might need to do on cancelation.
    //
    state_canceled = {
        name: "canceled",
        enter: function (promise) {
            // Initiate a transition to canceling. The _cancelAction may change the state
            // before the state machine pump runs again.
            promise._setState(state_canceling);
            promise._cancelAction();
        },
        cancel: _,
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Canceling state, commits to the promise moving to an error state with an error
    // object whose 'name' and 'message' properties contain the string "Canceled"
    //
    state_canceling = {
        name: "canceling",
        enter: function (promise) {
            var error = new Error(canceledName);
            error.name = error.message;
            promise._value = error;
            promise._setState(state_error_notify);
        },
        cancel: _,
        done: _,
        then: _,
        _completed: _,
        _error: _,
        _notify: _,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Success notify state, moves a promise to the success state and notifies all children
    //
    state_success_notify = {
        name: "complete_notify",
        enter: function (promise) {
            promise.done = CompletePromise.prototype.done;
            promise.then = CompletePromise.prototype.then;
            if (promise._listeners) {
                var queue = [promise];
                var p;
                while (queue.length) {
                    p = queue.shift();
                    p._state._notify(p, queue);
                }
            }
            promise._setState(state_success);
        },
        cancel: _,
        done: null, /*error to get here */
        then: null, /*error to get here */
        _completed: _,
        _error: _,
        _notify: notifySuccess,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Success state, moves a promise to the success state and does NOT notify any children.
    // Some upstream promise is owning the notification pass.
    //
    state_success = {
        name: "success",
        enter: function (promise) {
            promise.done = CompletePromise.prototype.done;
            promise.then = CompletePromise.prototype.then;
            promise._cleanupAction();
        },
        cancel: _,
        done: null, /*error to get here */
        then: null, /*error to get here */
        _completed: _,
        _error: _,
        _notify: notifySuccess,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Error notify state, moves a promise to the error state and notifies all children
    //
    state_error_notify = {
        name: "error_notify",
        enter: function (promise) {
            promise.done = ErrorPromise.prototype.done;
            promise.then = ErrorPromise.prototype.then;
            if (promise._listeners) {
                var queue = [promise];
                var p;
                while (queue.length) {
                    p = queue.shift();
                    p._state._notify(p, queue);
                }
            }
            promise._setState(state_error);
        },
        cancel: _,
        done: null, /*error to get here*/
        then: null, /*error to get here*/
        _completed: _,
        _error: _,
        _notify: notifyError,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Error state, moves a promise to the error state and does NOT notify any children.
    // Some upstream promise is owning the notification pass.
    //
    state_error = {
        name: "error",
        enter: function (promise) {
            promise.done = ErrorPromise.prototype.done;
            promise.then = ErrorPromise.prototype.then;
            promise._cleanupAction();
        },
        cancel: _,
        done: null, /*error to get here*/
        then: null, /*error to get here*/
        _completed: _,
        _error: _,
        _notify: notifyError,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    //
    // The statemachine implementation follows a very particular pattern, the states are specified
    // as static stateless bags of functions which are then indirected through the state machine
    // instance (a Promise). As such all of the functions on each state have the promise instance
    // passed to them explicitly as a parameter and the Promise instance members do a little
    // dance where they indirect through the state and insert themselves in the argument list.
    //
    // We could instead call directly through the promise states however then every caller
    // would have to remember to do things like pumping the state machine to catch state transitions.
    //

    var PromiseStateMachine = WinJS.Class.define(null, {
        _listeners: null,
        _nextState: null,
        _state: null,
        _value: null,

        cancel: function () {
            /// <signature helpKeyword="WinJS.PromiseStateMachine.cancel">
            /// <summary locid="WinJS.PromiseStateMachine.cancel">
            /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't
            /// already been fulfilled and cancellation is supported, the promise enters
            /// the error state with a value of Error("Canceled").
            /// </summary>
            /// </signature>
            this._state.cancel(this);
            this._run();
        },
        done: function Promise_done(onComplete, onError, onProgress) {
            /// <signature helpKeyword="WinJS.PromiseStateMachine.done">
            /// <summary locid="WinJS.PromiseStateMachine.done">
            /// Allows you to specify the work to be done on the fulfillment of the promised value,
            /// the error handling to be performed if the promise fails to fulfill
            /// a value, and the handling of progress notifications along the way.
            ///
            /// After the handlers have finished executing, this function throws any error that would have been returned
            /// from then() as a promise in the error state.
            /// </summary>
            /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.done_p:onComplete">
            /// The function to be called if the promise is fulfilled successfully with a value.
            /// The fulfilled value is passed as the single argument. If the value is null,
            /// the fulfilled value is returned. The value returned
            /// from the function becomes the fulfilled value of the promise returned by
            /// then(). If an exception is thrown while executing the function, the promise returned
            /// by then() moves into the error state.
            /// </param>
            /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onError">
            /// The function to be called if the promise is fulfilled with an error. The error
            /// is passed as the single argument. If it is null, the error is forwarded.
            /// The value returned from the function is the fulfilled value of the promise returned by then().
            /// </param>
            /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onProgress">
            /// the function to be called if the promise reports progress. Data about the progress
            /// is passed as the single argument. Promises are not required to support
            /// progress.
            /// </param>
            /// </signature>
            this._state.done(this, onComplete, onError, onProgress);
        },
        then: function Promise_then(onComplete, onError, onProgress) {
            /// <signature helpKeyword="WinJS.PromiseStateMachine.then">
            /// <summary locid="WinJS.PromiseStateMachine.then">
            /// Allows you to specify the work to be done on the fulfillment of the promised value,
            /// the error handling to be performed if the promise fails to fulfill
            /// a value, and the handling of progress notifications along the way.
            /// </summary>
            /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.then_p:onComplete">
            /// The function to be called if the promise is fulfilled successfully with a value.
            /// The value is passed as the single argument. If the value is null, the value is returned.
            /// The value returned from the function becomes the fulfilled value of the promise returned by
            /// then(). If an exception is thrown while this function is being executed, the promise returned
            /// by then() moves into the error state.
            /// </param>
            /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onError">
            /// The function to be called if the promise is fulfilled with an error. The error
            /// is passed as the single argument. If it is null, the error is forwarded.
            /// The value returned from the function becomes the fulfilled value of the promise returned by then().
            /// </param>
            /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onProgress">
            /// The function to be called if the promise reports progress. Data about the progress
            /// is passed as the single argument. Promises are not required to support
            /// progress.
            /// </param>
            /// <returns type="WinJS.Promise" locid="WinJS.PromiseStateMachine.then_returnValue">
            /// The promise whose value is the result of executing the complete or
            /// error function.
            /// </returns>
            /// </signature>
            return this._state.then(this, onComplete, onError, onProgress);
        },

        _chainedError: function (value, context) {
            var result = this._state._error(this, value, detailsForChainedError, context);
            this._run();
            return result;
        },
        _completed: function (value) {
            var result = this._state._completed(this, value);
            this._run();
            return result;
        },
        _error: function (value) {
            var result = this._state._error(this, value, detailsForError);
            this._run();
            return result;
        },
        _progress: function (value) {
            this._state._progress(this, value);
        },
        _setState: function (state) {
            this._nextState = state;
        },
        _setCompleteValue: function (value) {
            this._state._setCompleteValue(this, value);
            this._run();
        },
        _setChainedErrorValue: function (value, context) {
            var result = this._state._setErrorValue(this, value, detailsForChainedError, context);
            this._run();
            return result;
        },
        _setExceptionValue: function (value) {
            var result = this._state._setErrorValue(this, value, detailsForException);
            this._run();
            return result;
        },
        _run: function () {
            while (this._nextState) {
                this._state = this._nextState;
                this._nextState = null;
                this._state.enter(this);
            }
        }
    }, {
        supportedForProcessing: false
    });

    //
    // Implementations of shared state machine code.
    //

    function completed(promise, value) {
        var targetState;
        if (value && typeof value === "object" && typeof value.then === "function") {
            targetState = state_waiting;
        } else {
            targetState = state_success_notify;
        }
        promise._value = value;
        promise._setState(targetState);
    }
    function createErrorDetails(exception, error, promise, id, parent, handler) {
        return {
            exception: exception,
            error: error,
            promise: promise,
            handler: handler,
            id: id,
            parent: parent
        };
    }
    function detailsForHandledError(promise, errorValue, context, handler) {
        var exception = context._isException;
        var errorId = context._errorId;
        return createErrorDetails(
            exception ? errorValue : null,
            exception ? null : errorValue,
            promise,
            errorId,
            context,
            handler
        );
    }
    function detailsForChainedError(promise, errorValue, context) {
        var exception = context._isException;
        var errorId = context._errorId;
        setErrorInfo(promise, errorId, exception);
        return createErrorDetails(
            exception ? errorValue : null,
            exception ? null : errorValue,
            promise,
            errorId,
            context
        );
    }
    function detailsForError(promise, errorValue) {
        var errorId = ++error_number;
        setErrorInfo(promise, errorId);
        return createErrorDetails(
            null,
            errorValue,
            promise,
            errorId
        );
    }
    function detailsForException(promise, exceptionValue) {
        var errorId = ++error_number;
        setErrorInfo(promise, errorId, true);
        return createErrorDetails(
            exceptionValue,
            null,
            promise,
            errorId
        );
    }
    function done(promise, onComplete, onError, onProgress) {
        var asyncOpID = "WinJS.Promise.done";
        pushListener(promise, { c: onComplete, e: onError, p: onProgress, asyncOpID: asyncOpID });
    }
    function error(promise, value, onerrorDetails, context) {
        promise._value = value;
        callonerror(promise, value, onerrorDetails, context);
        promise._setState(state_error_notify);
    }
    function notifySuccess(promise, queue) {
        var value = promise._value;
        var listeners = promise._listeners;
        if (!listeners) {
            return;
        }
        promise._listeners = null;
        var i, len;
        for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {
            var listener = len === 1 ? listeners : listeners[i];
            var onComplete = listener.c;
            var target = listener.promise;

            if (target) {
                try {
                    target._setCompleteValue(onComplete ? onComplete(value) : value);
                } catch (ex) {
                    target._setExceptionValue(ex);
                } finally {
                }
                if (target._state !== state_waiting && target._listeners) {
                    queue.push(target);
                }
            } else {
                CompletePromise.prototype.done.call(promise, onComplete);
            }
        }
    }
    function notifyError(promise, queue) {
        var value = promise._value;
        var listeners = promise._listeners;
        if (!listeners) {
            return;
        }
        promise._listeners = null;
        var i, len;
        for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {
            var listener = len === 1 ? listeners : listeners[i];
            var onError = listener.e;
            var target = listener.promise;

            if (target) {
                var asyncCallbackStarted = false;
                try {
                    if (onError) {
                        asyncCallbackStarted = true;
                        if (!onError.handlesOnError) {
                            callonerror(target, value, detailsForHandledError, promise, onError);
                        }
                        target._setCompleteValue(onError(value))
                    } else {
                        target._setChainedErrorValue(value, promise);
                    }
                } catch (ex) {
                    target._setExceptionValue(ex);
                } finally {
                }
                if (target._state !== state_waiting && target._listeners) {
                    queue.push(target);
                }
            } else {
                ErrorPromise.prototype.done.call(promise, null, onError);
            }
        }
    }
    function callonerror(promise, value, onerrorDetailsGenerator, context, handler) {
        if (promiseEventListeners._listeners[errorET]) {
            if (value instanceof Error && value.message === canceledName) {
                return;
            }
            promiseEventListeners.dispatchEvent(errorET, onerrorDetailsGenerator(promise, value, context, handler));
        }
    }
    function progress(promise, value) {
        var listeners = promise._listeners;
        if (listeners) {
            var i, len;
            for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {
                var listener = len === 1 ? listeners : listeners[i];
                var onProgress = listener.p;
                if (onProgress) {
                    try { onProgress(value); } catch (ex) { }
                }
                if (!(listener.c || listener.e) && listener.promise) {
                    listener.promise._progress(value);
                }
            }
        }
    }
    function pushListener(promise, listener) {
        var listeners = promise._listeners;
        if (listeners) {
            // We may have either a single listener (which will never be wrapped in an array)
            // or 2+ listeners (which will be wrapped). Since we are now adding one more listener
            // we may have to wrap the single listener before adding the second.
            listeners = Array.isArray(listeners) ? listeners : [listeners];
            listeners.push(listener);
        } else {
            listeners = listener;
        }
        promise._listeners = listeners;
    }
    // The difference beween setCompleteValue()/setErrorValue() and complete()/error() is that setXXXValue() moves
    // a promise directly to the success/error state without starting another notification pass (because one
    // is already ongoing).
    function setErrorInfo(promise, errorId, isException) {
        promise._isException = isException || false;
        promise._errorId = errorId;
    }
    function setErrorValue(promise, value, onerrorDetails, context) {
        promise._value = value;
        callonerror(promise, value, onerrorDetails, context);
        promise._setState(state_error);
    }
    function setCompleteValue(promise, value) {
        var targetState;
        if (value && typeof value === "object" && typeof value.then === "function") {
            targetState = state_waiting;
        } else {
            targetState = state_success;
        }
        promise._value = value;
        promise._setState(targetState);
    }
    function then(promise, onComplete, onError, onProgress) {
        var result = new ThenPromise(promise);
        var asyncOpID = "WinJS.Promise.then";
        pushListener(promise, { promise: result, c: onComplete, e: onError, p: onProgress, asyncOpID: asyncOpID });
        return result;
    }

    //
    // Internal implementation detail promise, ThenPromise is created when a promise needs
    // to be returned from a then() method.
    //
    var ThenPromise = WinJS.Class.derive(PromiseStateMachine,
        function (creator) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.thenPromise))) {
                this._stack = WinJS.Promise._getStack();
            }

            this._creator = creator;
            this._setState(state_created);
            this._run();
        }, {
            _creator: null,

            _cancelAction: function () { if (this._creator) { this._creator.cancel(); } },
            _cleanupAction: function () { this._creator = null; }
        }, {
            supportedForProcessing: false
        }
    );

    //
    // Slim promise implementations for already completed promises, these are created
    // under the hood on synchronous completion paths as well as by WinJS.Promise.wrap
    // and WinJS.Promise.wrapError.
    //

    var ErrorPromise = WinJS.Class.define(
        function ErrorPromise_ctor(value) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.errorPromise))) {
                this._stack = WinJS.Promise._getStack();
            }

            this._value = value;
            callonerror(this, value, detailsForError);
        }, {
            cancel: function () {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.cancel">
                /// <summary locid="WinJS.PromiseStateMachine.cancel">
                /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't
                /// already been fulfilled and cancellation is supported, the promise enters
                /// the error state with a value of Error("Canceled").
                /// </summary>
                /// </signature>
            },
            done: function ErrorPromise_done(unused, onError) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.done">
                /// <summary locid="WinJS.PromiseStateMachine.done">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                ///
                /// After the handlers have finished executing, this function throws any error that would have been returned
                /// from then() as a promise in the error state.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.done_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The fulfilled value is passed as the single argument. If the value is null,
                /// the fulfilled value is returned. The value returned
                /// from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while executing the function, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function is the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onProgress">
                /// the function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// </signature>
                var value = this._value;
                if (onError) {
                    try {
                        if (!onError.handlesOnError) {
                            callonerror(null, value, detailsForHandledError, this, onError);
                        }
                        var result = onError(value);
                        if (result && typeof result === "object" && typeof result.done === "function") {
                            // If a promise is returned we need to wait on it.
                            result.done();
                        }
                        return;
                    } catch (ex) {
                        value = ex;
                    }
                }
                if (value instanceof Error && value.message === canceledName) {
                    // suppress cancel
                    return;
                }
                // force the exception to be thrown asyncronously to avoid any try/catch blocks
                //
                WinJS.Utilities.Scheduler.schedule(function () {
                    throw value;
                }, WinJS.Utilities.Scheduler.Priority.normal, null, "WinJS.Promise._throwException");
            },
            then: function ErrorPromise_then(unused, onError) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.then">
                /// <summary locid="WinJS.PromiseStateMachine.then">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.then_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The value is passed as the single argument. If the value is null, the value is returned.
                /// The value returned from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while this function is being executed, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function becomes the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onProgress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.PromiseStateMachine.then_returnValue">
                /// The promise whose value is the result of executing the complete or
                /// error function.
                /// </returns>
                /// </signature>

                // If the promise is already in a error state and no error handler is provided
                // we optimize by simply returning the promise instead of creating a new one.
                //
                if (!onError) { return this; }
                var result;
                var value = this._value;
                try {
                    if (!onError.handlesOnError) {
                        callonerror(null, value, detailsForHandledError, this, onError);
                    }
                    result = new CompletePromise(onError(value));
                } catch (ex) {
                    // If the value throw from the error handler is the same as the value
                    // provided to the error handler then there is no need for a new promise.
                    //
                    if (ex === value) {
                        result = this;
                    } else {
                        result = new ExceptionPromise(ex);
                    }
                }
                return result;
            }
        }, {
            supportedForProcessing: false
        }
    );

    var ExceptionPromise = WinJS.Class.derive(ErrorPromise,
        function ExceptionPromise_ctor(value) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.exceptionPromise))) {
                this._stack = WinJS.Promise._getStack();
            }

            this._value = value;
            callonerror(this, value, detailsForException);
        }, {
            /* empty */
        }, {
            supportedForProcessing: false
        }
    );

    var CompletePromise = WinJS.Class.define(
        function CompletePromise_ctor(value) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.completePromise))) {
                this._stack = WinJS.Promise._getStack();
            }

            if (value && typeof value === "object" && typeof value.then === "function") {
                var result = new ThenPromise(null);
                result._setCompleteValue(value);
                return result;
            }
            this._value = value;
        }, {
            cancel: function () {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.cancel">
                /// <summary locid="WinJS.PromiseStateMachine.cancel">
                /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't
                /// already been fulfilled and cancellation is supported, the promise enters
                /// the error state with a value of Error("Canceled").
                /// </summary>
                /// </signature>
            },
            done: function CompletePromise_done(onComplete) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.done">
                /// <summary locid="WinJS.PromiseStateMachine.done">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                ///
                /// After the handlers have finished executing, this function throws any error that would have been returned
                /// from then() as a promise in the error state.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.done_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The fulfilled value is passed as the single argument. If the value is null,
                /// the fulfilled value is returned. The value returned
                /// from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while executing the function, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function is the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onProgress">
                /// the function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// </signature>
                if (!onComplete) { return; }
                try {
                    var result = onComplete(this._value);
                    if (result && typeof result === "object" && typeof result.done === "function") {
                        result.done();
                    }
                } catch (ex) {
                    // force the exception to be thrown asynchronously to avoid any try/catch blocks
                    WinJS.Utilities.Scheduler.schedule(function () {
                        throw ex;
                    }, WinJS.Utilities.Scheduler.Priority.normal, null, "WinJS.Promise._throwException");
                }
            },
            then: function CompletePromise_then(onComplete) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.then">
                /// <summary locid="WinJS.PromiseStateMachine.then">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.then_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The value is passed as the single argument. If the value is null, the value is returned.
                /// The value returned from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while this function is being executed, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function becomes the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onProgress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.PromiseStateMachine.then_returnValue">
                /// The promise whose value is the result of executing the complete or
                /// error function.
                /// </returns>
                /// </signature>
                try {
                    // If the value returned from the completion handler is the same as the value
                    // provided to the completion handler then there is no need for a new promise.
                    //
                    var newValue = onComplete ? onComplete(this._value) : this._value;
                    return newValue === this._value ? this : new CompletePromise(newValue);
                } catch (ex) {
                    return new ExceptionPromise(ex);
                }
            }
        }, {
            supportedForProcessing: false
        }
    );

    //
    // Promise is the user-creatable WinJS.Promise object.
    //

    function timeout(timeoutMS) {
        var id;
        return new WinJS.Promise(
            function (c) {
                if (timeoutMS) {
                    id = setTimeout(c, timeoutMS);
                } else {
                    setImmediate(c);
                }
            },
            function () {
                if (id) {
                    clearTimeout(id);
                }
            }
        );
    }

    function timeoutWithPromise(timeout, promise) {
        var cancelPromise = function () { promise.cancel(); }
        var cancelTimeout = function () { timeout.cancel(); }
        timeout.then(cancelPromise);
        promise.then(cancelTimeout, cancelTimeout);
        return promise;
    }

    var staticCanceledPromise;

    var Promise = WinJS.Class.derive(PromiseStateMachine,
        function Promise_ctor(init, oncancel) {
            /// <signature helpKeyword="WinJS.Promise">
            /// <summary locid="WinJS.Promise">
            /// A promise provides a mechanism to schedule work to be done on a value that
            /// has not yet been computed. It is a convenient abstraction for managing
            /// interactions with asynchronous APIs.
            /// </summary>
            /// <param name="init" type="Function" locid="WinJS.Promise_p:init">
            /// The function that is called during construction of the  promise. The function
            /// is given three arguments (complete, error, progress). Inside this function
            /// you should add event listeners for the notifications supported by this value.
            /// </param>
            /// <param name="oncancel" optional="true" locid="WinJS.Promise_p:oncancel">
            /// The function to call if a consumer of this promise wants
            /// to cancel its undone work. Promises are not required to
            /// support cancellation.
            /// </param>
            /// </signature>

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.promise))) {
                this._stack = WinJS.Promise._getStack();
            }

            this._oncancel = oncancel;
            this._setState(state_created);
            this._run();

            try {
                var complete = this._completed.bind(this);
                var error = this._error.bind(this);
                var progress = this._progress.bind(this);
                init(complete, error, progress);
            } catch (ex) {
                this._setExceptionValue(ex);
            }
        }, {
            _oncancel: null,

            _cancelAction: function () {
                if (this._oncancel) {
                    try { this._oncancel(); } catch (ex) { }
                }
            },
            _cleanupAction: function () { this._oncancel = null; }
        }, {

            addEventListener: function Promise_addEventListener(eventType, listener, capture) {
                /// <signature helpKeyword="WinJS.Promise.addEventListener">
                /// <summary locid="WinJS.Promise.addEventListener">
                /// Adds an event listener to the control.
                /// </summary>
                /// <param name="eventType" locid="WinJS.Promise.addEventListener_p:eventType">
                /// The type (name) of the event.
                /// </param>
                /// <param name="listener" locid="WinJS.Promise.addEventListener_p:listener">
                /// The listener to invoke when the event is raised.
                /// </param>
                /// <param name="capture" locid="WinJS.Promise.addEventListener_p:capture">
                /// Specifies whether or not to initiate capture.
                /// </param>
                /// </signature>
                promiseEventListeners.addEventListener(eventType, listener, capture);
            },
            any: function Promise_any(values) {
                /// <signature helpKeyword="WinJS.Promise.any">
                /// <summary locid="WinJS.Promise.any">
                /// Returns a promise that is fulfilled when one of the input promises
                /// has been fulfilled.
                /// </summary>
                /// <param name="values" type="Array" locid="WinJS.Promise.any_p:values">
                /// An array that contains promise objects or objects whose property
                /// values include promise objects.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.any_returnValue">
                /// A promise that on fulfillment yields the value of the input (complete or error).
                /// </returns>
                /// </signature>
                return new Promise(
                    function (complete, error, progress) {
                        var keys = Object.keys(values);
                        var errors = Array.isArray(values) ? [] : {};
                        if (keys.length === 0) {
                            complete();
                        }
                        var canceled = 0;
                        keys.forEach(function (key) {
                            Promise.as(values[key]).then(
                                function () { complete({ key: key, value: values[key] }); },
                                function (e) {
                                    if (e instanceof Error && e.name === canceledName) {
                                        if ((++canceled) === keys.length) {
                                            complete(WinJS.Promise.cancel);
                                        }
                                        return;
                                    }
                                    error({ key: key, value: values[key] });
                                }
                            );
                        });
                    },
                    function () {
                        var keys = Object.keys(values);
                        keys.forEach(function (key) {
                            var promise = Promise.as(values[key]);
                            if (typeof promise.cancel === "function") {
                                promise.cancel();
                            }
                        });
                    }
                );
            },
            as: function Promise_as(value) {
                /// <signature helpKeyword="WinJS.Promise.as">
                /// <summary locid="WinJS.Promise.as">
                /// Returns a promise. If the object is already a promise it is returned;
                /// otherwise the object is wrapped in a promise.
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.as_p:value">
                /// The value to be treated as a promise.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.as_returnValue">
                /// A promise.
                /// </returns>
                /// </signature>
                if (value && typeof value === "object" && typeof value.then === "function") {
                    return value;
                }
                return new CompletePromise(value);
            },
            /// <field type="WinJS.Promise" helpKeyword="WinJS.Promise.cancel" locid="WinJS.Promise.cancel">
            /// Canceled promise value, can be returned from a promise completion handler
            /// to indicate cancelation of the promise chain.
            /// </field>
            cancel: {
                get: function () {
                    return (staticCanceledPromise = staticCanceledPromise || new ErrorPromise(new WinJS.ErrorFromName(canceledName)));
                }
            },
            dispatchEvent: function Promise_dispatchEvent(eventType, details) {
                /// <signature helpKeyword="WinJS.Promise.dispatchEvent">
                /// <summary locid="WinJS.Promise.dispatchEvent">
                /// Raises an event of the specified type and properties.
                /// </summary>
                /// <param name="eventType" locid="WinJS.Promise.dispatchEvent_p:eventType">
                /// The type (name) of the event.
                /// </param>
                /// <param name="details" locid="WinJS.Promise.dispatchEvent_p:details">
                /// The set of additional properties to be attached to the event object.
                /// </param>
                /// <returns type="Boolean" locid="WinJS.Promise.dispatchEvent_returnValue">
                /// Specifies whether preventDefault was called on the event.
                /// </returns>
                /// </signature>
                return promiseEventListeners.dispatchEvent(eventType, details);
            },
            is: function Promise_is(value) {
                /// <signature helpKeyword="WinJS.Promise.is">
                /// <summary locid="WinJS.Promise.is">
                /// Determines whether a value fulfills the promise contract.
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.is_p:value">
                /// A value that may be a promise.
                /// </param>
                /// <returns type="Boolean" locid="WinJS.Promise.is_returnValue">
                /// true if the specified value is a promise, otherwise false.
                /// </returns>
                /// </signature>
                return value && typeof value === "object" && typeof value.then === "function";
            },
            join: function Promise_join(values) {
                /// <signature helpKeyword="WinJS.Promise.join">
                /// <summary locid="WinJS.Promise.join">
                /// Creates a promise that is fulfilled when all the values are fulfilled.
                /// </summary>
                /// <param name="values" type="Object" locid="WinJS.Promise.join_p:values">
                /// An object whose fields contain values, some of which may be promises.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.join_returnValue">
                /// A promise whose value is an object with the same field names as those of the object in the values parameter, where
                /// each field value is the fulfilled value of a promise.
                /// </returns>
                /// </signature>
                return new Promise(
                    function (complete, error, progress) {
                        var keys = Object.keys(values);
                        var errors = Array.isArray(values) ? [] : {};
                        var results = Array.isArray(values) ? [] : {};
                        var undefineds = 0;
                        var pending = keys.length;
                        var argDone = function (key) {
                            if ((--pending) === 0) {
                                var errorCount = Object.keys(errors).length;
                                if (errorCount === 0) {
                                    complete(results);
                                } else {
                                    var canceledCount = 0;
                                    keys.forEach(function (key) {
                                        var e = errors[key];
                                        if (e instanceof Error && e.name === canceledName) {
                                            canceledCount++;
                                        }
                                    });
                                    if (canceledCount === errorCount) {
                                        complete(WinJS.Promise.cancel);
                                    } else {
                                        error(errors);
                                    }
                                }
                            } else {
                                progress({ Key: key, Done: true });
                            }
                        };
                        keys.forEach(function (key) {
                            var value = values[key];
                            if (value === undefined) {
                                undefineds++;
                            } else {
                                Promise.then(value,
                                    function (value) { results[key] = value; argDone(key); },
                                    function (value) { errors[key] = value; argDone(key); }
                                );
                            }
                        });
                        pending -= undefineds;
                        if (pending === 0) {
                            complete(results);
                            return;
                        }
                    },
                    function () {
                        Object.keys(values).forEach(function (key) {
                            var promise = Promise.as(values[key]);
                            if (typeof promise.cancel === "function") {
                                promise.cancel();
                            }
                        });
                    }
                );
            },
            removeEventListener: function Promise_removeEventListener(eventType, listener, capture) {
                /// <signature helpKeyword="WinJS.Promise.removeEventListener">
                /// <summary locid="WinJS.Promise.removeEventListener">
                /// Removes an event listener from the control.
                /// </summary>
                /// <param name='eventType' locid="WinJS.Promise.removeEventListener_eventType">
                /// The type (name) of the event.
                /// </param>
                /// <param name='listener' locid="WinJS.Promise.removeEventListener_listener">
                /// The listener to remove.
                /// </param>
                /// <param name='capture' locid="WinJS.Promise.removeEventListener_capture">
                /// Specifies whether or not to initiate capture.
                /// </param>
                /// </signature>
                promiseEventListeners.removeEventListener(eventType, listener, capture);
            },
            supportedForProcessing: false,
            then: function Promise_then(value, onComplete, onError, onProgress) {
                /// <signature helpKeyword="WinJS.Promise.then">
                /// <summary locid="WinJS.Promise.then">
                /// A static version of the promise instance method then().
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.then_p:value">
                /// the value to be treated as a promise.
                /// </param>
                /// <param name="onComplete" type="Function" locid="WinJS.Promise.then_p:complete">
                /// The function to be called if the promise is fulfilled with a value.
                /// If it is null, the promise simply
                /// returns the value. The value is passed as the single argument.
                /// </param>
                /// <param name="onError" type="Function" optional="true" locid="WinJS.Promise.then_p:error">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument.
                /// </param>
                /// <param name="onProgress" type="Function" optional="true" locid="WinJS.Promise.then_p:progress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.then_returnValue">
                /// A promise whose value is the result of executing the provided complete function.
                /// </returns>
                /// </signature>
                return Promise.as(value).then(onComplete, onError, onProgress);
            },
            thenEach: function Promise_thenEach(values, onComplete, onError, onProgress) {
                /// <signature helpKeyword="WinJS.Promise.thenEach">
                /// <summary locid="WinJS.Promise.thenEach">
                /// Performs an operation on all the input promises and returns a promise
                /// that has the shape of the input and contains the result of the operation
                /// that has been performed on each input.
                /// </summary>
                /// <param name="values" locid="WinJS.Promise.thenEach_p:values">
                /// A set of values (which could be either an array or an object) of which some or all are promises.
                /// </param>
                /// <param name="onComplete" type="Function" locid="WinJS.Promise.thenEach_p:complete">
                /// The function to be called if the promise is fulfilled with a value.
                /// If the value is null, the promise returns the value.
                /// The value is passed as the single argument.
                /// </param>
                /// <param name="onError" type="Function" optional="true" locid="WinJS.Promise.thenEach_p:error">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument.
                /// </param>
                /// <param name="onProgress" type="Function" optional="true" locid="WinJS.Promise.thenEach_p:progress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.thenEach_returnValue">
                /// A promise that is the result of calling Promise.join on the values parameter.
                /// </returns>
                /// </signature>
                var result = Array.isArray(values) ? [] : {};
                Object.keys(values).forEach(function (key) {
                    result[key] = Promise.as(values[key]).then(onComplete, onError, onProgress);
                });
                return Promise.join(result);
            },
            timeout: function Promise_timeout(time, promise) {
                /// <signature helpKeyword="WinJS.Promise.timeout">
                /// <summary locid="WinJS.Promise.timeout">
                /// Creates a promise that is fulfilled after a timeout.
                /// </summary>
                /// <param name="timeout" type="Number" optional="true" locid="WinJS.Promise.timeout_p:timeout">
                /// The timeout period in milliseconds. If this value is zero or not specified
                /// setImmediate is called, otherwise setTimeout is called.
                /// </param>
                /// <param name="promise" type="Promise" optional="true" locid="WinJS.Promise.timeout_p:promise">
                /// A promise that will be canceled if it doesn't complete before the
                /// timeout has expired.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.timeout_returnValue">
                /// A promise that is completed asynchronously after the specified timeout.
                /// </returns>
                /// </signature>
                var to = timeout(time);
                return promise ? timeoutWithPromise(to, promise) : to;
            },
            wrap: function Promise_wrap(value) {
                /// <signature helpKeyword="WinJS.Promise.wrap">
                /// <summary locid="WinJS.Promise.wrap">
                /// Wraps a non-promise value in a promise. You can use this function if you need
                /// to pass a value to a function that requires a promise.
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.wrap_p:value">
                /// Some non-promise value to be wrapped in a promise.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.wrap_returnValue">
                /// A promise that is successfully fulfilled with the specified value
                /// </returns>
                /// </signature>
                return new CompletePromise(value);
            },
            wrapError: function Promise_wrapError(error) {
                /// <signature helpKeyword="WinJS.Promise.wrapError">
                /// <summary locid="WinJS.Promise.wrapError">
                /// Wraps a non-promise error value in a promise. You can use this function if you need
                /// to pass an error to a function that requires a promise.
                /// </summary>
                /// <param name="error" locid="WinJS.Promise.wrapError_p:error">
                /// A non-promise error value to be wrapped in a promise.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.wrapError_returnValue">
                /// A promise that is in an error state with the specified value.
                /// </returns>
                /// </signature>
                return new ErrorPromise(error);
            },

            _veryExpensiveTagWithStack: {
                get: function () { return tagWithStack; },
                set: function (value) { tagWithStack = value; }
            },
            _veryExpensiveTagWithStack_tag: tag,
            _getStack: function () {
                try { throw new Error(); } catch (e) { return e.stack; }
            },

            _cancelBlocker: function Promise__cancelBlocker(input) {
                //
                // Returns a promise which on cancelation will still result in downstream cancelation while
                //  protecting the promise 'input' from being  canceled which has the effect of allowing 
                //  'input' to be shared amoung various consumers.
                //
                if (!Promise.is(input)) {
                    return Promise.wrap(input);
                }
                var complete;
                var error;
                var output = new WinJS.Promise(
                    function (c, e) {
                        complete = c;
                        error = e;
                    },
                    function () {
                        complete = null;
                        error = null;
                    }
                );
                input.then(
                    function (v) { complete && complete(v); },
                    function (e) { error && error(e); }
                );
                return output;
            },

        }
    );
    Object.defineProperties(Promise, WinJS.Utilities.createEventProperties(errorET));

    var SignalPromise = WinJS.Class.derive(PromiseStateMachine,
        function (cancel) {
            this._oncancel = cancel;
            this._setState(state_created);
            this._run();
        }, {
            _cancelAction: function () { this._oncancel && this._oncancel(); },
            _cleanupAction: function () { this._oncancel = null; }
        }, {
            supportedForProcessing: false
        }
    );

    var Signal = WinJS.Class.define(
        function Signal_ctor(oncancel) {
            this._promise = new SignalPromise(oncancel);
        }, {
            promise: {
                get: function () { return this._promise; }
            },

            cancel: function Signal_cancel() {
                this._promise.cancel();
            },
            complete: function Signal_complete(value) {
                this._promise._completed(value);
            },
            error: function Signal_error(value) {
                this._promise._error(value);
            },
            progress: function Signal_progress(value) {
                this._promise._progress(value);
            }
        }, {
            supportedForProcessing: false,
        }
    );

    // Publish WinJS.Promise
    //
    WinJS.Namespace.define("WinJS", {
        Promise: Promise,
        _Signal: Signal
    });

}(this));

 /***********************************************************
 * winjs-promise.js end
 **********************************************************/
//globalHolder.WinJS.Promise.all = globalHolder.WinJS.Promise.join;

 /***********************************************************
 * assign to global Class
 **********************************************************/
Promise = WinJS.Promise;
;var CoreUtilities;
(function (CoreUtilities) {
    // Contains utility functions that are common to Threshold clients - Cortana, Spartan OneBox etc.
    // Do not include client specfic code here.
    function deferFunction(functionPointer) {
        var originalArgs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            originalArgs[_i - 1] = arguments[_i];
        }
        return deferMethod.apply(null, [null, functionPointer].concat(originalArgs));
    }
    CoreUtilities.deferFunction = deferFunction;
    function deferMethod(sourceObject, functionPointer) {
        var originalArgs = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            originalArgs[_i - 2] = arguments[_i];
        }
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            if (!args || args.length === 0) {
                args = originalArgs;
            }
            else {
                for (var i in originalArgs) {
                    if (originalArgs.hasOwnProperty(i)) {
                        args.push(originalArgs[i]);
                    }
                }
            }
            return functionPointer.apply(sourceObject, args);
        };
    }
    CoreUtilities.deferMethod = deferMethod;
    // gets a property out of an object. 
    // should be used in cases where object has a lot of layers of properties.
    // the arguments will be object, list of properties. 
    // it works recursively so it will keep calling itself with the current object and the rest of the properties.
    // e.g. var a = { b: { c: { d: "e" } } } to get to "e", you can call getProperty(a, b, c, d)
    // will return null if any of the layers don't have what was passed in (e. g. getProperty(a, b, d))
    function getProperty() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        var currentState = args[0];
        for (var i = 1; i < args.length; i++) {
            if (currentState) {
                currentState = currentState[args[i]];
            }
            else {
                return null;
            }
        }
        return currentState;
    }
    CoreUtilities.getProperty = getProperty;
    // Legacy Support
    window["sj_df"] = deferFunction;
    window["sj_dm"] = deferMethod;
    window["sj_gp"] = getProperty;
})(CoreUtilities || (CoreUtilities = {}));
;/// <reference path="..\Declarations\Shared.d.ts"/>
/// <reference path="..\Declarations\Threshold.Utilities.d.ts"/>
var ThresholdDiagnosticsProd = (function () {
    function ThresholdDiagnosticsProd() {
        this.debugStrings = [];
        this.submitCallbackBound = false;
        sj_evt.bind("ajax.WindowsFeedback.Form.Shown", sj_dm(this, this.onFeedbackFormShown));
        sj_evt.bind("ajax.threshold.pageStart", sj_dm(this, this.clearDebugStrings));
    }
    ThresholdDiagnosticsProd.prototype.recordApiString = function (debugString) {
        console.log(debugString);
        this.debugStrings.push(debugString);
    };
    ThresholdDiagnosticsProd.prototype.clearDebugStrings = function () {
        this.debugStrings.length = 0;
    };
    ThresholdDiagnosticsProd.prototype.onFeedbackFormShown = function () {
        var form = _ge("fdbkfrm");
        if (form) {
            if (!this.submitCallbackBound) {
                var deferredSubmitCallback = sj_dm(this, this.onFeedbackFormSubmit, form);
                var formButtons = form.getElementsByClassName("fdbkactionbtns");
                if (formButtons && formButtons.length == 1) {
                    // onFeedbackFormSubmit is bound to a parent of the submit button (the div containing the submit/cancel buttons).
                    // It is bound with useCapture=true to ensure that a click on the submit button reaches our callback before the feedback 
                    // form's normal submission callback (which is bound to "click" on the button itself).
                    sj_be(formButtons[0], "click", deferredSubmitCallback, true);
                    this.submitCallbackBound = true;
                }
            }
        }
        else {
            // If the form is missing, a new method would need to be created and bound
            this.submitCallbackBound = false;
        }
    };
    ThresholdDiagnosticsProd.prototype.onFeedbackFormSubmit = function (event, form) {
        var apiDebug = "apiDebug";
        var pageDebug = _w["PageDebug"];
        var screenshotCheckbox = form.elements["screenshot"];
        // We assume that if there was no screenshot input element we didn't need the user's permission to get one
        if (!screenshotCheckbox || screenshotCheckbox.checked) {
            pageDebug[apiDebug] = this.debugStrings.toString();
        }
        else if (pageDebug[apiDebug]) {
            delete pageDebug[apiDebug];
        }
    };
    return ThresholdDiagnosticsProd;
})();
_w["ThresholdDiagnostics"] = new ThresholdDiagnosticsProd();
;
//]]></script><script type="text/javascript" src="/rms/rms%20answers%20Shared%20Threshold$Threshold.UtilitiesM2/nj/ebdb5391/c4a005fe.js"></script><script type="text/javascript">//<![CDATA[
// ------------------------------------------------------------------------------
// <copyright file="SearchAppAndroid.ts" company="Microsoft Corporation">
//     Copyright (c) Microsoft Corporation. All Rights Reserved.
//     Information Contained Herein is Proprietary and Confidential.
// </copyright>
// ------------------------------------------------------------------------------
/// <reference path="Declarations\CortanaSearch.d.ts" />
/// <reference path="..\..\..\..\Shared\Content\Content\Script\Declarations\Promise.Mock.d.ts" />
/// <reference path="..\..\..\..\Shared\Content\Content\Script\Declarations\Threshold.Utilities.d.ts" />
var WrapApi;
(function (WrapApi) {
    function completePromise(completionFunction) {
        if (WrapApi.AndroidReturnAsync) {
            // Set a timeout to finish resolution after the current call stack of execution finished.
            sb_st(function () { return completionFunction(); }, 0);
        }
        else {
            // To maintain current behavior, resolve synchronously.
            completionFunction();
        }
    }
    // This method clones an object while providing a wrapMethod bridges between one implementation of a function and another.
    // We use it to make sure the object we get back from Cortana API calls can fall back to our mock implementations if Cortana APIs fail or are not implemented.
    function wrapAndroidApi(cortanaObject) {
        if (cortanaObject) {
            // we don't implement the following as QF and device search are not part of CoA
            // searchResultsView: ISearchResultsView;
            // searchBox: ISearchBox;
            cortanaObject.isCortanaEnabled = cortanaObject.getIsCortanaEnabled();
            cortanaObject.isBingEnabled = cortanaObject.getIsBingEnabled();
            cortanaObject.isMobile = cortanaObject.getIsMobile();
            cortanaObject.region = cortanaObject.getRegion(); // The country code for the current region  
            cortanaObject.uiLanguage = cortanaObject.getUiLanguage(); // the language code for localized resources  
            cortanaObject.sessionId = cortanaObject.getSessionId(); // Logged in the Client to identify App open -> App close "sessions"  
            cortanaObject.impressionId = cortanaObject.getImpressionId(); // Produced by the client & logged by the server to identify each Keystroke  
            if (typeof cortanaObject.getCurrentState === 'function') {
                cortanaObject.currentState = cortanaObject.getCurrentState();
            }
            cortanaObject.launcher = cortanaObject.launcher || {
                launchUriAsync: function (uri, options) {
                    return new Promise(function (resolve, reject) {
                        var result = cortanaObject.launchUriSync(uri, options);
                        completePromise(function () { return resolve(result); });
                    });
                },
                launchRAFAsync: function (rawQuery, formCode) {
                    cortanaObject.launchRAFSync(rawQuery, formCode);
                },
                startPhoneCallAsync: function (phoneNumber, displayName) {
                    return new Promise(function (resolve, reject) {
                        cortanaObject.startPhoneCallSync(phoneNumber, displayName);
                        completePromise(function () { return resolve(true); });
                    });
                },
                navigateReactiveViewAsync: function (rawQuery, formCode) {
                    return new Promise(function (resolve, reject) {
                        var result = false;
                        if (cortanaObject.navigateReactiveViewSync) {
                            result = cortanaObject.navigateReactiveViewSync(rawQuery, formCode);
                        }
                        completePromise(function () { return resolve(result); });
                    });
                }
            };
            cortanaObject.proactiveView = cortanaObject.proactiveView || {
                invalidateCacheAsync: function () {
                    return new Promise(function (resolve, reject) {
                        var result = false;
                        if (cortanaObject.invalidateCacheSync) {
                            result = cortanaObject.invalidateCacheSync();
                        }
                        completePromise(function () { return resolve(result); });
                    });
                },
                perfMetrics: {
                    lookup: function (perfMetricKey) {
                        var result = 0;
                        if (cortanaObject.perfMetricLookup) {
                            result = cortanaObject.perfMetricLookup(perfMetricKey);
                        }
                        return new Date(result);
                    }
                }
            };
            cortanaObject.getQueryHeadersAsync = function () {
                return new Promise(function (resolve, reject) {
                    var headerString = cortanaObject.getQueryHeadersSync();
                    var headers = JSON.parse(headerString);
                    completePromise(function () { return resolve(headers); });
                });
            };
            if (typeof cortanaObject.navigateWebViewSync === 'function') {
                cortanaObject.navigateWebViewAsync = function (uri) {
                    return new Promise(function (resolve, reject) {
                        cortanaObject.navigateWebViewSync(uri);
                        completePromise(function () { return resolve(true); });
                    });
                };
            }
            cortanaObject.navigateWebViewWithPostAsync = function (uri, parameters) {
                return new Promise(function (resolve, reject) {
                    var postDataStringified = JSON.stringify(parameters);
                    cortanaObject.navigateWebViewWithPostSync(uri, postDataStringified);
                    completePromise(function () { return resolve(true); });
                });
            };
            cortanaObject.navigateWebViewBackAsync = function (frameCount) {
                return new Promise(function (resolve, reject) {
                    cortanaObject.navigateWebViewBackSync(frameCount);
                    completePromise(function () { return resolve(true); });
                });
            };
            cortanaObject.showWebViewAsync = function () {
                return new Promise(function (resolve, reject) {
                    cortanaObject.showWebViewSync();
                    completePromise(function () { return resolve(true); });
                });
            };
            cortanaObject.launchExperienceByName = function (experienceName, parameters) {
                var experienceDataStringified = JSON.stringify(parameters);
                cortanaObject.launchExperienceByNameSync(experienceName, experienceDataStringified);
            };
            var eventListenerMap = {};
            function triggerElement(element, index, array) {
                element();
            }
            ;
            cortanaObject.addEventListener = function (eventName, cb) {
                if (eventListenerMap[eventName] === undefined) {
                    eventListenerMap[eventName] = [];
                }
                eventListenerMap[eventName].push(cb);
            };
            cortanaObject.triggerEventListener = function (eventName) {
                if (eventListenerMap[eventName] !== undefined) {
                    eventListenerMap[eventName].forEach(triggerElement);
                }
            };
            function doneablePromise(fn) {
                var promise = new Promise(fn);
                if (typeof Promise.prototype.done !== 'function') {
                    promise.done = function (onFulfilled, onRejected) {
                        promise.then(onFulfilled, onRejected);
                    };
                }
                return promise;
            }
            var Screenshot = function (fileName, content, type) {
                this.fileName = fileName;
                this.contentType = type;
                var base64Content = content;
                this.getBase64ContentAsync = function () {
                    return doneablePromise(function (resolve, reject) {
                        completePromise(function () { return resolve(base64Content); });
                    });
                };
            };
            cortanaObject.getFeedbackFilesAsync = function () {
                return doneablePromise(function (resolve, reject) {
                    var data = JSON.parse(cortanaObject.getFeedbackFilesSync());
                    if (!data) {
                        completePromise(function () { return reject("Get feedback files failed."); });
                        return;
                    }
                    var screenshots = data.screenshots;
                    var files = {};
                    var i = 0;
                    var iLength = 0;
                    if (screenshots && screenshots.length > 0) {
                        for (i = 0, iLength = screenshots.length; i < iLength; i++) {
                            files[i] = new Screenshot(screenshots[i].fileName, screenshots[i].content, screenshots[i].type);
                        }
                    }
                    files['size'] = iLength;
                    completePromise(function () { return resolve(files); });
                });
            };
            //TFS 5227831: [CoA] In order to support proactive peek, implement cortanaApp.logMeasure() and cortanaApp.setNonAnimatingCortanaText(�)
            cortanaObject.logMeasure = function () {
            };
            cortanaObject.setNonAnimatingCortanaText = function () {
            };
            cortanaObject.processNLCommandAsync = function (commandTaskFrame, impressionId) {
                return new Promise(function (resolve, reject) {
                    var result = cortanaObject.processNLCommandSync(commandTaskFrame, impressionId);
                    completePromise(function () { return resolve(result); });
                });
            };
            cortanaObject.searchResultsView = {};
            cortanaObject.searchResultsView.executeSearchAsync = function (query) {
                return new Promise(function (resolve, reject) {
                    var result = cortanaObject.executeSearchSync(query);
                    completePromise(function () { return resolve(result); });
                });
            };
            cortanaObject.searchResultsView.deviceSearch = {};
            cortanaObject.searchResultsView.deviceSearch.findAppsAsync = function (appIds, impressionId) {
                return new Promise(function (resolve, reject) {
                    var appMapString = cortanaObject.findAppsSync(appIds, impressionId);
                    var appMap;
                    if (appMapString) {
                        try {
                            appMap = JSON.parse(appMapString);
                        }
                        catch (e) {
                            alert(e);
                        }
                    }
                    completePromise(function () { return resolve(appMap); });
                });
            };
            // SPA - Potable Cortana
            var spaEventListenerMap = {};
            cortanaObject.spaDialogRuntime = cortanaObject.spaDialogRuntime || {
                // NL APIs
                // Doing
                startLanguageUnderstandingFromVoiceAsync: function (cuInput) {
                    return new Promise(function (resolve, reject) {
                        var result = cortanaObject.startLanguageUnderstandingFromVoiceSync(cuInput);
                        completePromise(function () { return resolve(result); });
                    });
                },
                startDictationAsync: function (cuInput) {
                    return new Promise(function (resolve, reject) {
                        cortanaObject.startDictationSync(cuInput);
                        completePromise(function () { return resolve(true); });
                    });
                },
                endpointAudio: function (operationId) {
                    cortanaObject.endpointAudio(operationId);
                },
                dialogComplete: function (completionState) {
                    cortanaObject.dialogComplete(completionState);
                },
                // TTS APIs
                playEarconAsync: function (earConType) {
                    return new Promise(function (resolve, reject) {
                        cortanaObject.playEarconSync(earConType);
                        completePromise(function () { return resolve(true); });
                    });
                },
                // 
                speakAsync: function (ssmlData) {
                    return new Promise(function (resolve, reject) {
                        cortanaObject.speakSync(ssmlData);
                        completePromise(function () { return resolve(true); });
                    });
                },
                // 
                stopSpeakingAsync: function () {
                    return new Promise(function (resolve, reject) {
                        cortanaObject.stopSpeakingSync();
                        completePromise(function () { return resolve(true); });
                    });
                },
                // UI update APIs
                // 
                updateTrex: function (trexText) {
                    cortanaObject.updateTrex(trexText);
                },
                // 
                updateGui: function (uiState) {
                    cortanaObject.updateGui(uiState);
                },
                changeSticMode: function (isEnabled) {
                    cortanaObject.changeSticMode(isEnabled);
                },
                changeSticStateAndInputMode: function (spaSticState, spaSticInputMode) {
                    cortanaObject.changeSticStateAndInputMode(spaSticState, spaSticInputMode);
                },
                addEventListener: function (eventName, handler) {
                    if (!eventName) {
                        return;
                    }
                    eventName = eventName.toLowerCase();
                    if (spaEventListenerMap[eventName]) {
                        return;
                    }
                    spaEventListenerMap[eventName] = handler;
                    cortanaObject.registerEventListener(eventName, "CortanaApp.spaDialogRuntime.triggerEventListener");
                },
                triggerEventListener: function (eventName, params) {
                    if (!eventName) {
                        return;
                    }
                    eventName = eventName.toLowerCase();
                    var eventHandler = spaEventListenerMap[eventName];
                    if (!eventHandler) {
                        return;
                    }
                    var jsonParams = {};
                    try {
                        jsonParams = JSON.parse(params);
                    }
                    catch (e) {
                    }
                    if (typeof eventHandler === 'function') {
                        eventHandler.call(null, jsonParams);
                    }
                },
                removeEventListener: function (eventName, handler) {
                    if (!eventName) {
                        return;
                    }
                    eventName = eventName.toLowerCase();
                    if (!spaEventListenerMap[eventName]) {
                        return;
                    }
                    delete spaEventListenerMap[eventName];
                    cortanaObject.removeEventListener(eventName);
                }
            };
            return cortanaObject;
        }
    }
    WrapApi.wrapAndroidApi = wrapAndroidApi;
})(WrapApi || (WrapApi = {}));
var SearchAppWrapper = {
    CortanaApp: (_w['CortanaApp'] ? WrapApi.wrapAndroidApi(_w['CortanaApp']) : _w['MockCortanaAppInstance'])
};
;///<reference path="..\Declarations\Shared.d.ts"/>
var sj_b = _d.body;
;///<reference path="queue.ts"/>
BM.trigger();
;_G.AppVer="8_1_2_4971474";
//]]></script><script type="text/javascript">//<![CDATA[
_G.FCT=new Date;
//]]></script><script type="text/javascript">//<![CDATA[
_G.BCT=new Date;
//]]></script><style type="text/css">/* Do nothing. */

z {
  a: 1;
}
.b_vList > li.b_annooverride {
  padding-bottom: 0;
}
.sa_uc{clear:both;padding:0 0 10px}.sa_uc:after{clear:both;content:'.';display:block;height:0;visibility:hidden}.hsPanel {
  display: inline;
}
.hsPanel > span {
  padding-right: 5px;
}
.hsPanel .b_hintBadge {
  margin: 2.5px 0;
  display: inline-block;
}
/* badge item styles*/

.b_newBadge,
.b_safeBadge,
.b_notAvailableBadge,
.b_hintBadge,
.b_normalBadge,
.b_warningBadge,
.b_excellentBadge,
.b_goodBadge,
.b_notGoodBadge,
.b_badBadge,
.b_worseBadge,
.b_worstBadge {
  padding: 0 10px;
  color: white;
  display: inline-block;
}
.b_newBadge {
  background-color: #e12823;
}
.b_safeBadge {
  background-color: #339900;
}
.b_notAvailableBadge {
  background-color: gray;
}
.b_hintBadge {
  background-color: #bbbbbb;
}
.b_normalBadge {
  background-color: #2291ff;
}
.b_warningBadge {
  background-color: #ffaa00;
}
.b_excellentBadge {
  background-color: #339900;
}
.b_goodBadge {
  background-color: #78c800;
}
.b_notGoodBadge {
  background-color: #ffaa00;
}
.b_badBadge {
  background-color: #f07d00;
}
.b_worseBadge {
  background-color: #e12823;
}
.b_worstBadge {
  background-color: #b20000;
}
.msn_expansionList {
  margin: 3px 0 7px;
}
.msn_expansionList:last-child {
  margin: 3px 0 0;
}
.msn_expansionList:not(.msn_expNoTopBorder) {
  border-top: solid 1px whitesmoke;
}
.msn_expansionList > li {
  padding/* bingcss-ignore:  Top padding is OK to define inside style of container */: 10px 0;
  border-bottom: solid 1px whitesmoke;
}
.msn_expansionList:last-child > li:last-child {
  padding/* bingcss-ignore:  Top padding is OK to define inside style of container */: 10px 0;
  border-bottom: none;
}
.msn_expansionList .ArrowsIcon {
  float: right;
  margin: 7px 5px;
}
.BlockArrowsIcon {
  margin: 0 -10px;
  padding/* bingcss-ignore:  Top padding is OK to define inside styled of container */: 10px 0 0;
  border-top: solid 1px #e1e1e1;
  vertical-align: middle;
  text-align: center;
}
.msn_expansionList .HiddenSection {
  margin-top: 10px;
}
.targetHeight {
  min-height: 25px;
}
.btm_sml .sw_plus,
.btm_sml .sw_minus,
.sml .sw_plus,
.sml .sw_minus {
  display: inline-block;
  text-decoration: none;
  margin: 0 4px 1px 0;
}
.b_tblWithExpansion .btm_sml,
.b_tblWithExpansion .sml {
  padding-bottom: 12px;
}
.b_relative .btm_sml,
.b_relative .sml {
  letter-spacing: 2px;
}
.inline {
  display: inline-block;
  margin-left: 4px;
}
.sml.inline .sw_plus,
.sml.inline .sw_minus {
  margin: 0;
}
.btm_sml {
  padding-bottom: 24px;
}
/*
    fix empty div bug on Cortana
*/

.hidden_nostyle {
  padding: 0 !important;
  margin: 0 !important;
}
/*
    for slide animation, from animation.css
*/

.exp_slide {
  overflow: hidden;
  -webkit-transition: height cubic-bezier(0.15, 0.85, 0.35, 1) 350ms;
  -moz-transition: height cubic-bezier(0.15, 0.85, 0.35, 1) 350ms;
  -o-transition: height cubic-bezier(0.15, 0.85, 0.35, 1) 350ms;
  transition: height cubic-bezier(0.15, 0.85, 0.35, 1) 350ms;
}
.exp_slide.b_hide {
  display: block;
  /* Needs to be important to override the values from other classes */
  height: 0 !important;
  padding-top/* bingcss-ignore */: 0 !important;
  padding-bottom: 0 !important;
  margin-top: 0 !important;
  margin-bottom: 0 !important;
  border-top: 0 !important;
  border-bottom: 0 !important;
}
/*
    for scroll back when collapse
*/

body.exp_scroll {
  -webkit-transition: margin-top cubic-bezier(0.15, 0.85, 0.35, 1) 350ms;
  -moz-transition: margin-top cubic-bezier(0.15, 0.85, 0.35, 1) 350ms;
  -o-transition: margin-top cubic-bezier(0.15, 0.85, 0.35, 1) 350ms;
  transition: margin-top cubic-bezier(0.15, 0.85, 0.35, 1) 350ms;
}
/*This file is intentionally left empty*/
.imse 
{
    
}.b_top .sml.topanswer a,
.b_top .btm_sml a {
  background-color: #f9f9f9;
  margin: 0 -19px -10px -19px;
  display: block;
  text-decoration: none;
  text-align: center;
}
.b_top .sml.topanswer a {
  line-height: 35px;
  outline: none;
}
.b_top .btm_sml .leftAlign {
  text-align: left;
}
.b_top .btm_sml a {
  line-height: 40px;
  height: 40px;
  vertical-align: middle;
}
.b_top .btm_sml {
  padding-bottom: 0;
}
.b_top .btm_sml a:hover,
.b_top .sml.topanswer a:hover {
  background-color: #eeeeee;
}
.b_top .btm_sml a .expansionDefaultText {
  display: none;
  text-align: center;
}
.b_top .btm_sml a .expansionCustomizedText {
  text-align: left;
  padding: 0 0 0 19px;
  display: inline-block;
  *display: inline;
  zoom: 1;
}
.b_top .btm_sml .expansionChevronUp {
  background-image: url(/sa/simg/ansexp_chev_up.png);
}
.b_top .btm_sml .expansionChevronDown {
  background-image: url(/sa/simg/ansexp_chev_down.png);
}
.b_top .btm_sml .expansionChevronDown,
.b_top .btm_sml .expansionChevronUp {
  background-repeat: no-repeat;
  height: 9px;
  width: 16px;
  display: inline-block;
  *display: inline;
  zoom: 1;
  background-position: 0 0;
  margin: 0 19px 0 12px;
}
.b_top .btm_sml .expandChevronContainer {
  line-height: 40px;
  vertical-align: middle;
}
.b_top .btm_sml .expansionChevronDown.noExpandText,
.b_top .btm_sml .expansionChevronUp.noExpandText {
  margin: 0;
}
.b_top .btm_sml .expansionChevronUp.hasExpandText,
.b_top .btm_sml .expansionChevronDown.hasExpandText {
  margin-bottom: 0;
}
#b_results > .b_top .btm_sml a,
#b_results > .b_top .btm_sml a:visited {
  color: #444444;
}
.e_mhdr .btm_sml a {
  padding: 0;
  border-top: 0;
  margin-top: 10px;
}
/*This file is intentionally left empty*/
.imse 
{
    
}/*This file is intentionally left empty*/
.imse 
{
    
}/*
//  cipl - Common play icon for use with text link
//  cipa - Common play icon link
//  cipg - Disabled common play icon
//  cipt - Disabled common play icon for use with text
//  ciptr - icon on right side
//  ciplr - icon on right side
*/

.cipt,
.cipg,
.cipa,
.cipl,
.ciptr,
.ciplr {
  display: inline-block;
}
.cipa,
.cipl,
.ciplr {
  cursor: pointer;
}
.vab {
  vertical-align: bottom;
}
.vam {
  vertical-align: middle;
}
.vat {
  vertical-align: top;
}
.vabl {
  vertical-align: baseline;
}
.vatt {
  vertical-align: text-top;
}
.vatb {
  vertical-align: text-bottom;
}
.cipt,
.cipl {
  margin-right: 5px;
}
.ciptr,
.ciplr {
  margin-left: 5px;
}
.mb_ok_tag {
  font-size: 12px;
  border: 1px solid #aaaaaa;
  color: #777777;
  padding: 0 5px;
  margin-right: 5px;
  display: inline-block;
  vertical-align: middle;
  line-height: 16px;
  margin-top/*bingcss-ignore: tiny adjust to make this text in the middle of this line*/: -2px;
}
#b_context .b_rs .b_vList > li {
  padding-bottom: 4px;
}
#b_context .b_rs > .b_vList {
  padding-bottom: 6px;
}
/* Special styling for when the emotion is in large mode */

.b_anno.large {
  font-size: 42px;
  line-height: 51px;
  text-align: center;
  font-weight: 300;
}
/*
    Initially hide various elements. Note that this is a pretty big hack to make sure the
    initial paint is correct. The JS ends up slapping a b_hide on the elements, but that doesn't
    generally get executed before the first paint so there may be some jumps in the rendering.
    So the JS will slap both b_hide and peek classes on to handle this state.
    Make sure this matches the SearchPeek JS.
*/

#b_header:not(.peek),
.b_anno ~ h2:not(.peek),
.b_anno ~ .b_focusLabel:not(.peek),
#b_results:not(.peek) > *,
.b_footer:not(.peek) {
  display: none;
}
html.peek,
body.peek {
  background-color: white;
}
/*
    Use the javascipt methods in Animation.ts to toggle the animation instead of directly setting the class.      
        
    b_slide - Use this class when an element may slide up/down via animation.  Used by toggleSlide in Animation.ts.
    b_fade - Use this class when an element may fade in/out via animation. Upon completion of animation, element will completely disappear and occupies no space in view. Used by toggleFade in Animation.ts
    b_fadeUp - Use this class when an element may fade up/down via animation. Upon completion of animation, element will completely disappear and occupies no space in view. Used by toggleFadeUp in Animation.ts
    b_slideListUp - Use this class to animate a list of items slide up from bottom and arrive at destination one by one. Used by cascadeList in Animation.ts
    b_anim - Use this class when an element may show/hide via animation.     
    Animate by toggling the b_hide class. We override the default behavior of b_hide here.
*/

.b_fade,
.b_slide,
.b_anim,
.b_fadeUp,
.b_slideListHide,
.b_slideTranslate {
  overflow: hidden;
}
.b_fade.b_hide,
.b_slide.b_hide,
.b_slideTranslate.b_hide,
.b_anim.b_hide,
.b_fadeUp.b_hide,
.b_slideListHide {
  display: block;
  /* Needs to be important to override the values from other classes */
  padding-top/* bingcss-ignore */: 0 !important;
  padding-bottom/* bingcss-ignore */: 0 !important;
  margin-top/* bingcss-ignore */: 0 !important;
  margin-bottom/* bingcss-ignore */: 0 !important;
  border-top/* bingcss-ignore */: 0 !important;
  border-bottom/* bingcss-ignore */: 0 !important;
}
.b_slide.b_hide,
.b_anim.b_hide,
.b_slideListHide {
  /* Needs to be important to override the values from other classes */
  height/* bingcss-ignore */: 0 !important;
}
/* slide up/down the element with fixed/known height */

.b_anim {
  -webkit-transition: all 250ms;
  -moz-transition: all 250ms;
  -o-transition: all 250ms;
  transition: all 250ms;
}
/* fade out the element and makes sure no space is occupied upon completion*/

.b_fade {
  opacity: 1;
  max-height: 9999px;
  /* open up the container first, then fade in the content*/
  -webkit-transition: opacity linear 250ms, max-height linear 0ms 0ms;
  -moz-transition: opacity linear 250ms, max-height linear 0ms 0ms;
  -o-transition: opacity linear 250ms, max-height linear 0ms 0ms;
  transition: opacity linear 250ms, max-height linear 0ms 0ms;
}
.b_fade.b_hide {
  opacity: 0;
  max-height: 0;
  /* fade out the content first, then collapse the container*/
  -webkit-transition: opacity linear 250ms, max-height linear 0ms 250ms;
  -moz-transition: opacity linear 250ms, max-height linear 0ms 250ms;
  -o-transition: opacity linear 250ms, max-height linear 0ms 250ms;
  transition: opacity linear 250ms, max-height linear 0ms 250ms;
}
/* fade up the element and makes sure no space is occupied upon completion.  This is usually used for text animation*/

.b_fadeUp {
  opacity: 1;
  max-height: 9999px;
  -webkit-transform: translateY(0);
  -moz-transform: translateY(0);
  -o-transform: translateY(0);
  transform: translateY(0);
  -webkit-transition: opacity linear 170ms, -webkit-transform cubic-bezier(0.15, 0.85, 0.35, 1) 500ms, max-height linear 0ms;
  -moz-transition: opacity linear 170ms, -moz-transform cubic-bezier(0.15, 0.85, 0.35, 1) 500ms, max-height linear 0ms;
  -o-transition: opacity linear 170ms, -o-transform cubic-bezier(0.15, 0.85, 0.35, 1) 500ms, max-height linear 0ms;
  transition: opacity linear 170ms, transform cubic-bezier(0.15, 0.85, 0.35, 1) 500ms, max-height linear 0ms;
}
.b_fadeUp.b_hide {
  opacity: 0;
  max-height: 0;
  -webkit-transform: translateY(10px);
  -moz-transform: translateY(10px);
  -o-transform: translateY(10px);
  transform: translateY(10px);
  -webkit-transition: opacity linear 170ms, -webkit-transform cubic-bezier(0.15, 0.85, 0.35, 1) 500ms, max-height linear 0ms 500ms;
  -moz-transition: opacity linear 170ms, -moz-transform cubic-bezier(0.15, 0.85, 0.35, 1) 500ms, max-height linear 0ms 500ms;
  -o-transition: opacity linear 170ms, -o-transform cubic-bezier(0.15, 0.85, 0.35, 1) 500ms, max-height linear 0ms 500ms;
  transition: opacity linear 170ms, transform cubic-bezier(0.15, 0.85, 0.35, 1) 500ms, max-height linear 0ms 500ms;
}
/* slide up/down the element */

.b_slide,
.b_slide.b_hide {
  -webkit-transition: height cubic-bezier(0.15, 0.85, 0.35, 1) 250ms;
  -moz-transition: height cubic-bezier(0.15, 0.85, 0.35, 1) 250ms;
  -o-transition: height cubic-bezier(0.15, 0.85, 0.35, 1) 250ms;
  transition: height cubic-bezier(0.15, 0.85, 0.35, 1) 250ms;
}
.b_slideTranslate {
  max-height: 9999px;
  -webkit-transform: translateY(0);
  -moz-transform: translateY(0);
  -o-transform: translateY(0);
  transform: translateY(0);
  -webkit-transition: -webkit-transform cubic-bezier(0.15, 0.85, 0.35, 1) 250ms, max-height linear 0ms 0ms;
  -moz-transition: -moz-transform cubic-bezier(0.15, 0.85, 0.35, 1) 250ms, max-height linear 0ms 0ms;
  -o-transition: -o-transform cubic-bezier(0.15, 0.85, 0.35, 1) 250ms, max-height linear 0ms 0ms;
  transition: transform cubic-bezier(0.15, 0.85, 0.35, 1) 250ms, max-height linear 0ms 0ms;
}
.b_slideTranslate.b_hide {
  max-height: 0;
  -webkit-transform: translateY(-200px);
  -moz-transform: translateY(-200px);
  -o-transform: translateY(-200px);
  transform: translateY(-200px);
  -webkit-transition: -webkit-transform cubic-bezier(0.15, 0.85, 0.35, 1) 250ms, max-height linear 0ms 250ms;
  -moz-transition: -moz-transform cubic-bezier(0.15, 0.85, 0.35, 1) 250ms, max-height linear 0ms 250ms;
  -o-transition: -o-transform cubic-bezier(0.15, 0.85, 0.35, 1) 250ms, max-height linear 0ms 250ms;
  transition: transform cubic-bezier(0.15, 0.85, 0.35, 1) 250ms, max-height linear 0ms 250ms;
}
.b_fadeAnim {
  -webkit-animation: fadeAnim linear 330ms;
  -moz-animation: fadeAnim linear 330ms;
  -o-animation: fadeAnim linear 330ms;
  animation: fadeAnim linear 330ms;
}
/* slide up a list of items from below the viewport into the canvas. Starting translations will be set in Animation.ts.
   Items will arrive one by one, starting from the top. */

.b_slideListHide > li {
  opacity: 0;
}
.b_slideUp.b_slideListHide {
  opacity: 0;
  -webkit-transform: translateY(200px);
  -moz-transform: translateY(200px);
  -o-transform: translateY(200px);
  transform: translateY(200px);
}
.b_slideUp:not(.b_slideListHide),
.b_slideListUp:not(.b_slideListHide) {
  opacity: 1;
  -webkit-transform: translateY(0);
  -moz-transform: translateY(0);
  -o-transform: translateY(0);
  -ms-transform: translateY(0);
  transform: translateY(0);
  -webkit-transition: -webkit-transform cubic-bezier(0.15, 0.85, 0.35, 1) 400ms, opacity linear 250ms;
  -moz-transition: -moz-transform cubic-bezier(0.15, 0.85, 0.35, 1) 400ms, opacity linear 250ms;
  -o-transition: -o-transform cubic-bezier(0.15, 0.85, 0.35, 1) 400ms, opacity linear 250ms;
  transition: transform cubic-bezier(0.15, 0.85, 0.35, 1) 400ms, opacity linear 250ms;
}
/* Keyframes animation */

@keyframes fadeAnim {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
@-webkit-keyframes fadeAnim {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
@-moz-keyframes fadeAnim {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
@-o-keyframes fadeAnim {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
#b_results a.recourseLink {
  color: #666666;
  padding-top/* bingcss-ignore: border with side padding needs to be applied above the recourse link */: 12px;
  border-top: 1px solid #c4c4c4;
  display: block;
}
#b_content:not(.peekExpand) #b_results > .b_msg {
  border: 0;
  padding-top/* bingcss-ignore */: 0;
}
/* Square - Small Icon 16 x 16 */

.square_si {
  width: 16px;
  height: 16px;
  font-size: 16px;
  line-height: 16px;
}
/* End Square - Small Icon*/

</style><script type="text/javascript">//<![CDATA[
///<reference path="..\Declarations\Shared.d.ts" />
var BMPage;
(function (BMPage) {
    var PeekExpandInst;
    (function (PeekExpandInst) {
        function InstrumentPeekExpand(args) {
            var isPeekExpandInline = false;
            if (args && args.length > 1 && args[1] === true) {
                isPeekExpandInline = true;
            }
            var instUrl = "/fd/ls/l?IG=" + _G.IG + '&Type=Event.ClientInst&TS=' + Date.now() + '&DATA={"T":"CI.Cortana.ViewPort","SRC":"OpenPane"' + (isPeekExpandInline ? ',"DVP":' + _w.pageYOffset : '') + ',"VP":' + '"' + _w.innerWidth + "," + _w.innerHeight + '"}';
            var instLayout = new Image();
            instLayout.src = instUrl;
        }
        // wire to PeekExpand for both reactive and pro-active
        sj_evt.bind('peekexpand', InstrumentPeekExpand);
    })(PeekExpandInst || (PeekExpandInst = {}));
})(BMPage || (BMPage = {}));
;///<reference path="..\Declarations\Shared.d.ts" />
///<reference path="..\Declarations\CssClass.d.ts" />
var Animation;
(function (Animation) {
    var toggleClass = "b_hide";
    // this list need to be kept in sync so that all animations are cleared in toggleHide
    var animClasses = ["b_slideListUp", "b_slide", "b_fade", "b_fadeUp"];
    var elementLogMap = {};
    var curElementKey = 0;
    // these variables keep track of vendor-prefixed css/events
    var transitionEndEvent = "transitionend";
    var transformCss = "transform";
    var vendorEndEvents = {
        o: "oTransitionEnd",
        moz: "transitionend",
        webkit: "webkitTransitionEnd"
    };
    function IsElementHidden(ele) {
        return Lib.CssClass.contains(ele, "b_hide") || getComputedStyle(ele, null).display === "none";
    }
    function setVendorTransitionPrefix() {
        if ("transition" in _d.documentElement.style) {
            return;
        }
        for (var prefix in vendorEndEvents) {
            var cssPrefix = "-" + prefix + "-";
            if (cssPrefix + "transition" in _d.documentElement.style) {
                transitionEndEvent = vendorEndEvents[prefix];
            }
        }
    }
    function setVendorCssPrefix() {
        if ("transform" in _d.documentElement.style) {
            return;
        }
        for (var prefix in vendorEndEvents) {
            var prefixedCss = "-" + prefix + "-" + "transform";
            if (prefixedCss in _d.documentElement.style) {
                transformCss = prefixedCss;
            }
        }
    }
    function setVendorPrefix() {
        setVendorTransitionPrefix();
        setVendorCssPrefix();
    }
    function updateLogEnd(htmlElement) {
        if (htmlElement["AnimationKey"]) {
            var logData = elementLogMap[htmlElement["AnimationKey"]];
            logData.endTime = Date.now();
            if (_w["Log2"]) {
                Log2.LogEvent("ClientInst", { "T": "AnimationTiming", "startTime": logData.startTime, "endTime": logData.endTime, "AnimationName": logData.animationName }, null, null, null, null, null, null);
            }
        }
    }
    function updateLogStart(htmlElement, animation) {
        curElementKey += 1;
        htmlElement["AnimationKey"] = curElementKey;
        elementLogMap[curElementKey] = { startTime: Date.now(), endTime: -1, animationName: animation };
    }
    function cascadeListOld(list) {
        if (!list || !list.children || list.children.length == 0) {
            return;
        }
        var startingOffset = _w.innerHeight;
        list.style[transformCss] = "translateY(" + startingOffset + "px)";
        toggleAnimClass(list, "b_slideListUp");
        Lib.CssClass.remove(list, "b_slideListHide");
        list.style[transformCss] = "";
        var lastAnimatedItem = list.children[list.children.length - 1];
        if (lastAnimatedItem) {
            sj_be(lastAnimatedItem, transitionEndEvent, function (evt) {
                if (evt.target === lastAnimatedItem && evt.propertyName === transformCss) {
                    updateLogEnd(list);
                    for (var i = 0; i < list.children.length; i++) {
                        var item = list.children[i];
                        item.style[transformCss] = "";
                    }
                }
            });
            updateLogStart(list, "cascadeListOld");
        }
    }
    Animation.cascadeListOld = cascadeListOld;
    function cascadeList(list) {
        if (!list || !list.children || list.children.length == 0) {
            return;
        }
        var startingOffset = 200;
        list.style[transformCss] = "translateY(" + startingOffset + "px)";
        toggleAnimClass(list, "b_slideListUp");
        Lib.CssClass.remove(list, "b_slideListHide");
        /*
        * This works because when calling list.style the browser will recalculate all styles
        * and the previous change will occur, before we override the value with ""
        */
        list.style[transformCss] = "";
    }
    Animation.cascadeList = cascadeList;
    function toggleSlideTranslate(ele) {
        if (ele) {
            toggleAnimation(ele, "b_slideTranslate", false, [transformCss, transformCss]);
        }
    }
    Animation.toggleSlideTranslate = toggleSlideTranslate;
    function toggleSlide(ele) {
        if (ele) {
            toggleAnimation(ele, "b_slide", true, ["height", "height"]);
        }
    }
    Animation.toggleSlide = toggleSlide;
    function toggleFade(ele) {
        if (ele) {
            toggleAnimation(ele, "b_fade", false, ["opacity", "opacity"]);
        }
    }
    Animation.toggleFade = toggleFade;
    function toggleFadeUp(ele) {
        if (ele) {
            toggleAnimation(ele, "b_fadeUp", false, [transformCss, transformCss]);
        }
    }
    Animation.toggleFadeUp = toggleFadeUp;
    function toggleHide(ele) {
        if (ele) {
            for (var i = 0; i < animClasses.length; i++) {
                Lib.CssClass.remove(ele, animClasses[i]);
            }
            toggleAnimClass(ele, toggleClass);
            sj_evt.fire("transitionDone", ele);
            // instant animation.  Log both events one after the other
            updateLogStart(ele, "Hide");
            updateLogEnd(ele);
        }
    }
    Animation.toggleHide = toggleHide;
    function forceUpdateStyle(ele) {
        // Due to browser optimization of style update, multiple style changes may go at the same time instead of sequentially.  
        // To force update of styles before applying the animation class, a layout property is accessed, which forces the browser
        // to update the style and layouts.
        var tmp = ele.offsetTop;
    }
    function toggleAnimClass(ele, anim) {
        forceUpdateStyle(ele);
        Lib.CssClass.toggle(ele, anim);
    }
    // to animate on the height of an element, the height needs to be explicitly set on the element.
    function setHeight(ele) {
        var height = ele.clientHeight;
        if (height == 0 && Lib.CssClass.contains(ele, toggleClass)) {
            Lib.CssClass.remove(ele, toggleClass);
            height = ele.clientHeight;
            Lib.CssClass.add(ele, toggleClass);
        }
        if (height > 0) {
            ele.style.height = height + "px";
        }
    }
    function transitionEndHandler(evt, ele, lastProperty, anim) {
        if (evt.target != ele) {
            return;
        }
        // send an event to signal that the ele has finished all transitions
        var prop = Lib.CssClass.contains(ele, "b_hide") ? lastProperty[1] : lastProperty[0];
        if (evt.propertyName === prop) {
            updateLogEnd(ele);
            Lib.CssClass.remove(ele, anim);
            if (evt.propertyName === "height") {
                // upon height finishes animating, it should be cleared out.
                ele.style.removeProperty('height');
            }
            sj_ue(ele, transitionEndEvent, transitionEndHandler);
            sj_evt.fire("transitionDone", ele);
        }
    }
    function toggleAnimation(ele, anim, animateHeight, lastProperty) {
        if (animateHeight) {
            setHeight(ele);
        }
        toggleAnimClass(ele, anim);
        toggleAnimClass(ele, toggleClass);
        sj_be(ele, transitionEndEvent, function (evt) {
            transitionEndHandler(evt, ele, lastProperty, anim);
        });
        // log start of animation
        updateLogStart(ele, anim);
    }
    setVendorPrefix();
})(Animation || (Animation = {}));
;
//]]></script><script type="text/javascript">//<![CDATA[
///<reference path="..\..\..\..\Shared\Content\Content\Script\Declarations\Shared.d.ts" />
///<reference path="..\..\..\..\Threshold\src\Content\Script\Declarations\SearchAppWrapper.d.ts" />
var CUDialog;
(function (CUDialog) {
    function sendAction(response) {
        SearchAppWrapper.CortanaApp.sendAction(response.CuAction);
    }
    CUDialog.sendAction = sendAction;
})(CUDialog || (CUDialog = {}));
;
//]]></script><div id="b_content" class="peekExpand"><div id="b_pole"><div class="b_poleContent"><div class="b_ans b_cat3a"><div class="b_hide" id="CUDialogResponse">{"Uri":"action://CuOutput","SystemAction":{"Reminder":{"Condition":"None","Title":{"Value":"记住我的车停在楼下","ProfanityMasked":"记住我的车停在楼下","Uri":"entity://TextData","Version":"2.0"},"Uri":"entity://Reminder","Version":"2.0"},"Uri":"action://Reminder/Create","Version":"2.0"},"ConversationId":"9ff16d5b-4ccc-9b84-c9e5-75cfe69e8aaf","TraceId":"04D81438156E457FB07546DC975522CE","ImpressionId":"c6310a13bb7957fbc90e66b4e705fd78","LgObject":{"Uri":"action://LgObject","Ssml":null,"DisplayText":null,"SuggestionText":null,"SecondaryDisplayTextSmall":null,"SecondaryDisplayTextMedium":null,"SecondaryDisplayTextLarge":null}}</div></div></div></div><ol id="b_results" role="main" aria-label="Search Results" class="peekExpand peek"><li class="b_algo" data-bm="5"><h2><a href="http://www.110.com/ask/question-7235473.html" h="ID=SERP,5138.1">我的电动<strong>车停在楼下</strong>被派出所的人骑走了我去拿非要让我给购 ...</a></h2><div class="b_caption"><p><strong>记住我</strong> [免费注册] [忘记密码] 发布法律咨询 回复法律咨询 加入收藏 全国站 [进入分站] 请您选择相应地区 ... 我的电动<strong>车停在楼下</strong> 被派出所的人骑走了我去拿非要 ...</p><div class="b_attribution" u="0|5030|5004110902527318|tH4KMyW2FcDjmye0weBmRqkM2wouaITL"><cite>www.110.com</cite><span class="c_tlbxTrg"><span class="c_tlbxH" h="BASE:CACHEDPAGEDEFAULT" k="SERP,5139.1"></span></span></div></div></li><li class="b_algo" data-bm="6"><h2><a href="http://www.110.com/ask/question-7340062.html" h="ID=SERP,5150.1">我买的是二手<strong>车停在楼下</strong>不见了，通过查找发现让租赁公司 ...</a></h2><div class="b_caption"><p><strong>记住我</strong> [免费注册] [忘记密码] 发布法律咨询 回复法律咨询 加入收藏 全国站 [进入分站] 请您选择相应地区 ... 我买的是二手<strong>车停在楼下</strong> 不见了，通过查找发现让 ...</p><div class="b_attribution" u="1|5031|4539425535166259|x1nlljDpTG0QSrVnqffZcaT-uBm4EOKO"><cite>www.110.com</cite><span class="c_tlbxTrg"><span class="c_tlbxH" h="BASE:CACHEDPAGEDEFAULT" k="SERP,5151.1"></span></span></div></div></li><li class="b_ans" data-bm="7"><h2 class=""><a href="http://m.wenda.so.com/q/1391981361065128" h="ID=SERP,5424.1">我<strong>车停在楼下</strong>，昨晚不知道谁把我后挡风玻璃敲碎了 ...-360问答</a></h2><div class="b_caption"><div class="hsPanel"><span><span class=" b_goodBadge">最佳答案</span></span><span>车损险不包括玻璃的，是另外投保的，如果你家是小区的话，可以去找物业赔偿的(是在你家楼下吧?还是?)</span></div> <div class="b_attribution"><cite>wenda.so.com</cite></div></div><ul class="msn_expansionList"><li><div id="target_1" class="targetHeight"><span class="ArrowsIcon"><div class="sml" id="expitem_-615211368_1" data-appns="SERP" data-k="5372.1" data-expl=""><a id="expitem_-615211368_1_hit" class="leftAlign" aria-pressed="true" data-role="button" href="javascript:void(0);" aria-label="展开"><img class="cipa  rms_img" width="12" height="6" src="data:image/png;base64,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" data-bm="18"></a><div class="b_hide"><img class="cipa  rms_img" width="12" height="6" src="data:image/png;base64,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" data-bm="19"></div></div></span><span title=""><img class="cipt  rms_img" width="16" height="16" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAABZ0RVh0Q3JlYXRpb24gVGltZQAwNi8xMy8xNEyuoVwAAAAcdEVYdFNvZnR3YXJlAEFkb2JlIEZpcmV3b3JrcyBDUzbovLKMAAABw0lEQVRYhe2WwSsEYRjGf8tgdi0rxWJvGxcHxYGbHBzkqDZyUnLlP+A/UByc0R5XlGQPipKcESVCSIzWall21y4Osxu1szPzacc4eG7zvu/M8/u+eb76HP6Zjw9sVImd5n8foNcPzbU2ATRVwVw/rAxBm9c6AIdeCHv9KkTqHYaXYP9OrdfI0FILaYH4JtNwdC8IUAiivRFCAfPmAMF9mNrKr0tGL26cwXgYZvugvlKtnUdhZAWe38yZhwIQedXuaQKMtkOnD3auYHEPwqfQswA3T2r/MQHbl+bMjaQZwspydesPlK9azrzY0j2GNzFrTE0D/IYMQ/hdfc1wFy/cd5eBEofjiEUAk93gdevPTO9aCPCShkMFxlbze143LA/CtWBuhABcEkRf9X+DqGwP4T+A7QBCIXxKga8KxrvyezVy9oOCSxIC8MhQ54IJDYCcfNUWAvTMQyKtP+MqEwMQ2jAjc4AXk3eEHwFYIcsBSh36faEMmFVrHXgqIJGBjga1lnn/RQCpBIIDX8/xFKydCADI2apTMNE5HSqwfqreDfZuYfMCYkntWc1reXUFOCV4SMBb5mcQZqW5A7FkYeJiy/Zj+AnHDnzjpzz5XgAAAABJRU5ErkJggg==" data-bm="20">把<strong>车停在</strong>楼下可以吗</span></div><div class="b_hide"><div class="HiddenSection">如果没有划分禁停的话，没有问题的，如果楼上玻璃掉下来砸到你车了，他当然负责； 之前有过新闻，楼上一只晒太阳的乌龟掉下来，把别人楼下车砸啦，全赔的<ul class="b_vList"><li><a href="http://zhidao.baidu.com/question/358248831.html" h="ID=SERP,5369.1">查看详情</a></li></ul></div></div></li><li><div id="target_2" class="targetHeight"><span class="ArrowsIcon"><div class="sml" id="expitem_-615211368_2" data-appns="SERP" data-k="5373.1" data-expl=""><a id="expitem_-615211368_2_hit" class="leftAlign" aria-pressed="true" data-role="button" href="javascript:void(0);" aria-label="展开"><img class="cipa  rms_img" width="12" height="6" src="data:image/png;base64,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" data-bm="21"></a><div class="b_hide"><img class="cipa  rms_img" width="12" height="6" src="data:image/png;base64,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" data-bm="22"></div></div></span><span title=""><img class="cipt  rms_img" width="16" height="16" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAABZ0RVh0Q3JlYXRpb24gVGltZQAwNi8xMy8xNEyuoVwAAAAcdEVYdFNvZnR3YXJlAEFkb2JlIEZpcmV3b3JrcyBDUzbovLKMAAABw0lEQVRYhe2WwSsEYRjGf8tgdi0rxWJvGxcHxYGbHBzkqDZyUnLlP+A/UByc0R5XlGQPipKcESVCSIzWall21y4Osxu1szPzacc4eG7zvu/M8/u+eb76HP6Zjw9sVImd5n8foNcPzbU2ATRVwVw/rAxBm9c6AIdeCHv9KkTqHYaXYP9OrdfI0FILaYH4JtNwdC8IUAiivRFCAfPmAMF9mNrKr0tGL26cwXgYZvugvlKtnUdhZAWe38yZhwIQedXuaQKMtkOnD3auYHEPwqfQswA3T2r/MQHbl+bMjaQZwspydesPlK9azrzY0j2GNzFrTE0D/IYMQ/hdfc1wFy/cd5eBEofjiEUAk93gdevPTO9aCPCShkMFxlbze143LA/CtWBuhABcEkRf9X+DqGwP4T+A7QBCIXxKga8KxrvyezVy9oOCSxIC8MhQ54IJDYCcfNUWAvTMQyKtP+MqEwMQ2jAjc4AXk3eEHwFYIcsBSh36faEMmFVrHXgqIJGBjga1lnn/RQCpBIIDX8/xFKydCADI2apTMNE5HSqwfqreDfZuYfMCYkntWc1reXUFOCV4SMBb5mcQZqW5A7FkYeJiy/Zj+AnHDnzjpzz5XgAAAABJRU5ErkJggg==" data-bm="23">我家<strong>车停</strong>楼下被划，如何报复</span></div><div class="b_hide"><div class="HiddenSection">既然知道是谁干的了 只要有证据 还是通过法律来维护自己吧<ul class="b_vList"><li><a href="http://zhidao.baidu.com/question/184526830.html" h="ID=SERP,5370.1">查看详情</a></li></ul></div></div></li><li><div id="target_3" class="targetHeight"><span class="ArrowsIcon"><div class="sml" id="expitem_-615211368_3" data-appns="SERP" data-k="5374.1" data-expl=""><a id="expitem_-615211368_3_hit" class="leftAlign" aria-pressed="true" data-role="button" href="javascript:void(0);" aria-label="展开"><img class="cipa  rms_img" width="12" height="6" src="data:image/png;base64,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" data-bm="24"></a><div class="b_hide"><img class="cipa  rms_img" width="12" height="6" src="data:image/png;base64,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" data-bm="25"></div></div></span><span title=""><img class="cipt  rms_img" width="16" height="16" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAABZ0RVh0Q3JlYXRpb24gVGltZQAwNi8xMy8xNEyuoVwAAAAcdEVYdFNvZnR3YXJlAEFkb2JlIEZpcmV3b3JrcyBDUzbovLKMAAABw0lEQVRYhe2WwSsEYRjGf8tgdi0rxWJvGxcHxYGbHBzkqDZyUnLlP+A/UByc0R5XlGQPipKcESVCSIzWall21y4Osxu1szPzacc4eG7zvu/M8/u+eb76HP6Zjw9sVImd5n8foNcPzbU2ATRVwVw/rAxBm9c6AIdeCHv9KkTqHYaXYP9OrdfI0FILaYH4JtNwdC8IUAiivRFCAfPmAMF9mNrKr0tGL26cwXgYZvugvlKtnUdhZAWe38yZhwIQedXuaQKMtkOnD3auYHEPwqfQswA3T2r/MQHbl+bMjaQZwspydesPlK9azrzY0j2GNzFrTE0D/IYMQ/hdfc1wFy/cd5eBEofjiEUAk93gdevPTO9aCPCShkMFxlbze143LA/CtWBuhABcEkRf9X+DqGwP4T+A7QBCIXxKga8KxrvyezVy9oOCSxIC8MhQ54IJDYCcfNUWAvTMQyKtP+MqEwMQ2jAjc4AXk3eEHwFYIcsBSh36faEMmFVrHXgqIJGBjga1lnn/RQCpBIIDX8/xFKydCADI2apTMNE5HSqwfqreDfZuYfMCYkntWc1reXUFOCV4SMBb5mcQZqW5A7FkYeJiy/Zj+AnHDnzjpzz5XgAAAABJRU5ErkJggg==" data-bm="26">我<strong><strong>车停在</strong>楼下</strong>，马路边上，被交警拖走了，怎么处理?_360问答</span></div><div class="b_hide"><div class="HiddenSection">去交警大队办理手续..明天最少准备220元..200罚款.20停车费..<ul class="b_vList"><li><a href="http://m.wenda.so.com/q/1391589343060688" h="ID=SERP,5371.1">查看详情</a></li></ul></div></div></li></ul></li><li class="b_algo" data-bm="8"><h2><a href="http://zhidao.so.com/q/1418950151703625" h="ID=SERP,5258.1"><strong>车停在楼下</strong>对方把我刮蹭了我怎么处理_360问答</a></h2><div class="b_caption"><p><strong>车停在楼下</strong>对方把我刮蹭了我怎么处理 如果对方肯负责就最好，不行就得报警或是找保险了 ... 下面是答答童鞋给您的小建议，您看靠谱吗？初来乍到，弄错了您 ...</p><div class="b_attribution" u="6|5033|4900323039185620|mlJsSpZ9iCG0aMbMW6ah8dXwz9bitW9l"><cite>zhidao.so.com</cite><span class="c_tlbxTrg"><span class="c_tlbxH" h="BASE:CACHEDPAGEDEFAULT" k="SERP,5259.1"></span></span></div></div></li><li class="b_algo" data-bm="9"><h2><a href="http://news.cbg.cn/wltx/2016/0425/3307485.shtml" h="ID=SERP,5271.1"><strong>车停楼下</strong>添“新伤” 记录仪内找“元凶”</a></h2><div class="b_caption"><p><strong>记住我</strong> 退出 新闻 原创 在线630 看点扫描 直播现场 电视 微视频 家在重庆 汇剧天下 ... 名称： <strong>车停楼下</strong>添“新伤” 记录仪内找“元凶” 发布： 2016-04-25 12:57 时长 ...</p><div class="b_attribution" u="7|5036|4546516525123633|b4WcjztNcQEThBWCxyBLfWCXl1cSwQNd"><cite>news.cbg.cn</cite><span class="c_tlbxTrg"><span class="c_tlbxH" h="BASE:CACHEDPAGEDEFAULT" k="SERP,5272.1"></span></span></div></div></li><li class="b_algo" data-bm="10"><h2><a href="http://mycd.qq.com/t-1256650-1.htm" h="ID=SERP,5286.1"><strong>停在楼下的车子</strong>被倒下去的电瓶车刮伤了，电瓶车 ...- 大成社区</a></h2><div class="b_caption"><p>骑电瓶车的可能没的停稳就走了，我下去的时候那电瓶车刚好一下就倒下来了。刮了<strong>我的车</strong>。好 ...,<strong>停在楼下的车子</strong>被倒下去的电瓶车刮伤了，电瓶车有没有责任？</p><div class="b_attribution" u="8|5037|5042963134616028|KmNTKljWk6D1RixmCcEvysHH6Ab07DNj"><cite>mycd.qq.com</cite><span class="c_tlbxTrg"><span class="c_tlbxH" h="BASE:CACHEDPAGEDEFAULT" k="SERP,5287.1"></span></span></div></div></li><li class="b_algo" data-bm="11"><h2><a href="http://wenda.pchouse.com.cn/q/3026731.html" h="ID=SERP,5300.1">我<strong>车停在楼下</strong>,楼上不知哪家磁砖掉下砸了<strong>车子</strong>该 ...-家居问答</a></h2><div class="b_caption"><p><span class="mb_ok_tag">手机版</span>我<strong>车停在楼下</strong>, 楼上不知哪家磁砖掉下砸了<strong>车子</strong>该怎么办，谢谢大家为我解答。 找回密码 ... <strong>记住</strong> 登录状态 忘记密码？ 初次来到快问？立即注册 登录到快问 用户 ...</p><div class="b_attribution" u="9|5038|4929670535319760|wXBVzYqQrqnBwW3h1gS9tOHG10LknqPH"><cite>wenda.pchouse.com.cn</cite><span class="c_tlbxTrg"><span class="c_tlbxH" h="BASE:CACHEDPAGEDEFAULT" k="SERP,5301.1"></span></span></div></div></li><li class="b_algo" data-bm="12"><h2><a href="http://m.findlaw.cn/ask/question_35880745.html" h="ID=SERP,5314.1">我在**小区内住，<strong>我的车在楼下</strong>夜间停着，被他人古意划了 ...</a></h2><div class="b_caption"><p>我在**小区内住，<strong>我的车在楼下</strong>夜间停着，被他人古意划了，被监控拍下，请问他蒋受到怎样法律制宰。 待解决</p><div class="b_attribution" u="10|5039|714505402577|m7cxSNkBI_ZR0IuEKBSRujGeFfXbxx8I"><cite>china.findlaw.cn</cite><span class="c_tlbxTrg"><span class="c_tlbxH" h="BASE:CACHEDPAGEDEFAULT" k="SERP,5315.1"></span></span></div></div></li><li class="b_algo" data-bm="13"><h2><a href="http://jialonghuayuan.fang.com/bbs/1210039536~-1~2604/19340440_19340440.htm" h="ID=SERP,5326.1">我家的<strong>车停在楼下</strong>，车衣在一天之内不见了，大家觉得是会是 ...</a></h2><div class="b_caption"><p>搜房网 &gt; 佳龙花园小区网 &gt; 佳龙花园业主论坛 &gt; 我家的<strong>车停在楼下</strong>，车衣在一天之内不见了，大家觉得是会是谁拿去了呀？</p><div class="b_attribution" u="11|5230|4503815987539757|0J11oS0e-uoAGXqzE21Rg1pW1ntoqhgu"><cite>jialonghuayuan.fang.com</cite><span class="c_tlbxTrg"><span class="c_tlbxH" h="BASE:CACHEDPAGEDEFAULT" k="SERP,5327.1"></span></span></div></div></li><li class="b_algo" data-bm="14"><h2><a href="http://bbs.8080.net/thread-124490-1-1.html" h="ID=SERP,5340.1"><strong>车子停楼下</strong>被人擦了，也知道是谁干的，怎么报复 ...- 极速社区</a></h2><div class="b_caption"><p>... ....他昨天中午擦过以后，晚上直接把<strong>车子</strong>丢外面补漆，今天晚上才开回来，联想到我 ... <strong>车子停楼下</strong>被人擦了，也知道是谁干的，怎么报复 , ...</p><div class="b_attribution" u="12|5231|4651021642370288|F6jaOcc0CbFDClCm_duKkPzJQQSwRqgk"><cite>bbs.8080.net</cite><span class="c_tlbxTrg"><span class="c_tlbxH" h="BASE:CACHEDPAGEDEFAULT" k="SERP,5341.1"></span></span></div></div></li><li class="b_ans" data-bm="15"><div class="b_rs"><h2 class="">相关搜索</h2><div class="b_rich"><div class="b_vlist2col"><ul><li><a href="/search?q=%e8%ae%b0%e4%bd%8f%e6%88%91%e7%9a%84%e8%bd%a6%e5%9c%a8%e5%93%aa%e9%87%8c&amp;FORM=QSRE1" h="ID=SERP,5391.1"><strong>记住我的车在</strong>哪里</a></li><li><a href="/search?q=%e6%88%91%e5%9c%a8%e4%bd%a0%e5%ae%b6%e7%9a%84%e6%a5%bc%e4%b8%8b&amp;FORM=QSRE2" h="ID=SERP,5392.1"><strong>我在</strong>你家<strong>的楼下</strong></a></li><li><a href="/search?q=%e4%bd%a0%e5%b0%b1%e5%9c%a8%e6%88%91%e5%ae%b6%e7%9a%84%e6%a5%bc%e4%b8%8b&amp;FORM=QSRE3" h="ID=SERP,5393.1">你就<strong>在我</strong>家<strong>的楼下</strong></a></li></ul><ul><li><a href="/search?q=%e6%88%91%e7%9a%84%e8%bd%a6%e5%81%9c%e5%9c%a8%e5%93%aa%e9%87%8c%e9%82%a3&amp;FORM=QSRE4" h="ID=SERP,5394.1"><strong>我的车停在</strong>哪里那</a></li><li><a href="/search?q=%e8%ae%b0%e4%bd%8f%e6%88%91%e7%9a%84%e8%bd%a6%e5%81%9c%e5%9c%a8b21&amp;FORM=QSRE5" h="ID=SERP,5395.1"><strong>记住我的车停在</strong>b21</a></li><li><a href="/search?q=%e6%88%91%e7%9a%84%e8%bd%a6%e5%81%9c%e5%9c%a8%e5%93%aa%e9%87%8c&amp;FORM=QSRE6" h="ID=SERP,5396.1"><strong>我的车停在</strong>哪里</a></li></ul></div></div></div></li><li class="b_msg b_hide" data-bm="16"><a href="javascript:sj_evt.fire('peekactivate', true);" class="recourseLink" h="ID=SERP,5411.1"><span title=""><span class="b_symb b_cortanaMDL2  cipt vatb square_mi"></span><span>在必应中查看更多结果</span></span></a></li><li class="b_pag" data-bm="17"><ul class="sb_pag"><li><a class="sb_pagS">1</a></li><li><a href="/search?cc=cn&amp;setlang=zh-cn&amp;mkt=zh-cn&amp;uncrunched=1&amp;remindercox&amp;q=%e8%ae%b0%e4%bd%8f%e6%88%91%e7%9a%84%e8%bd%a6%e5%81%9c%e5%9c%a8%e6%a5%bc%e4%b8%8b%e3%80%82&amp;first=11&amp;FORM=PERE" h="ID=SERP,5401.1">2</a></li><li><a href="/search?cc=cn&amp;setlang=zh-cn&amp;mkt=zh-cn&amp;uncrunched=1&amp;remindercox&amp;q=%e8%ae%b0%e4%bd%8f%e6%88%91%e7%9a%84%e8%bd%a6%e5%81%9c%e5%9c%a8%e6%a5%bc%e4%b8%8b%e3%80%82&amp;first=21&amp;FORM=PERE1" h="ID=SERP,5402.1">3</a></li><li><a href="/search?cc=cn&amp;setlang=zh-cn&amp;mkt=zh-cn&amp;uncrunched=1&amp;remindercox&amp;q=%e8%ae%b0%e4%bd%8f%e6%88%91%e7%9a%84%e8%bd%a6%e5%81%9c%e5%9c%a8%e6%a5%bc%e4%b8%8b%e3%80%82&amp;first=11&amp;FORM=PORE" class="sb_pagN" h="ID=SERP,5403.1"><div class="sb_pagIconN"><span class="sw_next" title="下一页"><span class="b_symb b_cortanaMDL2  cipg  square_si"></span></span></div></a></li></ul></li></ol></div><footer class="b_footer peek" role="contentinfo"><div id="CntFtr"><p id="fti3">© 2016 Microsoft</p><ul id="ftrLnks"><div class="clrall"></div></ul></div></footer><script type="text/javascript">//<![CDATA[
(function (_onload, si_PP) {
    onload = function () {
        _G.BPT = new Date();
        if (_onload) {
            _onload();
        }
        if (!_w.sb_ppCPL && si_PP) {
            sb_st(function () {
                si_PP(new Date);
            }, 0);
        }
    };
})(_w.onload, _w.si_PP);
;///<reference path="queue.ts"/>
BM.trigger();
;///<reference path="..\..\..\..\..\Answers\services\Shared\Content\Content\Script\Declarations\Shared.d.ts" />
var Lib;
(function (Lib) {
    var CssClass;
    (function (CssClass) {
        var supportsClassList = typeof (document.body.classList) !== 'undefined';
        function indexOf(elems, elem) {
            if (elems.indexOf) {
                return elems.indexOf(elem);
            }
            var length = elems.length;
            for (var i = 0; i < length; i++) {
                if (elems[i] === elem) {
                    return i;
                }
            }
            return -1;
        }
        function add(elem, className) {
            if (contains(elem, className)) {
                return;
            }
            if (supportsClassList) {
                elem.classList.add(className);
            }
            else {
                elem.className += ' ' + className;
            }
        }
        CssClass.add = add;
        function remove(elem, className) {
            if (!contains(elem, className)) {
                return;
            }
            if (supportsClassList) {
                elem.classList.remove(className);
            }
            else {
                var classList = elem.className.split(' ');
                var classId = indexOf(classList, className);
                if (classId >= 0) {
                    classList.splice(classId, 1);
                }
                elem.className = classList.join(' ');
            }
        }
        CssClass.remove = remove;
        function toggle(elem, className) {
            if (supportsClassList) {
                elem.classList.toggle(className);
            }
            else {
                if (contains(elem, className)) {
                    remove(elem, className);
                }
                else {
                    add(elem, className);
                }
            }
        }
        CssClass.toggle = toggle;
        function contains(elem, className) {
            if (supportsClassList) {
                return elem.classList.contains(className);
            }
            else {
                var classList = elem.className.split(' ');
                return indexOf(classList, className) >= 0;
            }
        }
        CssClass.contains = contains;
    })(CssClass = Lib.CssClass || (Lib.CssClass = {}));
})(Lib || (Lib = {}));
;_w.rms.js({'A:0':0},{'A:rms:answers:BoxModel:Framework':'\/rms\/Framework\/nj\/92342395\/b2d8ec0a.js?bu=rms+answers+BoxModel+config.threshold%2ccore%2ccore%24viewport%2ccore%24layout%2ccore%24metrics%2cmodules%24mutation%2cmodules%24error%2cmodules%24network%2cmodules%24cursor%2cmodules%24keyboard%2cmodules%24bot'});;
//]]></script><div id="aRmsDefer"><div style="display:none"><!--//<![CDATA[
/// <reference path="../../../../Shared/Content/Content/script/Declarations/Shared.d.ts"/>
/// <reference path="../../../../Shared/Content/Content/script/Declarations/Threshold.Utilities.d.ts"/>
(function () {
    var kValueExtractionRegex = /ID=(\w+),(\d+(?:\.\d+)*)(&PR=(.*))?/i;
    function sendRequest(linkInfo, el, evt, typeOfClick) {
        if (linkInfo) {
            var gpingData = getGPingData(linkInfo, typeOfClick);
            var clickConfig = _w["ClickConfig"] || {};
            if (_w["Log2"]) {
                Log2.LogEvent(gpingData.eventType, gpingData.data, null, null, null, null, null, null);
                if (_w["ThresholdUtilities"]) {
                    var utilities = _w["ThresholdUtilities"];
                    utilities.uploadApiTimes("PCE");
                }
                if (clickConfig.ForceFlushOnClick || ((typeOfClick === 0) && clickLeavesPage())) {
                    // if we are leaving the page with this click we will flush all relevant logs
                    sj_evt.fire("visibility", document["hidden"]);
                    if (clickConfig.FlushSkipAbort) {
                        Log2.FlushMainQueueDontForce();
                    }
                    else {
                        Log2.ForceFlush();
                    }
                    _w["clickFlushedTime"] = sb_gt();
                }
            }
        }
    }
    _w["si_T"] = sendRequest;
    function clickLeavesPage() {
        if (_w.event && _w.event.srcElement) {
            var linkToCheck = _w.event.srcElement;
            while (!linkToCheck.href) {
                if (linkToCheck.parentElement) {
                    linkToCheck = linkToCheck.parentElement;
                }
                else {
                    // we have no further up to go, this means the user didn't click on a link
                    return false;
                }
            }
            if (linkToCheck.href.split("#")[0] !== _d.URL.split("#")[0]) {
                return true;
            }
        }
        return false;
    }
    function getGPingData(linkInfo, typeOfClick) {
        var matches = linkInfo.match(kValueExtractionRegex);
        if (matches) {
            var gpingData = {
                eventType: "Click",
                data: {
                    AppNS: matches[1],
                    K: matches[2],
                    Case: typeOfClick
                }
            };
            if (matches[4]) {
                gpingData.data.Properties = JSON.parse(matches[4]);
            }
            return gpingData;
        }
        throw new Error("hValue passed to click tracking was unable to be parsed: " + linkInfo);
    }
})();
;///<amd-module name="onHTML" />
define("onHTML", ["require", "exports", "event.custom"], function (require, exports, customEvents) {
    customEvents.fire("onHTML");
});
;///<reference path="Declarations\Shared.d.ts"/>
// Prevent zooming via ctrl + mousewheel
sj_be(_d, "mousewheel", function (evt) {
    if (evt.ctrlKey == true) {
        sj_pd(evt);
    }
});
// Prevent zooming via ctrl +/-
sj_be(_d, "keydown", function (evt) {
    if (evt.ctrlKey == true && (evt.keyCode == 107 || evt.keyCode == 109 || evt.keyCode == 187 || evt.keyCode == 189)) {
        sj_pd(evt);
    }
});
;///<reference path="Declarations\Shared.d.ts" />
/*
Instrumentation library for server and client powered apps in Windows smartsearch
Per this design, Server sets the visibility to false (v=0) on all the app links and client sends the Merge update through MergeInstruction format
setting v=1 on link being shown and also sends the Datasource merge event setting correct installstate of the app.
*/
var AppInst;
(function (AppInst) {
    var kValueExtractionRegex = /ID=([\w]+),([\d]+\.[\d]+)/i;
    var kValueNew = 1;
    AppInst.layoutJson = [];
    AppInst.datasourceJson = [];
    (function (InstallState) {
        InstallState[InstallState["Installed"] = 0] = "Installed";
        InstallState[InstallState["NotInstalled"] = 1] = "NotInstalled";
    })(AppInst.InstallState || (AppInst.InstallState = {}));
    var InstallState = AppInst.InstallState;
    // queues for submission or submits the instrumentation log for server powered apps in smartsearch
    function queueServerAppLog(hVisibleLayout, appInfoDsKValue, installState, hideIfNotInstalled, canSubmit) {
        if (canSubmit === void 0) { canSubmit = true; }
        var namespace = "";
        if (hVisibleLayout) {
            var matches = hVisibleLayout.match(kValueExtractionRegex);
            if (matches && matches.length >= 3) {
                // Store the namespace and K value.
                namespace = matches[1];
                var kValue = matches[2];
                if (installState !== 1 /* NotInstalled */ || !hideIfNotInstalled) {
                    AppInst.layoutJson.push({
                        "T": "L.MI",
                        "Action": "Update",
                        "AppNS": namespace,
                        "K": kValue,
                        "V": "1"
                    });
                }
            }
        }
        if (appInfoDsKValue) {
            AppInst.datasourceJson.push({
                "T": "D.MI",
                "Action": "Update",
                "AppNS": namespace,
                "K": appInfoDsKValue,
                "InstallState": getInstallStateString(installState)
            });
        }
        if (canSubmit) {
            submitLog();
        }
    }
    AppInst.queueServerAppLog = queueServerAppLog;
    function getInstallStateString(installState) {
        switch (installState) {
            case 0 /* Installed */:
                return "Installed";
            case 1 /* NotInstalled */:
                return "NotInstalled";
            default:
                return "Unknown";
        }
    }
    function getUniqueId() {
        return kValueNew++;
    }
    AppInst.getUniqueId = getUniqueId;
    // submits the instrumentation log in Merge instruction (MI) format.
    function submitLog() {
        var data = [];
        if (AppInst.layoutJson.length > 0) {
            data.push({
                "Page": AppInst.layoutJson
            });
            AppInst.layoutJson = [];
        }
        if (AppInst.datasourceJson.length > 0) {
            data.push(AppInst.datasourceJson);
            AppInst.datasourceJson = [];
        }
        if (data.length > 0) {
            postLog(JSON.stringify(data));
        }
    }
    AppInst.submitLog = submitLog;
    function postLog(data) {
        if (data) {
            if (_w["Log2"]) {
                Log2.LogEvent("ClientInst", JSON.parse(data), null, null, null, null, null, null);
            }
            else {
                // If ClientInstV2 is not supported
                var time = sb_gt();
                var payload = "<E><T>Event.ClientInst</T><IG>" + _G.IG + "</IG><TS>" + time + "</TS><D>" + data + "</D></E>";
                var xml = "<ClientInstRequest><Events>" + payload + "</Events><STS>" + time + "</STS></ClientInstRequest>";
                var request = sj_gx();
                request.open("POST", "/fd/ls/lsp.aspx", true);
                request.setRequestHeader("Content-Type", "text/xml");
                request.send(xml);
            }
        }
    }
})(AppInst || (AppInst = {}));
;///<reference path="..\Declarations\Shared.d.ts"/>
///<reference path="..\AppInst.ts"/>
// this module is used to initialize the Hose page to have app context sense
var AppApi;
(function (AppApi) {
    // Adds a handler for the specified control name
    function AddControlHandler(controlName, handler) {
        if (!controlHandlers[controlName]) {
            controlHandlers[controlName] = handler;
        }
    }
    AppApi.AddControlHandler = AddControlHandler;
    // The map of handlers for each control type
    var controlHandlers = {};
    // holding a cache of current page apps
    var pageApps = null;
    var instrumentationEnabled = typeof (AppInst) != 'undefined';
    // update app
    function updateApp(app) {
        if (pageApps && app) {
            var elements = pageApps[app.id];
            if (elements) {
                for (var i = 0; i < elements.length; ++i) {
                    updateAppElement(elements[i], app);
                }
            }
        }
    }
    // Invokes the control-specific handler
    function updateAppElement(element, app) {
        var hideIfNotInstalled = Boolean(element.getAttribute("data-hideIfNotInstalled"));
        if (instrumentationEnabled) {
            // Setting canSubmit to 'false' here so that single payload can be submitted later for all the Apps through explicit call to AppInst.SubmitLog function.
            var canSubmit = false;
            var installState = app.installed ? 0 /* Installed */ : 1 /* NotInstalled */;
            AppInst.queueServerAppLog(element.getAttribute("h"), element.getAttribute("data-appInfoDsK"), installState, hideIfNotInstalled, canSubmit);
        }
        var controlName = element.getAttribute("data-controlName");
        if (controlName) {
            var handler = controlHandlers[controlName];
            if (handler) {
                var minVersionStr = element.getAttribute("data-minVersion");
                var additionalPropsStr = element.getAttribute("data-additionalProps");
                var installedVersion = app.installedAppVersion ? stringToVersion(app.installedAppVersion) : null;
                var requiredMinVersion = minVersionStr ? stringToVersion(minVersionStr) : null;
                var eventArgs = {
                    appElement: element,
                    appInfo: app,
                    installedVersion: installedVersion,
                    requiredMinVersion: requiredMinVersion,
                    // if the min version is not specified, no update is needed
                    updateRequired: requiredMinVersion && installedVersion ? compareAppVersions(installedVersion, requiredMinVersion) < 0 : false,
                    updateAvailable: app.updateAvailable,
                    hideIfNotInstalled: hideIfNotInstalled,
                    additionalProps: null
                };
                try {
                    eventArgs.additionalProps = additionalPropsStr ? JSON.parse(additionalPropsStr) : null;
                    handler(eventArgs);
                }
                catch (ex) {
                    // Nothing we can do, really...
                    Log.Log("Error", "AppApi", "Handler_" + controlName, false, "Tx", ex.message);
                }
                if (app.installed && hideIfNotInstalled) {
                    // Show previously hidden apps
                    element.classList.remove('b_hide');
                }
            }
        }
    }
    // Reads the app from current page
    function readApps() {
        // We create the list of apps on first call to UpdateApp
        if (pageApps) {
            return;
        }
        pageApps = {};
        var dataAttr = "data-appid";
        // Scrape the DOM to get all the DOM Elements related to apps
        var appLinks = _d.querySelectorAll("[" + dataAttr + "]");
        for (var i = 0; i < appLinks.length; i++) {
            var appLink = appLinks[i];
            if (appLink) {
                // Get the value of data - appid attribute
                var appId = appLink.getAttribute(dataAttr);
                // If the app id is valid, then add it to the collection
                if (appId) {
                    var appElementList = pageApps[appId];
                    if (appElementList) {
                        // add it to the existing collection
                        appElementList.push(appLink);
                    }
                    else {
                        // create a new list to hold apps
                        pageApps[appId] = [appLink];
                    }
                }
            }
        }
    }
    // Make an element a launch link with proper instrumentation
    function setLaunchLink(targetElement, appElement, appId, launchUrl) {
        targetElement.setAttribute("href", launchUrl);
        // This code sets proper instrumentation attribute on the launch link
        // We cannot have two identical apps within the same DOM element, for example in the same pivot. We can have two
        // identical apps on different pivots, e.g. OpenTable on About and Apps, however they will have different K values
        // so we need to select the correct sibling element which contains the launch K value to use.
        var siblingInstElement = querySelector(appElement.parentElement, "[data-launchappid='" + appId + "']");
        if (siblingInstElement) {
            var hAttr = "h";
            // data-inst will only be present behind FD
            var hValue = siblingInstElement.getAttribute(hAttr);
            if (hValue && hValue.length > 0) {
                targetElement.setAttribute(hAttr, hValue);
            }
        }
    }
    AppApi.setLaunchLink = setLaunchLink;
    function instrumentUpgradeLink(appElement) {
        // If upgrade link is instrumented with it's own InstLink and h value, then set that to be the h value of rendered link.
        // This is currently applicable for Windows app links which use separate link for upgrade state.
        var upgradeLinkElement = querySelector(appElement.parentElement, "[data-linkRole='Upgrade']");
        if (upgradeLinkElement) {
            var hUpgradeLink = upgradeLinkElement.getAttribute("h");
            if (hUpgradeLink) {
                appElement.setAttribute("h", hUpgradeLink);
            }
        }
    }
    AppApi.instrumentUpgradeLink = instrumentUpgradeLink;
    // Shell will call this method to update app info with app list
    // This function name and its namespace can't be changed.
    function UpdateAppInfo(apps) {
        if (apps) {
            // This will only read the app element list once, caching it for all subsequent calls
            readApps();
            for (var i = 0; i < apps.length; ++i) {
                updateApp(apps[i]);
            }
        }
        // At this point, we have enqueued the logs for all the app links through AppInst.queueServerAppLog function calls.
        // For perf reasons, we submit them all at once in single payload through the following function call.
        if (instrumentationEnabled) {
            AppInst.submitLog();
        }
    }
    AppApi.UpdateAppInfo = UpdateAppInfo;
    function stringToVersion(versionStr) {
        return versionStr.split('.').map(function (s) { return Number(s); });
    }
    // Version comparison function
    function compareAppVersions(version1, version2) {
        var commonLength = Math.min(version1.length, version2.length);
        for (var i = 0; i < commonLength; i++) {
            var diff = version1[i] - version2[i];
            if (diff != 0) {
                return diff;
            }
        }
        // The longer version number is considered greater
        return version1.length - version2.length;
    }
    function querySelector(element, query) {
        return element.querySelector(query);
    }
})(AppApi || (AppApi = {}));
;// ------------------------------------------------------------------------------
// <copyright file="SmartSearch.Navigation.ts" company="Microsoft Corporation">
//     Copyright (c) Microsoft Corporation. All Rights Reserved.
//     Information Contained Herein is Proprietary and Confidential.
// </copyright>
// ------------------------------------------------------------------------------
///<reference path="..\..\..\..\Shared\Content\Content\script\Declarations\Shared.d.ts"/>
///<reference path="..\..\..\..\Shared\Content\Content\Script\Declarations\Threshold.Utilities.d.ts" />
///<reference path="SearchApp.Mock.ts" />
///<reference path="Declarations\CortanaEnums.d.ts" />
var CachedDeviceItems = {};
var SmartSearch;
(function (SmartSearch) {
    var cortanaApp = SearchAppWrapper.CortanaApp;
    var _supportedPaths = null;
    var baseProtocol = null;
    var baseHostname = null;
    var launchApiAllowedLatency = 100;
    var apiNameAbbreviator = /(^.)|([A-Z])/g;
    function isSupportedPath(path, search) {
        var supportedPathsCollection = getSupportedPaths();
        path = cleanPath(path);
        // Cut off the leading ? in the search parameters
        if (search && search.substring) {
            search = search.substring(1);
        }
        // A path is supported if it's not blocked and there is a supported path for it
        // Check block lists first as they should be shorter
        return (!isPathSatisfied(supportedPathsCollection.Blocked, path, search) && isPathSatisfied(supportedPathsCollection.Supported, path, search));
    }
    SmartSearch.isSupportedPath = isSupportedPath;
    /// Called by test code to reset cached state between tests
    function reset() {
        _supportedPaths = null;
    }
    SmartSearch.reset = reset;
    function cleanPath(path) {
        var cleanPath = path;
        if (cleanPath) {
            var cleanPath = cleanPath.toLowerCase();
            var cutIndex = -1;
            for (var i = 0; i < cleanPath.length && cleanPath[i] === "/"; i++) {
                cutIndex = i;
            }
            if (cutIndex >= 0) {
                cleanPath = cleanPath.substring(cutIndex + 1);
            }
        }
        return cleanPath;
    }
    function getSupportedPaths() {
        if (!_supportedPaths) {
            var thresholdConfig = _TC;
            if (thresholdConfig) {
                var supportedPaths = null;
                var blockedPaths = null;
                if (thresholdConfig.SP) {
                    supportedPaths = parsePathList(thresholdConfig.SP);
                }
                if (thresholdConfig.BP) {
                    blockedPaths = parsePathList(thresholdConfig.BP);
                }
                _supportedPaths = { Supported: supportedPaths, Blocked: blockedPaths };
            }
        }
        return _supportedPaths;
    }
    function isPathSatisfied(supportedPathsMap, path, search) {
        for (var i in supportedPathsMap) {
            if (path.indexOf(i) >= 0) {
                var requiredParameters = supportedPathsMap[i];
                var allParametersPresent = true;
                // Check if this path requires specific querystring parameters
                if (requiredParameters.length > 0) {
                    // If we require some parameters we assume we don't have them until we succeed with parsing
                    allParametersPresent = false;
                    if (search) {
                        var parsedPathParameters = cleanArray(search.split("&"));
                        // If we require some parameters and have parameters in the input path then we assume we've got what we need until we find a parameter is missing
                        allParametersPresent = parsedPathParameters.length >= requiredParameters.length;
                        if (allParametersPresent) {
                            for (var requiredParameterIndex in requiredParameters) {
                                if (parsedPathParameters.indexOf(requiredParameters[requiredParameterIndex]) < 0) {
                                    // We've failed to find a required parameter, so we know this is not a match
                                    allParametersPresent = false;
                                    break;
                                }
                            }
                        }
                    }
                }
                // We found all required parameters or there were no required parameters.  This is a match.
                if (allParametersPresent) {
                    return true;
                }
            }
        }
        return false;
    }
    function parsePathList(supportedPaths) {
        var parsedPaths = {};
        supportedPaths = supportedPaths.toLowerCase();
        var supportedFullPaths = supportedPaths.split(",");
        var defaultRequiredQueryStrings = [];
        for (var supportedFullPathIndex in supportedFullPaths) {
            var pathAndQuery = cleanArray(supportedFullPaths[supportedFullPathIndex].split("?"));
            var requiredQueryStrings = defaultRequiredQueryStrings;
            if (pathAndQuery.length > 1) {
                requiredQueryStrings = cleanArray(pathAndQuery[1].split("&"));
            }
            parsedPaths[cleanPath(pathAndQuery[0])] = requiredQueryStrings;
        }
        return parsedPaths;
    }
    function cleanArray(inputArray) {
        var returnValue = inputArray;
        if (inputArray) {
            var startIndex = 0;
            var foundItemToClean = false;
            for (var i = startIndex; i < inputArray.length; i++) {
                if (!inputArray[i]) {
                    if (!foundItemToClean) {
                        returnValue = [];
                        foundItemToClean = true;
                    }
                    if (i > startIndex) {
                        returnValue.push.apply(returnValue, inputArray.slice(startIndex, i));
                    }
                    startIndex = i + 1;
                }
            }
        }
        return returnValue;
    }
    function signalComplete() {
        sj_evt.fire("NavigationComplete");
    }
    function navigateTo(targetElement, event) {
        var preventDefault = true;
        // Check if target element link is internal or external
        if (targetElement) {
            var searchUtils = ThresholdUtilities;
            var destinationPath = targetElement.pathname;
            var destinationHostname = getHostname(targetElement);
            var destinationProtocol = targetElement.protocol;
            var destinationSearch = targetElement.search;
            var destinationHash = targetElement.hash;
            if (!baseHostname || !baseProtocol) {
                getBaseUrl();
            }
            var destinationLink = targetElement.href;
            // If the link is really a javascript invocation (like "javascript:void(0)"), bail out.
            if (destinationProtocol.toLowerCase() === "javascript:") {
                return;
            }
            if (destinationPath.toLowerCase() === _w.location.pathname.toLowerCase() && destinationSearch.toLowerCase() === _w.location.search.toLowerCase() && destinationHash.toLowerCase() === _w.location.hash.toLowerCase()) {
                SharedLogHelper.LogWarning("SelfNavigate");
            }
            else if (destinationLink) {
                if (!destinationHostname) {
                    destinationHostname = baseHostname; // automatically accquire current domain for relative links
                }
                // Determine if a link is relative.
                // Handle a weird case where the url is ms-windows-store:PDP?PFN=..., no host, and "ms-windows-store:" protocol
                var isRelative = (!destinationProtocol || destinationProtocol.indexOf("http") === 0) && (destinationHostname === baseHostname || destinationHostname === getHostname(location));
                var urlType = getUrlType(destinationPath, destinationSearch, destinationHostname, isRelative);
                var launcher = cortanaApp.launcher;
                switch (urlType) {
                    case 5 /* Search */:
                    case 3 /* Navigation */:
                        if (isRelative) {
                            rebaseLink(targetElement);
                            // Need to refresh after changing the link properties
                            destinationLink = targetElement.href;
                        }
                        if (urlType === 5 /* Search */) {
                            // Force Cat3b (search)
                            var joiningChar = destinationLink.indexOf("?") === -1 ? "?" : "&";
                            destinationLink += joiningChar + "persona=0";
                        }
                        var navigateWebViewFunctionName = "navigateWebViewAsync";
                        var launchWebContentFunctionName = "launchWebContent";
                        var thresholdConfig = _TC;
                        if (thresholdConfig && thresholdConfig.NW && launcher[launchWebContentFunctionName]) {
                            var launchOptions = launcher.createWebContentLaunchOptions();
                            launchOptions.uri = destinationLink;
                            searchUtils.wrapSynchronousApiCall(launcher, launchWebContentFunctionName, createInstrumentationKey(launchWebContentFunctionName), null, launchOptions);
                            signalComplete();
                        }
                        else if (cortanaApp[navigateWebViewFunctionName]) {
                            searchUtils.wrapApiCallWithTimeout(cortanaApp, navigateWebViewFunctionName, createInstrumentationKey(navigateWebViewFunctionName), destinationLink, launchApiAllowedLatency, null, destinationLink).done(signalComplete);
                        }
                        else {
                            // We're in charge of the actual navigation
                            preventDefault = false;
                        }
                        break;
                    case 0 /* App */:
                        var options = null;
                        var appContext = targetElement.getAttribute("data-appcontext");
                        if (appContext) {
                            options = launcher.createAppLaunchOptions();
                            options.appContext = appContext;
                        }
                        var itemId = targetElement.getAttribute("data-appid");
                        if (itemId) {
                            var itemSource = targetElement.getAttribute("data-source");
                            var deviceItem = CachedDeviceItems[itemId + ":" + itemSource];
                            if (deviceItem) {
                                var launchSearchItemAsyncPromise;
                                var functionName = "launchSearchItemAsync";
                                if (options) {
                                    launchSearchItemAsyncPromise = searchUtils.wrapApiCallWithTimeout(launcher, functionName, createInstrumentationKey(functionName), deviceItem.id, launchApiAllowedLatency, null, deviceItem, options);
                                }
                                else {
                                    launchSearchItemAsyncPromise = searchUtils.wrapApiCallWithTimeout(launcher, functionName, createInstrumentationKey(functionName), deviceItem.id, launchApiAllowedLatency, null, deviceItem);
                                }
                                launchSearchItemAsyncPromise.done(signalComplete);
                            }
                            else {
                                var itemType = targetElement.getAttribute("data-itemtype");
                                var functionName = itemType && itemType === "settings" ? "findSettingsAsync" : "findAppsAsync";
                                searchUtils.wrapApiCallWithTimeout(cortanaApp.searchResultsView.deviceSearch, functionName, createInstrumentationKey(functionName), "Navigation", launchApiAllowedLatency, null, [itemId]).then(sj_df(launchFirstFoundItem, options));
                            }
                        }
                        break;
                    case 4 /* Experience */:
                        var experienceName = targetElement.getAttribute("data-experiencename");
                        if (experienceName) {
                            SearchAppWrapper.CortanaApp.launchExperienceByName(experienceName, null);
                        }
                        break;
                    case 2 /* Explore */:
                        var destination = targetElement.getAttribute("data-dest");
                        if (destination) {
                            var provider = targetElement.getAttribute("data-provider");
                            if (provider) {
                                launcher.launchSearchInApp(destination, ThresholdUtilities.getDecodedQuery(_w.location.toString()), provider);
                            }
                            else {
                                launcher.launchSearchInApp(destination, ThresholdUtilities.getDecodedQuery(_w.location.toString()));
                            }
                            signalComplete();
                        }
                        break;
                    case 1 /* Web */:
                        if (isRelative) {
                            rebaseLink(targetElement);
                            // Need to refresh after changing the link properties
                            destinationLink = targetElement.href;
                            // Instrument the time of the click to allow us to join the impressions. These requests are from two
                            // different apps, so will be seen as 2 different users, making it difficult to measure e2e perf from
                            // app click to browser page load without this query param.
                            var joiningChar = destinationLink.indexOf("?") === -1 ? "?" : "&";
                            destinationLink += joiningChar + "ts=" + sb_gt();
                            if (_G.nclid) {
                                destinationLink += "&nclid=" + _G.nclid;
                            }
                        }
                        var functionName = "launchUriAsync";
                        searchUtils.wrapApiCallWithTimeout(launcher, functionName, createInstrumentationKey(functionName), "Navigation", launchApiAllowedLatency, null, destinationLink).then(signalComplete);
                        break;
                }
            }
        }
        if (event && preventDefault) {
            event.preventDefault();
        }
    }
    ;
    function createInstrumentationKey(apiName) {
        return apiName.match(apiNameAbbreviator).join("").toUpperCase();
    }
    function launchFirstFoundItem(result, options) {
        if (result != null) {
            for (var i in result) {
                var currentResult = result[i];
                // This check seems unecessary, but the mapping returned maps IDs to empty objects when it fails to find it on the machine.
                if (currentResult && currentResult.id) {
                    var functionName = "launchSearchItemAsync";
                    ThresholdUtilities.wrapApiCallWithTimeout(SearchAppWrapper.CortanaApp.launcher, functionName, createInstrumentationKey(functionName), null, launchApiAllowedLatency, null, currentResult, options).then(signalComplete);
                    break;
                }
            }
        }
    }
    function getUrlType(destinationPath, destinationSearch, destinationHostname, isRelative) {
        if (isRelative && isSupportedPath(destinationPath, destinationSearch)) {
            // This is a requery on search
            if (destinationPath === "search" || destinationPath === "/search") {
                return 5 /* Search */;
            }
            // This is a navigation link to another bing page
            return 3 /* Navigation */;
        }
        else if (destinationHostname === "ms-smartsearch") {
            if (destinationPath === "app" || destinationPath === "/app") {
                return 0 /* App */;
            }
            else if (destinationPath === "searchInApp" || destinationPath === "/searchInApp") {
                return 2 /* Explore */;
            }
            else if (destinationPath === "experience" || destinationPath === "/experience") {
                return 4 /* Experience */;
            }
        }
        // Any other links should be launched in browser.
        return 1 /* Web */;
    }
    ;
    function onClickHandler(evt) {
        if (!evt.defaultPrevented) {
            var element = evt.target;
            var targetElement = getParentContainer(element, "A");
            if (targetElement) {
                navigateTo(targetElement, evt);
            }
        }
    }
    ;
    function getParentContainer(target, tagName) {
        for (; target && target !== document; target = target.parentNode) {
            if (target.tagName === tagName) {
                return target;
            }
        }
    }
    ;
    function getBaseUrl() {
        if (_w["_TH_BU"]) {
            var baseUrlPieces = _TH_BU.split("//", 2);
            if (baseUrlPieces.length === 2) {
                baseProtocol = baseUrlPieces[0];
                baseHostname = baseUrlPieces[1];
                return;
            }
        }
        baseProtocol = location.protocol;
        baseHostname = getHostname(location);
    }
    function rebaseLink(element) {
        element.protocol = baseProtocol;
        element.hostname = baseHostname;
        element.port = baseProtocol === "https:" ? "443" : "80";
    }
    function getHostname(element) {
        if (!element) {
            return null;
        }
        var hostname = element.hostname;
        if (!hostname) {
            return null;
        }
        // Microsoft Edge drops the [ ] for IPv6 urls, and we cannot actually navigate to IPv6 hosts without them.
        // Add them if they're missing.
        if (hostname.indexOf(":") >= 0 && hostname.indexOf("[") < 0) {
            hostname = "[" + hostname + "]";
        }
        return hostname;
    }
    sj_be(_w, "click", onClickHandler);
    var UrlType;
    (function (UrlType) {
        UrlType[UrlType["App"] = 0] = "App";
        UrlType[UrlType["Web"] = 1] = "Web";
        UrlType[UrlType["Explore"] = 2] = "Explore";
        UrlType[UrlType["Navigation"] = 3] = "Navigation";
        UrlType[UrlType["Experience"] = 4] = "Experience";
        UrlType[UrlType["Search"] = 5] = "Search";
    })(UrlType || (UrlType = {}));
})(SmartSearch || (SmartSearch = {}));
;// ------------------------------------------------------------------------------
// <copyright file="SmartSearch.ts" company="Microsoft Corporation">
//     Copyright (c) Microsoft Corporation. All Rights Reserved.
//     Information Contained Herein is Proprietary and Confidential.
// </copyright>
// ------------------------------------------------------------------------------
///<reference path="..\..\..\..\Shared\Content\Content\script\Declarations\AppApi.d.ts"/>
///<reference path="..\..\..\..\Shared\Content\Content\script\Declarations\Shared.d.ts"/>
///<reference path="..\..\..\..\Shared\Content\Content\Script\Declarations\Threshold.Utilities.d.ts" />
///<reference path="SmartSearch.Navigation.ts"/>
///<reference path="SearchApp.Mock.ts"/>
(function () {
    var appIdAttribute = "data-appid";
    if (typeof AppApi === "undefined" || !AppApi.UpdateAppInfo || !SearchAppWrapper.CortanaApp.searchResultsView) {
        return;
    }
    // Get app ids
    var appIds = [];
    var appLinks = document.querySelectorAll("[" + appIdAttribute + "]");
    for (var i = 0; i < appLinks.length; i++) {
        var appId = appLinks[i].getAttribute(appIdAttribute);
        if (appIds.indexOf(appId) < 0) {
            appIds.push(appId);
        }
    }
    var processApplicationMap = function (results) {
        var apps = [];
        for (var index in appIds) {
            var appId = appIds[index];
            if (results.hasKey(appId)) {
                var item = results[appId];
                if (item) {
                    var app = {
                        id: appId,
                        installedAppVersion: item.version,
                        installed: true
                    };
                    apps.push(app);
                    if (CachedDeviceItems && !CachedDeviceItems[appId]) {
                        CachedDeviceItems[appId] = item;
                    }
                }
            }
        }
        AppApi.UpdateAppInfo(apps);
        ThresholdUtilities.uploadApiTimes("ALR");
    };
    // Check the app install state and update app info, only if we have some apps to check
    if (appIds.length > 0) {
        ThresholdUtilities.wrapApiCall(SearchAppWrapper.CortanaApp.searchResultsView.deviceSearch, "findAppsAsync", "AL", "AppLinking", appIds).then(processApplicationMap);
    }
})();
;// sets a session cookie crumb with the browser's inner width and height, and the device pixel ratio
(function () {
    function setCW() {
        var clientSizeCookie = "SRCHHPGUSR";
        var cwCookie = sj_cook.get(clientSizeCookie, "CW");

        if (!cwCookie || (window.sj_b && cwCookie != sj_b.clientWidth)) {
            sj_cook.set(clientSizeCookie, "CW", sb_de.clientWidth || sj_b.clientWidth, 1, "/");
        }

        var chCookie = sj_cook.get(clientSizeCookie, "CH");
        if (!chCookie || chCookie != sb_de.clientHeight) {
            sj_cook.set(clientSizeCookie, "CH", sb_de.clientHeight, 1, "/");
        }

        var dprCookie = sj_cook.get(clientSizeCookie, "DPR");
        if (typeof _w.devicePixelRatio !== 'undefined' && (!dprCookie || dprCookie != _w.devicePixelRatio)) {
            sj_cook.set(clientSizeCookie, "DPR", _w.devicePixelRatio, 1, "/");
        }
    }
    sj_be(_w, "load", setCW);
    sj_be(_w, "resize", setCW);
})();;/// <reference path="..\..\..\..\Shared\Content\Content\Script\Declarations\Shared.d.ts" />
/// <reference path='..\..\..\..\Shared\Content\Content\Script\Declarations\Threshold.Utilities.d.ts' />
/// <reference path="..\..\..\..\Threshold\src\Content\Script\Declarations\SearchAppWrapper.d.ts" />
(function () {
    if (SearchAppWrapper && SearchAppWrapper.CortanaApp) {
        var languageGenerationElement = _d.querySelector(".b_cat3a div[data-ssml]");
        if (languageGenerationElement) {
            ThresholdUtilities.wrapSynchronousApiCall(SearchAppWrapper.CortanaApp, "respond", null, "respond", languageGenerationElement.getAttribute("data-ssml"), languageGenerationElement.getAttribute("data-postssmlaction"), languageGenerationElement.getAttribute("data-secondarytext-small"), languageGenerationElement.getAttribute("data-secondarytext-medium"), languageGenerationElement.getAttribute("data-secondarytext-large"));
        }
        var emotionElement = _d.querySelector(".b_cat3a div[data-emot]");
        if (emotionElement) {
            ThresholdUtilities.wrapSynchronousApiCall(SearchAppWrapper.CortanaApp, "setEmotion", null, "setEmotion", emotionElement.getAttribute("data-emot"), emotionElement.getAttribute("data-emot-size") == "large", emotionElement.hasAttribute("data-emot-overridespeaking"));
        }
    }
})();
;

CUDialog.sendAction({"CuAction":"{\"Uri\":\"action://CuOutput\",\"SystemAction\":{\"Reminder\":{\"Condition\":\"None\",\"Title\":{\"Value\":\"记住我的车停在楼下\",\"ProfanityMasked\":\"记住我的车停在楼下\",\"Uri\":\"entity://TextData\",\"Version\":\"2.0\"},\"Uri\":\"entity://Reminder\",\"Version\":\"2.0\"},\"Uri\":\"action://Reminder/Create\",\"Version\":\"2.0\"},\"ConversationId\":\"9ff16d5b-4ccc-9b84-c9e5-75cfe69e8aaf\",\"TraceId\":\"04D81438156E457FB07546DC975522CE\",\"ImpressionId\":\"c6310a13bb7957fbc90e66b4e705fd78\",\"LgObject\":{\"Uri\":\"action://LgObject\",\"Ssml\":null,\"DisplayText\":null,\"SuggestionText\":null,\"SecondaryDisplayTextSmall\":null,\"SecondaryDisplayTextMedium\":null,\"SecondaryDisplayTextLarge\":null}}"});

;(function () {
    function Promote() {
        var isBingSE = _w["isBingCurrentSearchDefault"];
        var setSE = _w["setBingCurrentSearchDefault"];
        if (setSE && isBingSE) {
            var promptNow = false;
            var currDate = new Date();
            if (typeof (Storage) !== "undefined" && _w.localStorage) {
                var tempFlagData = localStorage.getItem("lastSEPromptShownFlag");
                if (tempFlagData != null && tempFlagData != "false") {
                    if (isBingSE() == false) {
                        Log.Log("SetSE", "SetSE", "setBingCurrentSearchDefault", true, "PSE", "Non-Bing", "SE", "Non-Bing", "UA", "Denied");
                    }
                    else {
                        Log.Log("SetSE", "SetSE", "setBingCurrentSearchDefault", true, "PSE", "Non-Bing", "SE", "Bing", "UA", "Accepted");
                    }
                    localStorage.setItem("lastSEPromptShownFlag", false);
                }
                if (!localStorage.getItem("lastSEPromptDate")) {
                    promptNow = true;
                }
                else {
                    if (currDate.getTime() - new Date(localStorage.getItem("lastSEPromptDate")).getTime() > 1000 * 60 * 60 * 24 * 7) {
                        promptNow = true;
                    }
                    else {
                        promptNow = false;
                    }
                }
            }
            if (promptNow && isBingSE() == false) {
                try {
                    localStorage.setItem("lastSEPromptDate", currDate);
                    localStorage.setItem("lastSEPromptShownFlag", true);
                    var result = setSE();
                }
                catch (err) {
                    promptNow = false;
                }
            }
        }
    }
    sj_be(_w, "load", Promote);
})();
;// this module defines some basic accessibility helpers
var AccessibilityHelpers;
(function (AccessibilityHelpers) {
    // Not Perfect, but there is no standard property for focusable elements
    var focusableItemsSelector = 'a[href], body, input, select, [tabindex]';
    function FocusNextFocusableElement() {
        if (_d.querySelectorAll && _d.activeElement) {
            var selectElements = _d.querySelectorAll(focusableItemsSelector);
            // Items with display:none, and tabIndex="-1" are not focusable
            var focusableElements = [];
            for (var i = 0; i < selectElements.length; i++) {
                var curItem = selectElements.item(i);
                if (curItem && curItem.tabIndex != -1 && window.getComputedStyle(curItem).display != "none") {
                    focusableElements.push(curItem);
                }
            }
            var currentlyFocusedIndex = focusableElements.indexOf(_d.activeElement);
            if (typeof (sj_log) != "undefined") {
                // Since our selector is supposed to encompass all focusable elements, the currently focused element
                // should always appear in this list.  But this behavior can differ from browser to browser, and I want to catch
                // instances where the element isn't found, so I can tweak my selector
                sj_log("CI.MoveFocus", "Next", _d.activeElement.tagName + " " + currentlyFocusedIndex.toString());
            }
            focusableElements[currentlyFocusedIndex + 1 % focusableElements.length].focus();
        }
    }
    AccessibilityHelpers.FocusNextFocusableElement = FocusNextFocusableElement;
})(AccessibilityHelpers || (AccessibilityHelpers = {}));
;///<reference path="Declarations\Shared.d.ts" />
///<reference path="Declarations\CssClass.d.ts" />
// this module defines the script working for expansion item
var expitem;
(function (expitem) {
    var items = {};
    var hiddenOnExpansionAttribute = "data-hoe";
    var inversionAttribute = "inversion";
    var transitionEndEventName = getTransitionEndEventName();
    var scrollbarWidth = getScrollbarWidth();
    // toggle visible state of managed items
    function toggle(p) {
        if (!p.collapsible) {
            hideItem(p);
        }
        var toCollapse = isExpanded(p);
        var exp = _ge(p.id);
        if (p.scrollBackOnCollapse) {
            if (toCollapse) {
                p.topInViewportBeforeCollapse = getTopInViewport(exp);
                p.bodyHeightBelowViewportBeforeCollapse = _d.body.scrollHeight - getBodyScrollTop() - getViewportHeight();
                if (hasHorizontalScrollbar()) {
                    p.bodyHeightBelowViewportBeforeCollapse += scrollbarWidth;
                }
            }
            else {
                p.topInViewportBeforeExpand = getTopInViewport(exp);
                p.bodyHeightBeforeExpand = _d.body.scrollHeight;
                p.answerContainerHeightBeforeExpand = p.answerContainer.clientHeight;
            }
        }
        for (var i = 0; i < p.turnable.length; i++) {
            var node = p.turnable[i];
            if (p.animationEnabled) {
                toggleSlide(p, node);
            }
            else {
                var inversion = node.getAttribute(inversionAttribute) === "1";
                if (inversion) {
                    var removeHideClass = toCollapse === inversion;
                    removeHideClass ? Lib.CssClass.add(node, 'b_hide') : Lib.CssClass.remove(node, 'b_hide');
                }
                else {
                    var hideNodeOnExpansion = node.getAttribute(hiddenOnExpansionAttribute) === "1";
                    var removeHideClass = toCollapse != hideNodeOnExpansion;
                    removeHideClass ? Lib.CssClass.add(node, 'b_hide') : Lib.CssClass.remove(node, 'b_hide');
                }
            }
        }
        for (i = 0; i < p.movable.length; i++) {
            move(p, p.movable[i], toCollapse, p.animationEnabled);
        }
        for (i = 0; i < p.exclusive.length; i++) {
            var pair = p.exclusive[i];
            if (pair.length != 2) {
                continue;
            }
            swap(pair);
        }
        for (i = 0; i < p.buffer.length; i++) {
            // flush out
            node = p.buffer[i];
            for (var j = 0; j < node.childNodes.length; j++) {
                node.parentNode.insertBefore(node.childNodes[i], node);
            }
        }
        p.state++;
        var disableAnswerSideScrollBackWhenCollapse = p.scrollBackOnCollapse;
        sj_evt.fire('exptoggle', p.id, toCollapse, disableAnswerSideScrollBackWhenCollapse);
        if (p.scrollBackOnCollapse) {
            if (toCollapse) {
                updatePage(p);
            }
            else {
                updateExpansionHeight(p);
            }
        }
        // log the instrumentation
        Log.Log(toCollapse ? "Hide" : "Show", p.logArea, p.logName, false, "AppNS", exp.getAttribute("data-appns"), "K", exp.getAttribute("data-k"));
    }
    // hide current expansion item itself
    function hideItem(p) {
        setDisplayOfItem(p, 'none');
    }
    // show current expansion item itself
    function showItem(p) {
        setDisplayOfItem(p, '');
    }
    function setDisplayOfItem(p, display) {
        var anchor = _ge(p.id);
        if (!anchor) {
            return;
        }
        var par = anchor.parentNode;
        /*There may be padding specified in the parent 'sml' class (used in ExpansionItem) which needs to be hidden.  */
        if (par.className == 'sml' || par.className == 'btm_sml') {
            par.style.display = display;
        }
        else {
            anchor.style.display = display;
        }
    }
    function swap(pair) {
        if (pair.length !== 2) {
            return;
        }
        var temp = sj_ce("div");
        moveAll(pair[0], temp);
        moveAll(pair[1], pair[0]);
        moveAll(temp, pair[1]);
    }
    // move all children from one element to another
    function moveAll(elem1, elem2) {
        while (elem1.childNodes.length > 0) {
            elem2.appendChild(elem1.childNodes[0]);
        }
    }
    // move all elements managed by an movable entry
    function getMovableChildren(entry, forceRefresh) {
        var movableChildrenProperty = 'movech';
        var movableChildren = entry[movableChildrenProperty];
        if (!movableChildren || forceRefresh) {
            movableChildren = [];
            var childNodes = entry.childNodes;
            if (childNodes) {
                for (var i = 0; i < childNodes.length; i++) {
                    movableChildren.push(childNodes[i]);
                }
            }
            entry[movableChildrenProperty] = movableChildren;
        }
        return movableChildren;
    }
    function toggleOnEndForMovableEntry(entry) {
        Lib.CssClass.add(entry, "b_hide");
        var movableChildren = getMovableChildren(entry, true);
        for (var i = 0; i < movableChildren.length; i++) {
            var child = movableChildren[i];
            entry.parentNode.insertBefore(child, entry);
        }
    }
    function move(p, entry, toCollapse, enableAnimation) {
        var movableChildren;
        var child;
        var i;
        if (enableAnimation) {
            if (toCollapse) {
                Lib.CssClass.remove(entry, "b_hide");
                movableChildren = getMovableChildren(entry, false);
                for (i = 0; i < movableChildren.length; i++) {
                    child = movableChildren[i];
                    entry.appendChild(child);
                }
                toggleSlide(p, entry);
            }
            else {
                // disable padding, margin to avoid impact from other CSS rules when removing "b_hide" 
                Lib.CssClass.add(entry, "hidden_nostyle");
                toggleSlide(p, entry, toggleOnEndForMovableEntry);
            }
        }
        else {
            movableChildren = getMovableChildren(entry, !toCollapse);
            for (i = 0; i < movableChildren.length; i++) {
                child = movableChildren[i];
                if (toCollapse) {
                    entry.appendChild(child);
                }
                else {
                    entry.parentNode.insertBefore(child, entry);
                }
            }
        }
    }
    function updateExpansionHeight(p) {
        p.expansionHeight = p.answerContainer.clientHeight - p.answerContainerHeightBeforeExpand;
        p.bodyExpansionHeight = _d.body.scrollHeight - p.bodyHeightBeforeExpand;
    }
    // there might be enough content below viewport for this to collapse
    // so window scroll differently in this special case
    function updatePage(p) {
        if (p.expansionHeight != p.bodyExpansionHeight) {
            return;
        }
        pageScrollWithEqualHeight(p);
    }
    function pageScrollWithEqualHeight(p) {
        var offsetY = 0;
        var marginTop = 0;
        if (p.topInViewportBeforeCollapse <= p.topInViewportBeforeExpand) {
            if (p.expansionHeight <= p.bodyHeightBelowViewportBeforeCollapse) {
                offsetY = -p.expansionHeight;
            }
            else {
                offsetY = -p.bodyHeightBelowViewportBeforeCollapse;
            }
            marginTop = p.expansionHeight;
        }
        else {
            var topAfterCollapse = p.topInViewportBeforeCollapse - p.expansionHeight;
            if (p.expansionHeight <= p.bodyHeightBelowViewportBeforeCollapse) {
                offsetY = topAfterCollapse - p.topInViewportBeforeExpand;
            }
            else {
                offsetY = p.topInViewportBeforeCollapse - p.bodyHeightBelowViewportBeforeCollapse - p.topInViewportBeforeExpand;
            }
            marginTop = -(topAfterCollapse - p.topInViewportBeforeExpand);
        }
        pageScroll(p, offsetY, marginTop);
    }
    function pageScroll(p, offsetY, marginTop) {
        if (!p.animationEnabled || !p.inAnimation) {
            _w.scrollBy(0, offsetY);
            return;
        }
        Lib.CssClass.add(_d.body, "exp_scroll");
        forceStyleUpdate(_d.body);
        _d.body.style.marginTop = marginTop + "px";
        function resetPage() {
            sj_ue(_d.body, transitionEndEventName, resetPage);
            Lib.CssClass.remove(_d.body, "exp_scroll");
            forceStyleUpdate(_d.body);
            _d.body.style.marginTop = "";
            _w.scrollBy(0, offsetY);
        }
        sj_be(_d.body, transitionEndEventName, resetPage);
    }
    function toggleSlide(p, node, onEnd) {
        if (onEnd === void 0) { onEnd = null; }
        p.inAnimation = true;
        setHeight(node);
        forceStyleUpdate(node);
        Lib.CssClass.add(node, "exp_slide");
        forceStyleUpdate(node);
        Lib.CssClass.toggle(node, "b_hide");
        var toExpand = !isExpanded(p);
        function slideEndHandler(event) {
            if (event.target != node) {
                return;
            }
            sj_ue(node, transitionEndEventName, slideEndHandler);
            Lib.CssClass.remove(node, "exp_slide");
            node.style.height = "";
            if (onEnd) {
                onEnd(node);
            }
            // calculate expansion height when expanding this
            if (toExpand && p.scrollBackOnCollapse) {
                updateExpansionHeight(p);
            }
            p.inAnimation = false;
        }
        sj_be(node, transitionEndEventName, slideEndHandler);
    }
    function wireupAll() {
        var dataExp = "data-exp";
        var nodes = null;
        if (_d.querySelectorAll) {
            nodes = _d.querySelectorAll("[" + dataExp + "]");
        }
        else {
            nodes = _d.getElementsByTagName("*");
        }
        for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            if (node.getAttribute) {
                if (_w["progressiveLoad"] === true) {
                    if (Lib.CssClass.contains(node, "hasOnP1")) {
                        continue;
                    }
                    else {
                        Lib.CssClass.add(node, "hasOnP1");
                    }
                }
                var expAttribute = node.getAttribute(dataExp);
                if (expAttribute) {
                    wireupElement(node, expAttribute);
                    // Ensure that an element is not wired up twice.
                    node.removeAttribute(dataExp);
                }
            }
        }
    }
    function wireupElement(element, expAttribute) {
        var expAttributeList = expAttribute.split(";");
        switch (expAttributeList[0]) {
            case "I":
                wireupLinkElement(element, expAttributeList);
                break;
            case "H":
                wireupHiddenElement(element, expAttributeList);
                break;
        }
    }
    function wireupLinkElement(element, expAttributeList) {
        var id = expAttributeList[1];
        var item = getOrCreateItem(id);
        item.id = id;
        item.collapsible = "1" === expAttributeList[2];
        item.visibles = parseInt(expAttributeList[3]);
        item.state = "1" === expAttributeList[4] ? 1 : 0;
        item.hitTarget = expAttributeList[5];
        item.logArea = expAttributeList[6] || "Expansion";
        item.logName = expAttributeList[7] || id;
        item.scrollBackOnCollapse = "1" === expAttributeList[8];
        item.animationEnabled = ("1" === expAttributeList[9]) && (transitionEndEventName !== "");
        item.answerContainer = findAnswerContainer(_ge(item.id));
        sj_evt.bind("exphide", function (evtArgs) {
            var expId = evtArgs[1];
            if (expId === item.id) {
                hideItem(item);
            }
        });
        sj_evt.bind("expshow", function (evtArgs) {
            var expId = evtArgs[1];
            if (expId === item.id) {
                showItem(item);
            }
        });
        // bind extra hit targets
        var targets = [element.id, item.hitTarget];
        for (var i = 0; i < targets.length; ++i) {
            var hitTarget = _ge(targets[i]);
            if (hitTarget) {
                sj_be(hitTarget, "keyup", function (evt) {
                    // Keycode 13 is "Enter" (Only re-focus if done through keyboard)
                    if (evt.keyCode == 13 && !item.collapsible) {
                        // When we hide the currently focused item, focus resets to the beginning.  Explicitly set to avoid this jump
                        AccessibilityHelpers.FocusNextFocusableElement();
                        sj_sp(evt);
                    }
                });
                sj_be(hitTarget, "click", function (evt) {
                    toggle(item);
                    sj_sp(evt);
                });
            }
        }
        items[id] = item;
    }
    function wireupHiddenElement(element, expAttributeList) {
        var id = expAttributeList[1];
        var keep = "1" === expAttributeList[2];
        var exclusive = expAttributeList[3];
        var buffer = "1" === expAttributeList[4];
        var hiddenOnExpansion = "1" === expAttributeList[5];
        var expanded = "1" === expAttributeList[6];
        var item = getOrCreateItem(id);
        if (buffer) {
            item.buffer.push(element);
        }
        else if (expanded) {
            element.setAttribute(inversionAttribute, "1");
            item.turnable.push(element);
        }
        else if (hiddenOnExpansion) {
            element.setAttribute(hiddenOnExpansionAttribute, "1");
            item.turnable.push(element);
        }
        else if (keep) {
            item.turnable.push(element);
        }
        else if (exclusive && exclusive.length) {
            var other = _ge(exclusive);
            if (other) {
                item.exclusive.push([element, other]);
            }
        }
        else {
            item.movable.push(element);
        }
        items[id] = item;
    }
    function getOrCreateItem(id) {
        return items[id] || {
            id: id,
            movable: [],
            turnable: [],
            exclusive: [],
            external: [],
            buffer: []
        };
    }
    function isExpanded(item) {
        return (item.state % 2) !== 0;
    }
    function allowExplicitExpansionOnly(item) {
        var expansion = _ge(item.id);
        if (expansion != null && expansion.getAttribute("data-expl") == "1") {
            return true;
        }
        return false;
    }
    // Due to browser optimization of style update, multiple style changes may go at the same time instead of sequentially.  
    // To force update of styles before applying the animation class, a layout property is accessed, which forces the browser
    // to update the style and layouts.
    function forceStyleUpdate(node) {
        var tmp = node.offsetTop;
    }
    function findAnswerContainer(node) {
        var answerContainerParentIds = { "b_pole": true, "b_results": true, "b_context": true };
        var parent = node.parentElement;
        while (parent != null && !(parent.id in answerContainerParentIds)) {
            node = parent;
            parent = node.parentElement;
        }
        return node;
    }
    function setHeight(node) {
        var height = node.clientHeight;
        if (height == 0 && Lib.CssClass.contains(node, "b_hide")) {
            Lib.CssClass.remove(node, "b_hide");
            height = node.clientHeight;
            Lib.CssClass.add(node, "b_hide");
        }
        if (height > 0) {
            node.style.height = height + "px";
        }
    }
    function getTopInViewport(node) {
        var rect = node.getBoundingClientRect();
        return rect.top;
    }
    function getTransitionEndEventName() {
        var eventName = "TransitionEnd";
        var styleName = "Transition";
        var prefixes = ["o", "Moz", "webkit"];
        if (styleName.toLowerCase() in _d.documentElement.style) {
            return eventName.toLowerCase();
        }
        for (var i = 0; i < prefixes.length; i++) {
            var prefixStyleName = prefixes[i] + styleName;
            if (prefixStyleName in _d.documentElement.style) {
                return prefixes[i] + eventName;
            }
        }
        return "";
    }
    function hasHorizontalScrollbar() {
        return _w.innerHeight > _d.documentElement.clientHeight;
    }
    function getScrollbarWidth() {
        var outer = sj_ce("div");
        outer.style.visibility = "hidden";
        outer.style.width = "100px";
        _d.body.appendChild(outer);
        var outerWidth = outer.offsetWidth;
        outer.style.overflow = "scroll";
        var inner = sj_ce("div");
        inner.style.width = "100%";
        outer.appendChild(inner);
        var innerWidth = inner.offsetWidth;
        _d.body.removeChild(outer);
        return outerWidth - innerWidth;
    }
    function getBodyScrollTop() {
        return _w.pageYOffset || _d.body.scrollTop || _d.documentElement.scrollTop;
    }
    function getViewportHeight() {
        return _w.innerHeight || _d.documentElement.clientHeight;
    }
    // Argument 1: Required. expansion ID representing the item to expand, collapse, or toggle
    // Argument 2: Optional. int. The state. 0 to collapse, 1 to expand. Pass nothing to toggle.
    sj_evt.bind("expItem.exp", function (args) {
        var item = items[args[1]];
        if (item && !allowExplicitExpansionOnly(item)) {
            if (args.length > 2) {
                var shouldExpand = (args[2] % 2) !== 0;
                if (shouldExpand != isExpanded(item)) {
                    toggle(item);
                    if (!shouldExpand && !item.collapsible) {
                        showItem(item);
                    }
                }
            }
            else {
                toggle(item);
            }
        }
    }, true);
    sj_evt.bind("onP1", wireupAll, true);
})(expitem || (expitem = {}));
;///<reference path="Declarations\Shared.d.ts" />
var SelectorHelper;
(function (SelectorHelper) {
    // This method is intended to work cross-browser. On down-level browsers without native javascript support, the DOM is walked to find a match.  Please be mindful of performance when calling this for down-level browsers.
    function selectorMatches(e, selector) {
        if (e["matches"]) {
            return e["matches"](selector);
        }
        else if (e["webkitMatchesSelector"]) {
            return e["webkitMatchesSelector"](selector);
        }
        else if (e["mozMatchesSelector"]) {
            return e["mozMatchesSelector"](selector);
        }
        else if (e["msMatchesSelector"]) {
            return e["msMatchesSelector"](selector);
        }
        else {
            var eles = _d.querySelectorAll(selector);
            if (eles) {
                for (var i = 0; i < eles.length; i++) {
                    if (eles[i] === e) {
                        return true;
                    }
                }
            }
            return false;
        }
    }
    SelectorHelper.selectorMatches = selectorMatches;
    function findFirstAncestorWithSelector(e, selector) {
        var p = e;
        do {
            p = p.parentElement;
        } while (p != null && !selectorMatches(p, selector));
        return p;
    }
    SelectorHelper.findFirstAncestorWithSelector = findFirstAncestorWithSelector;
})(SelectorHelper || (SelectorHelper = {}));
;///<reference path="..\Declarations\Shared.d.ts" />
///<reference path="..\SelectorHelper.ts" />
var AnswerActionsHelper;
(function (AnswerActionsHelper) {
    function createUndoContainer(undoText, confirmText) {
        if (undoText == null || confirmText == null) {
            return null;
        }
        var msgContainer = sj_ce("div", null, "b_undoContainer b_hide");
        var confirmContainer = sj_ce("div", null, "confirmMsg");
        confirmContainer.innerHTML = confirmText;
        var undoLink = sj_ce("a");
        undoLink.setAttribute("href", "javascript:void(0);");
        undoLink.innerText = undoText;
        msgContainer.appendChild(confirmContainer);
        msgContainer.appendChild(undoLink);
        return msgContainer;
    }
    AnswerActionsHelper.createUndoContainer = createUndoContainer;
    function createErrorHandler(actionLink, errorString, isButtons) {
        return function () {
            // Let the action link be functional again and set error text
            actionLink["isHandling"] = false;
            actionLink.innerText = errorString;
            actionLink.classList.remove("b_demoteText");
            if (!isButtons) {
                actionLink.classList.add("b_accentColor");
            }
        };
    }
    AnswerActionsHelper.createErrorHandler = createErrorHandler;
    // For a given element, find the answer card it's contained within.
    function findContainingCard(element) {
        var card = SelectorHelper.findFirstAncestorWithSelector(element, "#b_pole,.b_ans,.b_ansSlice,.answer,.b_inlActions");
        var isInlineActionContainer = card.classList.contains("b_inlActions");
        if (isInlineActionContainer) {
            var ansCard = SelectorHelper.findFirstAncestorWithSelector(card, "#b_pole,.b_ans,.b_ansSlice,.answer");
            if (ansCard) {
                card = ansCard;
            }
        }
        return card;
    }
    AnswerActionsHelper.findContainingCard = findContainingCard;
    // Determines whether an element is a wrapper used for swapping.
    function isSwapWrapper(element) {
        return element.getAttribute("data-type") === "wrapper";
    }
    AnswerActionsHelper.isSwapWrapper = isSwapWrapper;
    function fade(element) {
        if (element == null) {
            return;
        }
        element.classList.add("b_anim");
        // For the animation to work correctly, it has to transition from one property to another.
        // So to transition to zero properly, we need to set the height explicitly first.
        element.style.height = _w.getComputedStyle(element).height;
        // Start the animation. We need a miniscule amount of time to have the above style change repaint.
        sb_st(function () {
            element.classList.add("b_hide");
            sj_evt.fire('elementgone', element);
        }, 1);
    }
    AnswerActionsHelper.fade = fade;
    function createResponseCard(content, oldCard) {
        if (!oldCard) {
            return null;
        }
        var container = sj_ce(oldCard.tagName, "", oldCard.className);
        container.innerHTML = content;
        return container;
    }
    AnswerActionsHelper.createResponseCard = createResponseCard;
    function swapElements(newElement, oldElement, fadeIfNoReplacement) {
        if (newElement == null || oldElement == null) {
            if (oldElement != null && fadeIfNoReplacement) {
                fade(oldElement);
            }
            return;
        }
        // Create a wrapper element that houses both the new and old elements.
        // Try to reuse an existing wrapper if we find one to keep the DOM shallow.
        var parent = oldElement.parentElement;
        var container;
        if (isSwapWrapper(parent)) {
            container = parent;
        }
        else {
            container = sj_ce("div");
            container.setAttribute("data-type", "wrapper");
            container.classList.add('b_anim');
            parent.insertBefore(container, oldElement);
            container.appendChild(oldElement);
        }
        // Move the new element to the wrapper too
        container.appendChild(newElement);
        // We want to ensure the container animates the height change. To do this we:
        //   1. Set the height to the old element's height
        //   2. Set the height to the new element's height after the above height change goes into effect.
        //   3. When the height has animated, reset the value so that the style is not affecting other transformations on page
        container.style.height = getTotalHeight(oldElement) + "px";
        sb_st(function () {
            container.style.height = getTotalHeight(newElement) + "px";
            sb_st(function () { return container.style.height = ''; }, 0);
        }, 0);
        // Fade out the old element
        fade(oldElement);
    }
    AnswerActionsHelper.swapElements = swapElements;
    function findImmediateChild(parent, descendant) {
        while (descendant && descendant.parentElement !== parent) {
            descendant = descendant.parentElement;
        }
        return descendant;
    }
    function wrapWithDiv(elements, excludedElements) {
        var wrapper = sj_ce("div");
        var i = 0;
        while (i < elements.length) {
            var child = elements[i];
            if (excludedElements == null || excludedElements.indexOf(child) < 0) {
                wrapper.appendChild(child);
            }
            else {
                i++;
            }
        }
        return wrapper;
    }
    function getTotalHeight(element) {
        return convertStyleToPixels(_w.getComputedStyle(element).height) + convertStyleToPixels(_w.getComputedStyle(element).paddingBottom);
    }
    function convertStyleToPixels(style) {
        // Cut off the "px" suffix
        return parseInt(style.substring(0, style.length - 2));
    }
    function insertScriptIntoHead(script) {
        var returnScript = sj_ce("script", "");
        returnScript.type = "text/javascript";
        if (script.src) {
            returnScript.src = script.src;
        }
        else {
            returnScript.innerHTML = script.innerHTML;
        }
        insertNodeIntoHead(returnScript);
    }
    function dismissCard(action) {
        var lastClickedCard = AnswerActionsHelper.findContainingCard(action);
        AnswerActionsHelper.fade(lastClickedCard);
        var answerContainer = SelectorHelper.findFirstAncestorWithSelector(lastClickedCard, "#b_pole,.b_ans");
        if (answerContainer) {
            sb_st(function () {
                var subAnswers = AnswerActionsHelper.findInCard(answerContainer, ".b_ansSlice", false);
                if (!subAnswers) {
                    AnswerActionsHelper.fade(answerContainer);
                }
                sj_evt.fire("dismissCard");
            }, 1);
        }
    }
    AnswerActionsHelper.dismissCard = dismissCard;
    function replaceCard(action, newContent) {
        // Find the old and new answer cards
        var oldCard = findContainingCard(action);
        var newCard = createResponseCard(newContent, oldCard);
        if (oldCard == null || newCard == null) {
            if (oldCard != null) {
                // No new card came back but the action was successfull. Just dismiss the card.
                fade(oldCard);
            }
            return;
        }
        var isSearchReversed = false;
        var ansSlices = oldCard.querySelectorAll("div.b_ansSlice");
        if (ansSlices) {
            isSearchReversed = true;
        }
        // Extract styles and throw them into the DOM
        var styles = newCard.querySelectorAll("style, link");
        if (styles) {
            for (var i = 0; i < styles.length; i++) {
                insertNodeIntoHead(styles[i]);
            }
        }
        // Find the old explanation
        var newExplanation = findExplanation(newCard, false);
        var oldExplanation = findExplanation(oldCard, isSearchReversed);
        // Find the old and new annotations
        var newAnnotation = findAnnotation(newCard, false);
        var oldAnnotation = findAnnotation(oldCard, false);
        // Find the old and new actions
        var newActions = findActions(newCard, false);
        var oldActions = findActions(oldCard, isSearchReversed);
        // Find and swap the old and new captions
        var newCaption = wrapCaption(newAnnotation, newActions, newExplanation);
        var oldCaption = wrapCaption(oldAnnotation, oldActions, oldExplanation);
        // Extract scripts to later throw them into the DOM
        var scripts = newCard.querySelectorAll("script");
        // All animations go! Note that each of these animate independantly.
        swapElements(newAnnotation, oldAnnotation, false);
        swapElements(newCaption, oldCaption, false);
        swapElements(newActions, oldActions, true);
        swapElements(newExplanation, oldExplanation, true);
        if (scripts) {
            for (var i = 0; i < scripts.length; i++) {
                insertScriptIntoHead(scripts[i]);
            }
        }
        sj_evt.fire("replaceCard");
    }
    AnswerActionsHelper.replaceCard = replaceCard;
    // Find the element having a parent with data-type = "infoldAction"
    function findInlineActionContainer(action) {
        while (action != null) {
            var parent = action.parentElement;
            if (parent && parent.getAttribute && parent.getAttribute("data-type") === "InlineActionsWrapper") {
                return action;
            }
            action = parent;
        }
        return null;
    }
    AnswerActionsHelper.findInlineActionContainer = findInlineActionContainer;
    function insertNodeIntoHead(node) {
        _d.head.appendChild(node);
    }
    function findAnnotation(card, isSearchReversed) {
        return findInCard(card, '.b_anno,[data-anno]', isSearchReversed);
    }
    AnswerActionsHelper.findAnnotation = findAnnotation;
    function findTitle(card) {
        return findInCard(card, '.b_anno~h2,.b_anno~.b_focusLabel', false);
    }
    AnswerActionsHelper.findTitle = findTitle;
    function nodeListContains(nodelist, elem) {
        for (var i = 0; i < nodelist.length; i++) {
            if (nodelist[i] == elem) {
                return true;
            }
        }
        return false;
    }
    AnswerActionsHelper.nodeListContains = nodeListContains;
    function findActions(card, isSearchReversed) {
        var expandableActions = findInCard(card, '[data-type="expandableActions"]', isSearchReversed);
        return expandableActions ? expandableActions : findInCard(card, '[data-type="actions"]', isSearchReversed);
    }
    AnswerActionsHelper.findActions = findActions;
    function findExplanation(card, isSearchReversed) {
        return findInCard(card, '.actExpl', isSearchReversed);
    }
    AnswerActionsHelper.findExplanation = findExplanation;
    function findInCard(card, selector, isSearchReversed) {
        if (card) {
            var elements = card.querySelectorAll(selector);
            for (var i = (isSearchReversed ? elements.length - 1 : 0); (!isSearchReversed && i < elements.length) || (isSearchReversed && i >= 0); isSearchReversed ? i-- : i++) {
                var element = elements[i];
                if (element.classList.contains('b_hide')) {
                    // If we find an already faded element, go ahead and do some housekeeping to just remove it from the DOM.
                    element.parentNode.removeChild(element);
                }
                else {
                    return element;
                }
            }
        }
        return null;
    }
    AnswerActionsHelper.findInCard = findInCard;
    function wrapCaption(annotation, actions, explanation) {
        if (!annotation) {
            return null;
        }
        var parent = findContainingCard(annotation);
        var annotationImmediateChild = findImmediateChild(parent, annotation);
        var caption = wrapWithDiv(parent.childNodes, [annotationImmediateChild, findImmediateChild(parent, actions), findImmediateChild(parent, explanation)]);
        return parent.insertBefore(caption, annotationImmediateChild.nextSibling);
    }
})(AnswerActionsHelper || (AnswerActionsHelper = {}));
;///<reference path="..\..\..\..\Shared\Content\Content\Script\Declarations\Shared.d.ts" />
///<reference path="..\..\..\..\Shared\Content\Content\Script\Declarations\Animation.d.ts" />
///<reference path="..\..\..\..\Threshold\src\Content\Script\Declarations\SearchAppWrapper.d.ts" />
var SearchPeek;
(function (SearchPeek) {
    // const aliases for perf
    var Load = "load";
    var Peek = "peek";
    var PeekExpand = "peekExpand";
    var HideClass = "b_hide";
    var content = _ge("b_content");
    var results = _ge("b_results");
    var resultsItems = results.querySelectorAll(".b_ans,.b_algo,.b_ad");
    var poleAnswer = _ge("b_pole");
    var isCat3a = poleAnswer != null && poleAnswer.querySelector(".b_anno") != null;
    var annotation = isCat3a ? poleAnswer.querySelector(".b_anno") : null;
    var title = isCat3a ? poleAnswer.querySelector(".b_anno~h2,.b_anno~.b_focusLabel") : null;
    var header = _ge("b_header");
    var pagination = results.querySelector(".b_pag");
    var footer = _d.querySelector(".b_footer");
    var messageModules = results.querySelectorAll(".b_msg");
    var recourseLink = results.querySelector(".recourseLink").parentNode;
    var feedbackDiv = _ge("sb_feedback");
    var feedbackBadge = feedbackDiv ? feedbackDiv.parentNode : null;
    var hasPeekActivated = false;
    function activatePeek() {
        if (hasPeekActivated) {
            return;
        }
        hasPeekActivated = true;
        // change the background color
        _d.documentElement.classList.remove(Peek);
        sj_b.classList.remove(Peek);
        _d.documentElement.classList.add(PeekExpand);
        sj_b.classList.add(PeekExpand);
        // hide the pole answer based on a flag set by the answer
        if (annotation.getAttribute("data-mainContent") === "1") {
            Animation.toggleSlide(poleAnswer);
        }
        else {
            // answer will be shown in Cat3B, show/hide/animate the elements
            if (title) {
                title.classList.remove(HideClass);
            }
            annotation.classList.add(HideClass);
        }
        // Hide the recourse links        
        recourseLink.classList.add(HideClass);
        // Fade in the header, results, pagination, footer, etc.
        Animation.toggleSlideTranslate(header);
        content.classList.add(PeekExpand);
        results.classList.add("b_slideListHide");
        for (var i = 0; i < resultsItems.length; i++) {
            var result = resultsItems[i];
            result.classList.remove(HideClass);
        }
        if (pagination != null) {
            pagination.classList.remove(HideClass);
        }
        footer.classList.remove(HideClass);
        Animation.cascadeList(results);
        // Hide the client header
        SearchAppWrapper.CortanaApp.setChromeState(7 /* NoHeader */);
        // Let others know the peek happened
        sj_evt.fire("peekexpand", true);
    }
    function showPeek() {
        if (isCat3a) {
            // The title stays hidden
            if (title != null) {
                title.classList.add(HideClass);
                title.classList.add(Peek);
            }
            annotation.classList.remove("b_anim");
            // The scope bar stays hidden
            header.classList.add(HideClass);
            header.classList.add(Peek);
            // results stay hidden
            results.classList.add(Peek);
            for (var i = 0; i < resultsItems.length; i++) {
                var result = resultsItems[i];
                result.classList.add(HideClass);
            }
            for (var i = 0; i < messageModules.length; i++) {
                var messageModule = messageModules[i];
                if (messageModule !== recourseLink && messageModule !== feedbackBadge) {
                    messageModule.classList.add(HideClass);
                }
            }
            // pagination stays hidden
            if (pagination != null) {
                pagination.classList.add(HideClass);
            }
            // The footer stays hidden
            footer.classList.add(HideClass);
            footer.classList.add(Peek);
            // Wait for user to click the recourse link.
            sj_evt.bind("peekactivate", activatePeek, true);
        }
        else {
            // Hide the recourse link
            recourseLink.classList.add(HideClass);
            // Fade in the header, results, footer, etc.
            header.classList.add(Peek);
            content.classList.add(PeekExpand);
            results.classList.add(PeekExpand);
            results.classList.add(Peek);
            footer.classList.add(Peek);
        }
        // Clean up event binding
        sj_ue(_w, Load, showPeek);
    }
    if (content != null && results != null && header != null && recourseLink != null && footer != null) {
        // Because of timing and dimensions-related issues related to the browser itself sliding up from the bottom of the screen,
        // we should just hide the results until after we load and have a chance to properly set peek padding.
        sj_be(_w, Load, showPeek);
    }
    // background color needs to be applied before onload so the initial paint gets the right background for cat3a
    if (isCat3a) {
        _d.documentElement.classList.add(Peek);
        sj_b.classList.add(Peek);
    }
})(SearchPeek || (SearchPeek = {}));
;///<reference path="..\..\..\..\Shared\Content\Content\Script\Declarations\Shared.d.ts" />
///<reference path="Declarations\PageDebug.d.ts" />
/*
 * This module defines methods to set PageDebug properties.
 */
var Feedback;
(function (Feedback) {
    var DebugCollector;
    (function (DebugCollector) {
        'use strict';
        function GetPageDebug() {
            _w["PageDebug"] = (typeof _w["PageDebug"] !== "undefined") ? _w["PageDebug"] : {};
            return _w["PageDebug"];
        }
        function SetFederationDebugInfo(debugInfo) {
            if (debugInfo.length < 1)
                return;
            GetPageDebug().FederationDebugInfo = debugInfo;
        }
        DebugCollector.SetFederationDebugInfo = SetFederationDebugInfo;
    })(DebugCollector = Feedback.DebugCollector || (Feedback.DebugCollector = {}));
})(Feedback || (Feedback = {}));
;Feedback.DebugCollector.SetFederationDebugInfo('QueryID : f7a547f3e6d74bc6a2eb8bf3dae9edb9');;
//]]>--></div></div><script type="text/javascript">//<![CDATA[
_G.HT=new Date;
//]]></script><script type="text/javascript" data-rms="1">//@ sourceURL=BingDynamicScript0.js
//<![CDATA[
/// <reference path="../../../../Shared/Content/Content/script/Declarations/Shared.d.ts"/>
/// <reference path="../../../../Shared/Content/Content/script/Declarations/Threshold.Utilities.d.ts"/>
(function () {
    var kValueExtractionRegex = /ID=(\w+),(\d+(?:\.\d+)*)(&PR=(.*))?/i;
    function sendRequest(linkInfo, el, evt, typeOfClick) {
        if (linkInfo) {
            var gpingData = getGPingData(linkInfo, typeOfClick);
            var clickConfig = _w["ClickConfig"] || {};
            if (_w["Log2"]) {
                Log2.LogEvent(gpingData.eventType, gpingData.data, null, null, null, null, null, null);
                if (_w["ThresholdUtilities"]) {
                    var utilities = _w["ThresholdUtilities"];
                    utilities.uploadApiTimes("PCE");
                }
                if (clickConfig.ForceFlushOnClick || ((typeOfClick === 0) && clickLeavesPage())) {
                    // if we are leaving the page with this click we will flush all relevant logs
                    sj_evt.fire("visibility", document["hidden"]);
                    if (clickConfig.FlushSkipAbort) {
                        Log2.FlushMainQueueDontForce();
                    }
                    else {
                        Log2.ForceFlush();
                    }
                    _w["clickFlushedTime"] = sb_gt();
                }
            }
        }
    }
    _w["si_T"] = sendRequest;
    function clickLeavesPage() {
        if (_w.event && _w.event.srcElement) {
            var linkToCheck = _w.event.srcElement;
            while (!linkToCheck.href) {
                if (linkToCheck.parentElement) {
                    linkToCheck = linkToCheck.parentElement;
                }
                else {
                    // we have no further up to go, this means the user didn't click on a link
                    return false;
                }
            }
            if (linkToCheck.href.split("#")[0] !== _d.URL.split("#")[0]) {
                return true;
            }
        }
        return false;
    }
    function getGPingData(linkInfo, typeOfClick) {
        var matches = linkInfo.match(kValueExtractionRegex);
        if (matches) {
            var gpingData = {
                eventType: "Click",
                data: {
                    AppNS: matches[1],
                    K: matches[2],
                    Case: typeOfClick
                }
            };
            if (matches[4]) {
                gpingData.data.Properties = JSON.parse(matches[4]);
            }
            return gpingData;
        }
        throw new Error("hValue passed to click tracking was unable to be parsed: " + linkInfo);
    }
})();
;///<amd-module name="onHTML" />
define("onHTML", ["require", "exports", "event.custom"], function (require, exports, customEvents) {
    customEvents.fire("onHTML");
});
;///<reference path="Declarations\Shared.d.ts"/>
// Prevent zooming via ctrl + mousewheel
sj_be(_d, "mousewheel", function (evt) {
    if (evt.ctrlKey == true) {
        sj_pd(evt);
    }
});
// Prevent zooming via ctrl +/-
sj_be(_d, "keydown", function (evt) {
    if (evt.ctrlKey == true && (evt.keyCode == 107 || evt.keyCode == 109 || evt.keyCode == 187 || evt.keyCode == 189)) {
        sj_pd(evt);
    }
});
;///<reference path="Declarations\Shared.d.ts" />
/*
Instrumentation library for server and client powered apps in Windows smartsearch
Per this design, Server sets the visibility to false (v=0) on all the app links and client sends the Merge update through MergeInstruction format
setting v=1 on link being shown and also sends the Datasource merge event setting correct installstate of the app.
*/
var AppInst;
(function (AppInst) {
    var kValueExtractionRegex = /ID=([\w]+),([\d]+\.[\d]+)/i;
    var kValueNew = 1;
    AppInst.layoutJson = [];
    AppInst.datasourceJson = [];
    (function (InstallState) {
        InstallState[InstallState["Installed"] = 0] = "Installed";
        InstallState[InstallState["NotInstalled"] = 1] = "NotInstalled";
    })(AppInst.InstallState || (AppInst.InstallState = {}));
    var InstallState = AppInst.InstallState;
    // queues for submission or submits the instrumentation log for server powered apps in smartsearch
    function queueServerAppLog(hVisibleLayout, appInfoDsKValue, installState, hideIfNotInstalled, canSubmit) {
        if (canSubmit === void 0) { canSubmit = true; }
        var namespace = "";
        if (hVisibleLayout) {
            var matches = hVisibleLayout.match(kValueExtractionRegex);
            if (matches && matches.length >= 3) {
                // Store the namespace and K value.
                namespace = matches[1];
                var kValue = matches[2];
                if (installState !== 1 /* NotInstalled */ || !hideIfNotInstalled) {
                    AppInst.layoutJson.push({
                        "T": "L.MI",
                        "Action": "Update",
                        "AppNS": namespace,
                        "K": kValue,
                        "V": "1"
                    });
                }
            }
        }
        if (appInfoDsKValue) {
            AppInst.datasourceJson.push({
                "T": "D.MI",
                "Action": "Update",
                "AppNS": namespace,
                "K": appInfoDsKValue,
                "InstallState": getInstallStateString(installState)
            });
        }
        if (canSubmit) {
            submitLog();
        }
    }
    AppInst.queueServerAppLog = queueServerAppLog;
    function getInstallStateString(installState) {
        switch (installState) {
            case 0 /* Installed */:
                return "Installed";
            case 1 /* NotInstalled */:
                return "NotInstalled";
            default:
                return "Unknown";
        }
    }
    function getUniqueId() {
        return kValueNew++;
    }
    AppInst.getUniqueId = getUniqueId;
    // submits the instrumentation log in Merge instruction (MI) format.
    function submitLog() {
        var data = [];
        if (AppInst.layoutJson.length > 0) {
            data.push({
                "Page": AppInst.layoutJson
            });
            AppInst.layoutJson = [];
        }
        if (AppInst.datasourceJson.length > 0) {
            data.push(AppInst.datasourceJson);
            AppInst.datasourceJson = [];
        }
        if (data.length > 0) {
            postLog(JSON.stringify(data));
        }
    }
    AppInst.submitLog = submitLog;
    function postLog(data) {
        if (data) {
            if (_w["Log2"]) {
                Log2.LogEvent("ClientInst", JSON.parse(data), null, null, null, null, null, null);
            }
            else {
                // If ClientInstV2 is not supported
                var time = sb_gt();
                var payload = "<E><T>Event.ClientInst</T><IG>" + _G.IG + "</IG><TS>" + time + "</TS><D>" + data + "</D></E>";
                var xml = "<ClientInstRequest><Events>" + payload + "</Events><STS>" + time + "</STS></ClientInstRequest>";
                var request = sj_gx();
                request.open("POST", "/fd/ls/lsp.aspx", true);
                request.setRequestHeader("Content-Type", "text/xml");
                request.send(xml);
            }
        }
    }
})(AppInst || (AppInst = {}));
;///<reference path="..\Declarations\Shared.d.ts"/>
///<reference path="..\AppInst.ts"/>
// this module is used to initialize the Hose page to have app context sense
var AppApi;
(function (AppApi) {
    // Adds a handler for the specified control name
    function AddControlHandler(controlName, handler) {
        if (!controlHandlers[controlName]) {
            controlHandlers[controlName] = handler;
        }
    }
    AppApi.AddControlHandler = AddControlHandler;
    // The map of handlers for each control type
    var controlHandlers = {};
    // holding a cache of current page apps
    var pageApps = null;
    var instrumentationEnabled = typeof (AppInst) != 'undefined';
    // update app
    function updateApp(app) {
        if (pageApps && app) {
            var elements = pageApps[app.id];
            if (elements) {
                for (var i = 0; i < elements.length; ++i) {
                    updateAppElement(elements[i], app);
                }
            }
        }
    }
    // Invokes the control-specific handler
    function updateAppElement(element, app) {
        var hideIfNotInstalled = Boolean(element.getAttribute("data-hideIfNotInstalled"));
        if (instrumentationEnabled) {
            // Setting canSubmit to 'false' here so that single payload can be submitted later for all the Apps through explicit call to AppInst.SubmitLog function.
            var canSubmit = false;
            var installState = app.installed ? 0 /* Installed */ : 1 /* NotInstalled */;
            AppInst.queueServerAppLog(element.getAttribute("h"), element.getAttribute("data-appInfoDsK"), installState, hideIfNotInstalled, canSubmit);
        }
        var controlName = element.getAttribute("data-controlName");
        if (controlName) {
            var handler = controlHandlers[controlName];
            if (handler) {
                var minVersionStr = element.getAttribute("data-minVersion");
                var additionalPropsStr = element.getAttribute("data-additionalProps");
                var installedVersion = app.installedAppVersion ? stringToVersion(app.installedAppVersion) : null;
                var requiredMinVersion = minVersionStr ? stringToVersion(minVersionStr) : null;
                var eventArgs = {
                    appElement: element,
                    appInfo: app,
                    installedVersion: installedVersion,
                    requiredMinVersion: requiredMinVersion,
                    // if the min version is not specified, no update is needed
                    updateRequired: requiredMinVersion && installedVersion ? compareAppVersions(installedVersion, requiredMinVersion) < 0 : false,
                    updateAvailable: app.updateAvailable,
                    hideIfNotInstalled: hideIfNotInstalled,
                    additionalProps: null
                };
                try {
                    eventArgs.additionalProps = additionalPropsStr ? JSON.parse(additionalPropsStr) : null;
                    handler(eventArgs);
                }
                catch (ex) {
                    // Nothing we can do, really...
                    Log.Log("Error", "AppApi", "Handler_" + controlName, false, "Tx", ex.message);
                }
                if (app.installed && hideIfNotInstalled) {
                    // Show previously hidden apps
                    element.classList.remove('b_hide');
                }
            }
        }
    }
    // Reads the app from current page
    function readApps() {
        // We create the list of apps on first call to UpdateApp
        if (pageApps) {
            return;
        }
        pageApps = {};
        var dataAttr = "data-appid";
        // Scrape the DOM to get all the DOM Elements related to apps
        var appLinks = _d.querySelectorAll("[" + dataAttr + "]");
        for (var i = 0; i < appLinks.length; i++) {
            var appLink = appLinks[i];
            if (appLink) {
                // Get the value of data - appid attribute
                var appId = appLink.getAttribute(dataAttr);
                // If the app id is valid, then add it to the collection
                if (appId) {
                    var appElementList = pageApps[appId];
                    if (appElementList) {
                        // add it to the existing collection
                        appElementList.push(appLink);
                    }
                    else {
                        // create a new list to hold apps
                        pageApps[appId] = [appLink];
                    }
                }
            }
        }
    }
    // Make an element a launch link with proper instrumentation
    function setLaunchLink(targetElement, appElement, appId, launchUrl) {
        targetElement.setAttribute("href", launchUrl);
        // This code sets proper instrumentation attribute on the launch link
        // We cannot have two identical apps within the same DOM element, for example in the same pivot. We can have two
        // identical apps on different pivots, e.g. OpenTable on About and Apps, however they will have different K values
        // so we need to select the correct sibling element which contains the launch K value to use.
        var siblingInstElement = querySelector(appElement.parentElement, "[data-launchappid='" + appId + "']");
        if (siblingInstElement) {
            var hAttr = "h";
            // data-inst will only be present behind FD
            var hValue = siblingInstElement.getAttribute(hAttr);
            if (hValue && hValue.length > 0) {
                targetElement.setAttribute(hAttr, hValue);
            }
        }
    }
    AppApi.setLaunchLink = setLaunchLink;
    function instrumentUpgradeLink(appElement) {
        // If upgrade link is instrumented with it's own InstLink and h value, then set that to be the h value of rendered link.
        // This is currently applicable for Windows app links which use separate link for upgrade state.
        var upgradeLinkElement = querySelector(appElement.parentElement, "[data-linkRole='Upgrade']");
        if (upgradeLinkElement) {
            var hUpgradeLink = upgradeLinkElement.getAttribute("h");
            if (hUpgradeLink) {
                appElement.setAttribute("h", hUpgradeLink);
            }
        }
    }
    AppApi.instrumentUpgradeLink = instrumentUpgradeLink;
    // Shell will call this method to update app info with app list
    // This function name and its namespace can't be changed.
    function UpdateAppInfo(apps) {
        if (apps) {
            // This will only read the app element list once, caching it for all subsequent calls
            readApps();
            for (var i = 0; i < apps.length; ++i) {
                updateApp(apps[i]);
            }
        }
        // At this point, we have enqueued the logs for all the app links through AppInst.queueServerAppLog function calls.
        // For perf reasons, we submit them all at once in single payload through the following function call.
        if (instrumentationEnabled) {
            AppInst.submitLog();
        }
    }
    AppApi.UpdateAppInfo = UpdateAppInfo;
    function stringToVersion(versionStr) {
        return versionStr.split('.').map(function (s) { return Number(s); });
    }
    // Version comparison function
    function compareAppVersions(version1, version2) {
        var commonLength = Math.min(version1.length, version2.length);
        for (var i = 0; i < commonLength; i++) {
            var diff = version1[i] - version2[i];
            if (diff != 0) {
                return diff;
            }
        }
        // The longer version number is considered greater
        return version1.length - version2.length;
    }
    function querySelector(element, query) {
        return element.querySelector(query);
    }
})(AppApi || (AppApi = {}));
;// ------------------------------------------------------------------------------
// <copyright file="SmartSearch.Navigation.ts" company="Microsoft Corporation">
//     Copyright (c) Microsoft Corporation. All Rights Reserved.
//     Information Contained Herein is Proprietary and Confidential.
// </copyright>
// ------------------------------------------------------------------------------
///<reference path="..\..\..\..\Shared\Content\Content\script\Declarations\Shared.d.ts"/>
///<reference path="..\..\..\..\Shared\Content\Content\Script\Declarations\Threshold.Utilities.d.ts" />
///<reference path="SearchApp.Mock.ts" />
///<reference path="Declarations\CortanaEnums.d.ts" />
var CachedDeviceItems = {};
var SmartSearch;
(function (SmartSearch) {
    var cortanaApp = SearchAppWrapper.CortanaApp;
    var _supportedPaths = null;
    var baseProtocol = null;
    var baseHostname = null;
    var launchApiAllowedLatency = 100;
    var apiNameAbbreviator = /(^.)|([A-Z])/g;
    function isSupportedPath(path, search) {
        var supportedPathsCollection = getSupportedPaths();
        path = cleanPath(path);
        // Cut off the leading ? in the search parameters
        if (search && search.substring) {
            search = search.substring(1);
        }
        // A path is supported if it's not blocked and there is a supported path for it
        // Check block lists first as they should be shorter
        return (!isPathSatisfied(supportedPathsCollection.Blocked, path, search) && isPathSatisfied(supportedPathsCollection.Supported, path, search));
    }
    SmartSearch.isSupportedPath = isSupportedPath;
    /// Called by test code to reset cached state between tests
    function reset() {
        _supportedPaths = null;
    }
    SmartSearch.reset = reset;
    function cleanPath(path) {
        var cleanPath = path;
        if (cleanPath) {
            var cleanPath = cleanPath.toLowerCase();
            var cutIndex = -1;
            for (var i = 0; i < cleanPath.length && cleanPath[i] === "/"; i++) {
                cutIndex = i;
            }
            if (cutIndex >= 0) {
                cleanPath = cleanPath.substring(cutIndex + 1);
            }
        }
        return cleanPath;
    }
    function getSupportedPaths() {
        if (!_supportedPaths) {
            var thresholdConfig = _TC;
            if (thresholdConfig) {
                var supportedPaths = null;
                var blockedPaths = null;
                if (thresholdConfig.SP) {
                    supportedPaths = parsePathList(thresholdConfig.SP);
                }
                if (thresholdConfig.BP) {
                    blockedPaths = parsePathList(thresholdConfig.BP);
                }
                _supportedPaths = { Supported: supportedPaths, Blocked: blockedPaths };
            }
        }
        return _supportedPaths;
    }
    function isPathSatisfied(supportedPathsMap, path, search) {
        for (var i in supportedPathsMap) {
            if (path.indexOf(i) >= 0) {
                var requiredParameters = supportedPathsMap[i];
                var allParametersPresent = true;
                // Check if this path requires specific querystring parameters
                if (requiredParameters.length > 0) {
                    // If we require some parameters we assume we don't have them until we succeed with parsing
                    allParametersPresent = false;
                    if (search) {
                        var parsedPathParameters = cleanArray(search.split("&"));
                        // If we require some parameters and have parameters in the input path then we assume we've got what we need until we find a parameter is missing
                        allParametersPresent = parsedPathParameters.length >= requiredParameters.length;
                        if (allParametersPresent) {
                            for (var requiredParameterIndex in requiredParameters) {
                                if (parsedPathParameters.indexOf(requiredParameters[requiredParameterIndex]) < 0) {
                                    // We've failed to find a required parameter, so we know this is not a match
                                    allParametersPresent = false;
                                    break;
                                }
                            }
                        }
                    }
                }
                // We found all required parameters or there were no required parameters.  This is a match.
                if (allParametersPresent) {
                    return true;
                }
            }
        }
        return false;
    }
    function parsePathList(supportedPaths) {
        var parsedPaths = {};
        supportedPaths = supportedPaths.toLowerCase();
        var supportedFullPaths = supportedPaths.split(",");
        var defaultRequiredQueryStrings = [];
        for (var supportedFullPathIndex in supportedFullPaths) {
            var pathAndQuery = cleanArray(supportedFullPaths[supportedFullPathIndex].split("?"));
            var requiredQueryStrings = defaultRequiredQueryStrings;
            if (pathAndQuery.length > 1) {
                requiredQueryStrings = cleanArray(pathAndQuery[1].split("&"));
            }
            parsedPaths[cleanPath(pathAndQuery[0])] = requiredQueryStrings;
        }
        return parsedPaths;
    }
    function cleanArray(inputArray) {
        var returnValue = inputArray;
        if (inputArray) {
            var startIndex = 0;
            var foundItemToClean = false;
            for (var i = startIndex; i < inputArray.length; i++) {
                if (!inputArray[i]) {
                    if (!foundItemToClean) {
                        returnValue = [];
                        foundItemToClean = true;
                    }
                    if (i > startIndex) {
                        returnValue.push.apply(returnValue, inputArray.slice(startIndex, i));
                    }
                    startIndex = i + 1;
                }
            }
        }
        return returnValue;
    }
    function signalComplete() {
        sj_evt.fire("NavigationComplete");
    }
    function navigateTo(targetElement, event) {
        var preventDefault = true;
        // Check if target element link is internal or external
        if (targetElement) {
            var searchUtils = ThresholdUtilities;
            var destinationPath = targetElement.pathname;
            var destinationHostname = getHostname(targetElement);
            var destinationProtocol = targetElement.protocol;
            var destinationSearch = targetElement.search;
            var destinationHash = targetElement.hash;
            if (!baseHostname || !baseProtocol) {
                getBaseUrl();
            }
            var destinationLink = targetElement.href;
            // If the link is really a javascript invocation (like "javascript:void(0)"), bail out.
            if (destinationProtocol.toLowerCase() === "javascript:") {
                return;
            }
            if (destinationPath.toLowerCase() === _w.location.pathname.toLowerCase() && destinationSearch.toLowerCase() === _w.location.search.toLowerCase() && destinationHash.toLowerCase() === _w.location.hash.toLowerCase()) {
                SharedLogHelper.LogWarning("SelfNavigate");
            }
            else if (destinationLink) {
                if (!destinationHostname) {
                    destinationHostname = baseHostname; // automatically accquire current domain for relative links
                }
                // Determine if a link is relative.
                // Handle a weird case where the url is ms-windows-store:PDP?PFN=..., no host, and "ms-windows-store:" protocol
                var isRelative = (!destinationProtocol || destinationProtocol.indexOf("http") === 0) && (destinationHostname === baseHostname || destinationHostname === getHostname(location));
                var urlType = getUrlType(destinationPath, destinationSearch, destinationHostname, isRelative);
                var launcher = cortanaApp.launcher;
                switch (urlType) {
                    case 5 /* Search */:
                    case 3 /* Navigation */:
                        if (isRelative) {
                            rebaseLink(targetElement);
                            // Need to refresh after changing the link properties
                            destinationLink = targetElement.href;
                        }
                        if (urlType === 5 /* Search */) {
                            // Force Cat3b (search)
                            var joiningChar = destinationLink.indexOf("?") === -1 ? "?" : "&";
                            destinationLink += joiningChar + "persona=0";
                        }
                        var navigateWebViewFunctionName = "navigateWebViewAsync";
                        var launchWebContentFunctionName = "launchWebContent";
                        var thresholdConfig = _TC;
                        if (thresholdConfig && thresholdConfig.NW && launcher[launchWebContentFunctionName]) {
                            var launchOptions = launcher.createWebContentLaunchOptions();
                            launchOptions.uri = destinationLink;
                            searchUtils.wrapSynchronousApiCall(launcher, launchWebContentFunctionName, createInstrumentationKey(launchWebContentFunctionName), null, launchOptions);
                            signalComplete();
                        }
                        else if (cortanaApp[navigateWebViewFunctionName]) {
                            searchUtils.wrapApiCallWithTimeout(cortanaApp, navigateWebViewFunctionName, createInstrumentationKey(navigateWebViewFunctionName), destinationLink, launchApiAllowedLatency, null, destinationLink).done(signalComplete);
                        }
                        else {
                            // We're in charge of the actual navigation
                            preventDefault = false;
                        }
                        break;
                    case 0 /* App */:
                        var options = null;
                        var appContext = targetElement.getAttribute("data-appcontext");
                        if (appContext) {
                            options = launcher.createAppLaunchOptions();
                            options.appContext = appContext;
                        }
                        var itemId = targetElement.getAttribute("data-appid");
                        if (itemId) {
                            var itemSource = targetElement.getAttribute("data-source");
                            var deviceItem = CachedDeviceItems[itemId + ":" + itemSource];
                            if (deviceItem) {
                                var launchSearchItemAsyncPromise;
                                var functionName = "launchSearchItemAsync";
                                if (options) {
                                    launchSearchItemAsyncPromise = searchUtils.wrapApiCallWithTimeout(launcher, functionName, createInstrumentationKey(functionName), deviceItem.id, launchApiAllowedLatency, null, deviceItem, options);
                                }
                                else {
                                    launchSearchItemAsyncPromise = searchUtils.wrapApiCallWithTimeout(launcher, functionName, createInstrumentationKey(functionName), deviceItem.id, launchApiAllowedLatency, null, deviceItem);
                                }
                                launchSearchItemAsyncPromise.done(signalComplete);
                            }
                            else {
                                var itemType = targetElement.getAttribute("data-itemtype");
                                var functionName = itemType && itemType === "settings" ? "findSettingsAsync" : "findAppsAsync";
                                searchUtils.wrapApiCallWithTimeout(cortanaApp.searchResultsView.deviceSearch, functionName, createInstrumentationKey(functionName), "Navigation", launchApiAllowedLatency, null, [itemId]).then(sj_df(launchFirstFoundItem, options));
                            }
                        }
                        break;
                    case 4 /* Experience */:
                        var experienceName = targetElement.getAttribute("data-experiencename");
                        if (experienceName) {
                            SearchAppWrapper.CortanaApp.launchExperienceByName(experienceName, null);
                        }
                        break;
                    case 2 /* Explore */:
                        var destination = targetElement.getAttribute("data-dest");
                        if (destination) {
                            var provider = targetElement.getAttribute("data-provider");
                            if (provider) {
                                launcher.launchSearchInApp(destination, ThresholdUtilities.getDecodedQuery(_w.location.toString()), provider);
                            }
                            else {
                                launcher.launchSearchInApp(destination, ThresholdUtilities.getDecodedQuery(_w.location.toString()));
                            }
                            signalComplete();
                        }
                        break;
                    case 1 /* Web */:
                        if (isRelative) {
                            rebaseLink(targetElement);
                            // Need to refresh after changing the link properties
                            destinationLink = targetElement.href;
                            // Instrument the time of the click to allow us to join the impressions. These requests are from two
                            // different apps, so will be seen as 2 different users, making it difficult to measure e2e perf from
                            // app click to browser page load without this query param.
                            var joiningChar = destinationLink.indexOf("?") === -1 ? "?" : "&";
                            destinationLink += joiningChar + "ts=" + sb_gt();
                            if (_G.nclid) {
                                destinationLink += "&nclid=" + _G.nclid;
                            }
                        }
                        var functionName = "launchUriAsync";
                        searchUtils.wrapApiCallWithTimeout(launcher, functionName, createInstrumentationKey(functionName), "Navigation", launchApiAllowedLatency, null, destinationLink).then(signalComplete);
                        break;
                }
            }
        }
        if (event && preventDefault) {
            event.preventDefault();
        }
    }
    ;
    function createInstrumentationKey(apiName) {
        return apiName.match(apiNameAbbreviator).join("").toUpperCase();
    }
    function launchFirstFoundItem(result, options) {
        if (result != null) {
            for (var i in result) {
                var currentResult = result[i];
                // This check seems unecessary, but the mapping returned maps IDs to empty objects when it fails to find it on the machine.
                if (currentResult && currentResult.id) {
                    var functionName = "launchSearchItemAsync";
                    ThresholdUtilities.wrapApiCallWithTimeout(SearchAppWrapper.CortanaApp.launcher, functionName, createInstrumentationKey(functionName), null, launchApiAllowedLatency, null, currentResult, options).then(signalComplete);
                    break;
                }
            }
        }
    }
    function getUrlType(destinationPath, destinationSearch, destinationHostname, isRelative) {
        if (isRelative && isSupportedPath(destinationPath, destinationSearch)) {
            // This is a requery on search
            if (destinationPath === "search" || destinationPath === "/search") {
                return 5 /* Search */;
            }
            // This is a navigation link to another bing page
            return 3 /* Navigation */;
        }
        else if (destinationHostname === "ms-smartsearch") {
            if (destinationPath === "app" || destinationPath === "/app") {
                return 0 /* App */;
            }
            else if (destinationPath === "searchInApp" || destinationPath === "/searchInApp") {
                return 2 /* Explore */;
            }
            else if (destinationPath === "experience" || destinationPath === "/experience") {
                return 4 /* Experience */;
            }
        }
        // Any other links should be launched in browser.
        return 1 /* Web */;
    }
    ;
    function onClickHandler(evt) {
        if (!evt.defaultPrevented) {
            var element = evt.target;
            var targetElement = getParentContainer(element, "A");
            if (targetElement) {
                navigateTo(targetElement, evt);
            }
        }
    }
    ;
    function getParentContainer(target, tagName) {
        for (; target && target !== document; target = target.parentNode) {
            if (target.tagName === tagName) {
                return target;
            }
        }
    }
    ;
    function getBaseUrl() {
        if (_w["_TH_BU"]) {
            var baseUrlPieces = _TH_BU.split("//", 2);
            if (baseUrlPieces.length === 2) {
                baseProtocol = baseUrlPieces[0];
                baseHostname = baseUrlPieces[1];
                return;
            }
        }
        baseProtocol = location.protocol;
        baseHostname = getHostname(location);
    }
    function rebaseLink(element) {
        element.protocol = baseProtocol;
        element.hostname = baseHostname;
        element.port = baseProtocol === "https:" ? "443" : "80";
    }
    function getHostname(element) {
        if (!element) {
            return null;
        }
        var hostname = element.hostname;
        if (!hostname) {
            return null;
        }
        // Microsoft Edge drops the [ ] for IPv6 urls, and we cannot actually navigate to IPv6 hosts without them.
        // Add them if they're missing.
        if (hostname.indexOf(":") >= 0 && hostname.indexOf("[") < 0) {
            hostname = "[" + hostname + "]";
        }
        return hostname;
    }
    sj_be(_w, "click", onClickHandler);
    var UrlType;
    (function (UrlType) {
        UrlType[UrlType["App"] = 0] = "App";
        UrlType[UrlType["Web"] = 1] = "Web";
        UrlType[UrlType["Explore"] = 2] = "Explore";
        UrlType[UrlType["Navigation"] = 3] = "Navigation";
        UrlType[UrlType["Experience"] = 4] = "Experience";
        UrlType[UrlType["Search"] = 5] = "Search";
    })(UrlType || (UrlType = {}));
})(SmartSearch || (SmartSearch = {}));
;// ------------------------------------------------------------------------------
// <copyright file="SmartSearch.ts" company="Microsoft Corporation">
//     Copyright (c) Microsoft Corporation. All Rights Reserved.
//     Information Contained Herein is Proprietary and Confidential.
// </copyright>
// ------------------------------------------------------------------------------
///<reference path="..\..\..\..\Shared\Content\Content\script\Declarations\AppApi.d.ts"/>
///<reference path="..\..\..\..\Shared\Content\Content\script\Declarations\Shared.d.ts"/>
///<reference path="..\..\..\..\Shared\Content\Content\Script\Declarations\Threshold.Utilities.d.ts" />
///<reference path="SmartSearch.Navigation.ts"/>
///<reference path="SearchApp.Mock.ts"/>
(function () {
    var appIdAttribute = "data-appid";
    if (typeof AppApi === "undefined" || !AppApi.UpdateAppInfo || !SearchAppWrapper.CortanaApp.searchResultsView) {
        return;
    }
    // Get app ids
    var appIds = [];
    var appLinks = document.querySelectorAll("[" + appIdAttribute + "]");
    for (var i = 0; i < appLinks.length; i++) {
        var appId = appLinks[i].getAttribute(appIdAttribute);
        if (appIds.indexOf(appId) < 0) {
            appIds.push(appId);
        }
    }
    var processApplicationMap = function (results) {
        var apps = [];
        for (var index in appIds) {
            var appId = appIds[index];
            if (results.hasKey(appId)) {
                var item = results[appId];
                if (item) {
                    var app = {
                        id: appId,
                        installedAppVersion: item.version,
                        installed: true
                    };
                    apps.push(app);
                    if (CachedDeviceItems && !CachedDeviceItems[appId]) {
                        CachedDeviceItems[appId] = item;
                    }
                }
            }
        }
        AppApi.UpdateAppInfo(apps);
        ThresholdUtilities.uploadApiTimes("ALR");
    };
    // Check the app install state and update app info, only if we have some apps to check
    if (appIds.length > 0) {
        ThresholdUtilities.wrapApiCall(SearchAppWrapper.CortanaApp.searchResultsView.deviceSearch, "findAppsAsync", "AL", "AppLinking", appIds).then(processApplicationMap);
    }
})();
;// sets a session cookie crumb with the browser's inner width and height, and the device pixel ratio
(function () {
    function setCW() {
        var clientSizeCookie = "SRCHHPGUSR";
        var cwCookie = sj_cook.get(clientSizeCookie, "CW");

        if (!cwCookie || (window.sj_b && cwCookie != sj_b.clientWidth)) {
            sj_cook.set(clientSizeCookie, "CW", sb_de.clientWidth || sj_b.clientWidth, 1, "/");
        }

        var chCookie = sj_cook.get(clientSizeCookie, "CH");
        if (!chCookie || chCookie != sb_de.clientHeight) {
            sj_cook.set(clientSizeCookie, "CH", sb_de.clientHeight, 1, "/");
        }

        var dprCookie = sj_cook.get(clientSizeCookie, "DPR");
        if (typeof _w.devicePixelRatio !== 'undefined' && (!dprCookie || dprCookie != _w.devicePixelRatio)) {
            sj_cook.set(clientSizeCookie, "DPR", _w.devicePixelRatio, 1, "/");
        }
    }
    sj_be(_w, "load", setCW);
    sj_be(_w, "resize", setCW);
})();;/// <reference path="..\..\..\..\Shared\Content\Content\Script\Declarations\Shared.d.ts" />
/// <reference path='..\..\..\..\Shared\Content\Content\Script\Declarations\Threshold.Utilities.d.ts' />
/// <reference path="..\..\..\..\Threshold\src\Content\Script\Declarations\SearchAppWrapper.d.ts" />
(function () {
    if (SearchAppWrapper && SearchAppWrapper.CortanaApp) {
        var languageGenerationElement = _d.querySelector(".b_cat3a div[data-ssml]");
        if (languageGenerationElement) {
            ThresholdUtilities.wrapSynchronousApiCall(SearchAppWrapper.CortanaApp, "respond", null, "respond", languageGenerationElement.getAttribute("data-ssml"), languageGenerationElement.getAttribute("data-postssmlaction"), languageGenerationElement.getAttribute("data-secondarytext-small"), languageGenerationElement.getAttribute("data-secondarytext-medium"), languageGenerationElement.getAttribute("data-secondarytext-large"));
        }
        var emotionElement = _d.querySelector(".b_cat3a div[data-emot]");
        if (emotionElement) {
            ThresholdUtilities.wrapSynchronousApiCall(SearchAppWrapper.CortanaApp, "setEmotion", null, "setEmotion", emotionElement.getAttribute("data-emot"), emotionElement.getAttribute("data-emot-size") == "large", emotionElement.hasAttribute("data-emot-overridespeaking"));
        }
    }
})();
;CUDialog.sendAction({"CuAction":"{\"Uri\":\"action://CuOutput\",\"SystemAction\":{\"Reminder\":{\"Condition\":\"None\",\"Title\":{\"Value\":\"记住我的车停在楼下\",\"ProfanityMasked\":\"记住我的车停在楼下\",\"Uri\":\"entity://TextData\",\"Version\":\"2.0\"},\"Uri\":\"entity://Reminder\",\"Version\":\"2.0\"},\"Uri\":\"action://Reminder/Create\",\"Version\":\"2.0\"},\"ConversationId\":\"9ff16d5b-4ccc-9b84-c9e5-75cfe69e8aaf\",\"TraceId\":\"04D81438156E457FB07546DC975522CE\",\"ImpressionId\":\"c6310a13bb7957fbc90e66b4e705fd78\",\"LgObject\":{\"Uri\":\"action://LgObject\",\"Ssml\":null,\"DisplayText\":null,\"SuggestionText\":null,\"SecondaryDisplayTextSmall\":null,\"SecondaryDisplayTextMedium\":null,\"SecondaryDisplayTextLarge\":null}}"});;(function () {
    function Promote() {
        var isBingSE = _w["isBingCurrentSearchDefault"];
        var setSE = _w["setBingCurrentSearchDefault"];
        if (setSE && isBingSE) {
            var promptNow = false;
            var currDate = new Date();
            if (typeof (Storage) !== "undefined" && _w.localStorage) {
                var tempFlagData = localStorage.getItem("lastSEPromptShownFlag");
                if (tempFlagData != null && tempFlagData != "false") {
                    if (isBingSE() == false) {
                        Log.Log("SetSE", "SetSE", "setBingCurrentSearchDefault", true, "PSE", "Non-Bing", "SE", "Non-Bing", "UA", "Denied");
                    }
                    else {
                        Log.Log("SetSE", "SetSE", "setBingCurrentSearchDefault", true, "PSE", "Non-Bing", "SE", "Bing", "UA", "Accepted");
                    }
                    localStorage.setItem("lastSEPromptShownFlag", false);
                }
                if (!localStorage.getItem("lastSEPromptDate")) {
                    promptNow = true;
                }
                else {
                    if (currDate.getTime() - new Date(localStorage.getItem("lastSEPromptDate")).getTime() > 1000 * 60 * 60 * 24 * 7) {
                        promptNow = true;
                    }
                    else {
                        promptNow = false;
                    }
                }
            }
            if (promptNow && isBingSE() == false) {
                try {
                    localStorage.setItem("lastSEPromptDate", currDate);
                    localStorage.setItem("lastSEPromptShownFlag", true);
                    var result = setSE();
                }
                catch (err) {
                    promptNow = false;
                }
            }
        }
    }
    sj_be(_w, "load", Promote);
})();
;// this module defines some basic accessibility helpers
var AccessibilityHelpers;
(function (AccessibilityHelpers) {
    // Not Perfect, but there is no standard property for focusable elements
    var focusableItemsSelector = 'a[href], body, input, select, [tabindex]';
    function FocusNextFocusableElement() {
        if (_d.querySelectorAll && _d.activeElement) {
            var selectElements = _d.querySelectorAll(focusableItemsSelector);
            // Items with display:none, and tabIndex="-1" are not focusable
            var focusableElements = [];
            for (var i = 0; i < selectElements.length; i++) {
                var curItem = selectElements.item(i);
                if (curItem && curItem.tabIndex != -1 && window.getComputedStyle(curItem).display != "none") {
                    focusableElements.push(curItem);
                }
            }
            var currentlyFocusedIndex = focusableElements.indexOf(_d.activeElement);
            if (typeof (sj_log) != "undefined") {
                // Since our selector is supposed to encompass all focusable elements, the currently focused element
                // should always appear in this list.  But this behavior can differ from browser to browser, and I want to catch
                // instances where the element isn't found, so I can tweak my selector
                sj_log("CI.MoveFocus", "Next", _d.activeElement.tagName + " " + currentlyFocusedIndex.toString());
            }
            focusableElements[currentlyFocusedIndex + 1 % focusableElements.length].focus();
        }
    }
    AccessibilityHelpers.FocusNextFocusableElement = FocusNextFocusableElement;
})(AccessibilityHelpers || (AccessibilityHelpers = {}));
;///<reference path="Declarations\Shared.d.ts" />
///<reference path="Declarations\CssClass.d.ts" />
// this module defines the script working for expansion item
var expitem;
(function (expitem) {
    var items = {};
    var hiddenOnExpansionAttribute = "data-hoe";
    var inversionAttribute = "inversion";
    var transitionEndEventName = getTransitionEndEventName();
    var scrollbarWidth = getScrollbarWidth();
    // toggle visible state of managed items
    function toggle(p) {
        if (!p.collapsible) {
            hideItem(p);
        }
        var toCollapse = isExpanded(p);
        var exp = _ge(p.id);
        if (p.scrollBackOnCollapse) {
            if (toCollapse) {
                p.topInViewportBeforeCollapse = getTopInViewport(exp);
                p.bodyHeightBelowViewportBeforeCollapse = _d.body.scrollHeight - getBodyScrollTop() - getViewportHeight();
                if (hasHorizontalScrollbar()) {
                    p.bodyHeightBelowViewportBeforeCollapse += scrollbarWidth;
                }
            }
            else {
                p.topInViewportBeforeExpand = getTopInViewport(exp);
                p.bodyHeightBeforeExpand = _d.body.scrollHeight;
                p.answerContainerHeightBeforeExpand = p.answerContainer.clientHeight;
            }
        }
        for (var i = 0; i < p.turnable.length; i++) {
            var node = p.turnable[i];
            if (p.animationEnabled) {
                toggleSlide(p, node);
            }
            else {
                var inversion = node.getAttribute(inversionAttribute) === "1";
                if (inversion) {
                    var removeHideClass = toCollapse === inversion;
                    removeHideClass ? Lib.CssClass.add(node, 'b_hide') : Lib.CssClass.remove(node, 'b_hide');
                }
                else {
                    var hideNodeOnExpansion = node.getAttribute(hiddenOnExpansionAttribute) === "1";
                    var removeHideClass = toCollapse != hideNodeOnExpansion;
                    removeHideClass ? Lib.CssClass.add(node, 'b_hide') : Lib.CssClass.remove(node, 'b_hide');
                }
            }
        }
        for (i = 0; i < p.movable.length; i++) {
            move(p, p.movable[i], toCollapse, p.animationEnabled);
        }
        for (i = 0; i < p.exclusive.length; i++) {
            var pair = p.exclusive[i];
            if (pair.length != 2) {
                continue;
            }
            swap(pair);
        }
        for (i = 0; i < p.buffer.length; i++) {
            // flush out
            node = p.buffer[i];
            for (var j = 0; j < node.childNodes.length; j++) {
                node.parentNode.insertBefore(node.childNodes[i], node);
            }
        }
        p.state++;
        var disableAnswerSideScrollBackWhenCollapse = p.scrollBackOnCollapse;
        sj_evt.fire('exptoggle', p.id, toCollapse, disableAnswerSideScrollBackWhenCollapse);
        if (p.scrollBackOnCollapse) {
            if (toCollapse) {
                updatePage(p);
            }
            else {
                updateExpansionHeight(p);
            }
        }
        // log the instrumentation
        Log.Log(toCollapse ? "Hide" : "Show", p.logArea, p.logName, false, "AppNS", exp.getAttribute("data-appns"), "K", exp.getAttribute("data-k"));
    }
    // hide current expansion item itself
    function hideItem(p) {
        setDisplayOfItem(p, 'none');
    }
    // show current expansion item itself
    function showItem(p) {
        setDisplayOfItem(p, '');
    }
    function setDisplayOfItem(p, display) {
        var anchor = _ge(p.id);
        if (!anchor) {
            return;
        }
        var par = anchor.parentNode;
        /*There may be padding specified in the parent 'sml' class (used in ExpansionItem) which needs to be hidden.  */
        if (par.className == 'sml' || par.className == 'btm_sml') {
            par.style.display = display;
        }
        else {
            anchor.style.display = display;
        }
    }
    function swap(pair) {
        if (pair.length !== 2) {
            return;
        }
        var temp = sj_ce("div");
        moveAll(pair[0], temp);
        moveAll(pair[1], pair[0]);
        moveAll(temp, pair[1]);
    }
    // move all children from one element to another
    function moveAll(elem1, elem2) {
        while (elem1.childNodes.length > 0) {
            elem2.appendChild(elem1.childNodes[0]);
        }
    }
    // move all elements managed by an movable entry
    function getMovableChildren(entry, forceRefresh) {
        var movableChildrenProperty = 'movech';
        var movableChildren = entry[movableChildrenProperty];
        if (!movableChildren || forceRefresh) {
            movableChildren = [];
            var childNodes = entry.childNodes;
            if (childNodes) {
                for (var i = 0; i < childNodes.length; i++) {
                    movableChildren.push(childNodes[i]);
                }
            }
            entry[movableChildrenProperty] = movableChildren;
        }
        return movableChildren;
    }
    function toggleOnEndForMovableEntry(entry) {
        Lib.CssClass.add(entry, "b_hide");
        var movableChildren = getMovableChildren(entry, true);
        for (var i = 0; i < movableChildren.length; i++) {
            var child = movableChildren[i];
            entry.parentNode.insertBefore(child, entry);
        }
    }
    function move(p, entry, toCollapse, enableAnimation) {
        var movableChildren;
        var child;
        var i;
        if (enableAnimation) {
            if (toCollapse) {
                Lib.CssClass.remove(entry, "b_hide");
                movableChildren = getMovableChildren(entry, false);
                for (i = 0; i < movableChildren.length; i++) {
                    child = movableChildren[i];
                    entry.appendChild(child);
                }
                toggleSlide(p, entry);
            }
            else {
                // disable padding, margin to avoid impact from other CSS rules when removing "b_hide" 
                Lib.CssClass.add(entry, "hidden_nostyle");
                toggleSlide(p, entry, toggleOnEndForMovableEntry);
            }
        }
        else {
            movableChildren = getMovableChildren(entry, !toCollapse);
            for (i = 0; i < movableChildren.length; i++) {
                child = movableChildren[i];
                if (toCollapse) {
                    entry.appendChild(child);
                }
                else {
                    entry.parentNode.insertBefore(child, entry);
                }
            }
        }
    }
    function updateExpansionHeight(p) {
        p.expansionHeight = p.answerContainer.clientHeight - p.answerContainerHeightBeforeExpand;
        p.bodyExpansionHeight = _d.body.scrollHeight - p.bodyHeightBeforeExpand;
    }
    // there might be enough content below viewport for this to collapse
    // so window scroll differently in this special case
    function updatePage(p) {
        if (p.expansionHeight != p.bodyExpansionHeight) {
            return;
        }
        pageScrollWithEqualHeight(p);
    }
    function pageScrollWithEqualHeight(p) {
        var offsetY = 0;
        var marginTop = 0;
        if (p.topInViewportBeforeCollapse <= p.topInViewportBeforeExpand) {
            if (p.expansionHeight <= p.bodyHeightBelowViewportBeforeCollapse) {
                offsetY = -p.expansionHeight;
            }
            else {
                offsetY = -p.bodyHeightBelowViewportBeforeCollapse;
            }
            marginTop = p.expansionHeight;
        }
        else {
            var topAfterCollapse = p.topInViewportBeforeCollapse - p.expansionHeight;
            if (p.expansionHeight <= p.bodyHeightBelowViewportBeforeCollapse) {
                offsetY = topAfterCollapse - p.topInViewportBeforeExpand;
            }
            else {
                offsetY = p.topInViewportBeforeCollapse - p.bodyHeightBelowViewportBeforeCollapse - p.topInViewportBeforeExpand;
            }
            marginTop = -(topAfterCollapse - p.topInViewportBeforeExpand);
        }
        pageScroll(p, offsetY, marginTop);
    }
    function pageScroll(p, offsetY, marginTop) {
        if (!p.animationEnabled || !p.inAnimation) {
            _w.scrollBy(0, offsetY);
            return;
        }
        Lib.CssClass.add(_d.body, "exp_scroll");
        forceStyleUpdate(_d.body);
        _d.body.style.marginTop = marginTop + "px";
        function resetPage() {
            sj_ue(_d.body, transitionEndEventName, resetPage);
            Lib.CssClass.remove(_d.body, "exp_scroll");
            forceStyleUpdate(_d.body);
            _d.body.style.marginTop = "";
            _w.scrollBy(0, offsetY);
        }
        sj_be(_d.body, transitionEndEventName, resetPage);
    }
    function toggleSlide(p, node, onEnd) {
        if (onEnd === void 0) { onEnd = null; }
        p.inAnimation = true;
        setHeight(node);
        forceStyleUpdate(node);
        Lib.CssClass.add(node, "exp_slide");
        forceStyleUpdate(node);
        Lib.CssClass.toggle(node, "b_hide");
        var toExpand = !isExpanded(p);
        function slideEndHandler(event) {
            if (event.target != node) {
                return;
            }
            sj_ue(node, transitionEndEventName, slideEndHandler);
            Lib.CssClass.remove(node, "exp_slide");
            node.style.height = "";
            if (onEnd) {
                onEnd(node);
            }
            // calculate expansion height when expanding this
            if (toExpand && p.scrollBackOnCollapse) {
                updateExpansionHeight(p);
            }
            p.inAnimation = false;
        }
        sj_be(node, transitionEndEventName, slideEndHandler);
    }
    function wireupAll() {
        var dataExp = "data-exp";
        var nodes = null;
        if (_d.querySelectorAll) {
            nodes = _d.querySelectorAll("[" + dataExp + "]");
        }
        else {
            nodes = _d.getElementsByTagName("*");
        }
        for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            if (node.getAttribute) {
                if (_w["progressiveLoad"] === true) {
                    if (Lib.CssClass.contains(node, "hasOnP1")) {
                        continue;
                    }
                    else {
                        Lib.CssClass.add(node, "hasOnP1");
                    }
                }
                var expAttribute = node.getAttribute(dataExp);
                if (expAttribute) {
                    wireupElement(node, expAttribute);
                    // Ensure that an element is not wired up twice.
                    node.removeAttribute(dataExp);
                }
            }
        }
    }
    function wireupElement(element, expAttribute) {
        var expAttributeList = expAttribute.split(";");
        switch (expAttributeList[0]) {
            case "I":
                wireupLinkElement(element, expAttributeList);
                break;
            case "H":
                wireupHiddenElement(element, expAttributeList);
                break;
        }
    }
    function wireupLinkElement(element, expAttributeList) {
        var id = expAttributeList[1];
        var item = getOrCreateItem(id);
        item.id = id;
        item.collapsible = "1" === expAttributeList[2];
        item.visibles = parseInt(expAttributeList[3]);
        item.state = "1" === expAttributeList[4] ? 1 : 0;
        item.hitTarget = expAttributeList[5];
        item.logArea = expAttributeList[6] || "Expansion";
        item.logName = expAttributeList[7] || id;
        item.scrollBackOnCollapse = "1" === expAttributeList[8];
        item.animationEnabled = ("1" === expAttributeList[9]) && (transitionEndEventName !== "");
        item.answerContainer = findAnswerContainer(_ge(item.id));
        sj_evt.bind("exphide", function (evtArgs) {
            var expId = evtArgs[1];
            if (expId === item.id) {
                hideItem(item);
            }
        });
        sj_evt.bind("expshow", function (evtArgs) {
            var expId = evtArgs[1];
            if (expId === item.id) {
                showItem(item);
            }
        });
        // bind extra hit targets
        var targets = [element.id, item.hitTarget];
        for (var i = 0; i < targets.length; ++i) {
            var hitTarget = _ge(targets[i]);
            if (hitTarget) {
                sj_be(hitTarget, "keyup", function (evt) {
                    // Keycode 13 is "Enter" (Only re-focus if done through keyboard)
                    if (evt.keyCode == 13 && !item.collapsible) {
                        // When we hide the currently focused item, focus resets to the beginning.  Explicitly set to avoid this jump
                        AccessibilityHelpers.FocusNextFocusableElement();
                        sj_sp(evt);
                    }
                });
                sj_be(hitTarget, "click", function (evt) {
                    toggle(item);
                    sj_sp(evt);
                });
            }
        }
        items[id] = item;
    }
    function wireupHiddenElement(element, expAttributeList) {
        var id = expAttributeList[1];
        var keep = "1" === expAttributeList[2];
        var exclusive = expAttributeList[3];
        var buffer = "1" === expAttributeList[4];
        var hiddenOnExpansion = "1" === expAttributeList[5];
        var expanded = "1" === expAttributeList[6];
        var item = getOrCreateItem(id);
        if (buffer) {
            item.buffer.push(element);
        }
        else if (expanded) {
            element.setAttribute(inversionAttribute, "1");
            item.turnable.push(element);
        }
        else if (hiddenOnExpansion) {
            element.setAttribute(hiddenOnExpansionAttribute, "1");
            item.turnable.push(element);
        }
        else if (keep) {
            item.turnable.push(element);
        }
        else if (exclusive && exclusive.length) {
            var other = _ge(exclusive);
            if (other) {
                item.exclusive.push([element, other]);
            }
        }
        else {
            item.movable.push(element);
        }
        items[id] = item;
    }
    function getOrCreateItem(id) {
        return items[id] || {
            id: id,
            movable: [],
            turnable: [],
            exclusive: [],
            external: [],
            buffer: []
        };
    }
    function isExpanded(item) {
        return (item.state % 2) !== 0;
    }
    function allowExplicitExpansionOnly(item) {
        var expansion = _ge(item.id);
        if (expansion != null && expansion.getAttribute("data-expl") == "1") {
            return true;
        }
        return false;
    }
    // Due to browser optimization of style update, multiple style changes may go at the same time instead of sequentially.  
    // To force update of styles before applying the animation class, a layout property is accessed, which forces the browser
    // to update the style and layouts.
    function forceStyleUpdate(node) {
        var tmp = node.offsetTop;
    }
    function findAnswerContainer(node) {
        var answerContainerParentIds = { "b_pole": true, "b_results": true, "b_context": true };
        var parent = node.parentElement;
        while (parent != null && !(parent.id in answerContainerParentIds)) {
            node = parent;
            parent = node.parentElement;
        }
        return node;
    }
    function setHeight(node) {
        var height = node.clientHeight;
        if (height == 0 && Lib.CssClass.contains(node, "b_hide")) {
            Lib.CssClass.remove(node, "b_hide");
            height = node.clientHeight;
            Lib.CssClass.add(node, "b_hide");
        }
        if (height > 0) {
            node.style.height = height + "px";
        }
    }
    function getTopInViewport(node) {
        var rect = node.getBoundingClientRect();
        return rect.top;
    }
    function getTransitionEndEventName() {
        var eventName = "TransitionEnd";
        var styleName = "Transition";
        var prefixes = ["o", "Moz", "webkit"];
        if (styleName.toLowerCase() in _d.documentElement.style) {
            return eventName.toLowerCase();
        }
        for (var i = 0; i < prefixes.length; i++) {
            var prefixStyleName = prefixes[i] + styleName;
            if (prefixStyleName in _d.documentElement.style) {
                return prefixes[i] + eventName;
            }
        }
        return "";
    }
    function hasHorizontalScrollbar() {
        return _w.innerHeight > _d.documentElement.clientHeight;
    }
    function getScrollbarWidth() {
        var outer = sj_ce("div");
        outer.style.visibility = "hidden";
        outer.style.width = "100px";
        _d.body.appendChild(outer);
        var outerWidth = outer.offsetWidth;
        outer.style.overflow = "scroll";
        var inner = sj_ce("div");
        inner.style.width = "100%";
        outer.appendChild(inner);
        var innerWidth = inner.offsetWidth;
        _d.body.removeChild(outer);
        return outerWidth - innerWidth;
    }
    function getBodyScrollTop() {
        return _w.pageYOffset || _d.body.scrollTop || _d.documentElement.scrollTop;
    }
    function getViewportHeight() {
        return _w.innerHeight || _d.documentElement.clientHeight;
    }
    // Argument 1: Required. expansion ID representing the item to expand, collapse, or toggle
    // Argument 2: Optional. int. The state. 0 to collapse, 1 to expand. Pass nothing to toggle.
    sj_evt.bind("expItem.exp", function (args) {
        var item = items[args[1]];
        if (item && !allowExplicitExpansionOnly(item)) {
            if (args.length > 2) {
                var shouldExpand = (args[2] % 2) !== 0;
                if (shouldExpand != isExpanded(item)) {
                    toggle(item);
                    if (!shouldExpand && !item.collapsible) {
                        showItem(item);
                    }
                }
            }
            else {
                toggle(item);
            }
        }
    }, true);
    sj_evt.bind("onP1", wireupAll, true);
})(expitem || (expitem = {}));
;///<reference path="Declarations\Shared.d.ts" />
var SelectorHelper;
(function (SelectorHelper) {
    // This method is intended to work cross-browser. On down-level browsers without native javascript support, the DOM is walked to find a match.  Please be mindful of performance when calling this for down-level browsers.
    function selectorMatches(e, selector) {
        if (e["matches"]) {
            return e["matches"](selector);
        }
        else if (e["webkitMatchesSelector"]) {
            return e["webkitMatchesSelector"](selector);
        }
        else if (e["mozMatchesSelector"]) {
            return e["mozMatchesSelector"](selector);
        }
        else if (e["msMatchesSelector"]) {
            return e["msMatchesSelector"](selector);
        }
        else {
            var eles = _d.querySelectorAll(selector);
            if (eles) {
                for (var i = 0; i < eles.length; i++) {
                    if (eles[i] === e) {
                        return true;
                    }
                }
            }
            return false;
        }
    }
    SelectorHelper.selectorMatches = selectorMatches;
    function findFirstAncestorWithSelector(e, selector) {
        var p = e;
        do {
            p = p.parentElement;
        } while (p != null && !selectorMatches(p, selector));
        return p;
    }
    SelectorHelper.findFirstAncestorWithSelector = findFirstAncestorWithSelector;
})(SelectorHelper || (SelectorHelper = {}));
;///<reference path="..\Declarations\Shared.d.ts" />
///<reference path="..\SelectorHelper.ts" />
var AnswerActionsHelper;
(function (AnswerActionsHelper) {
    function createUndoContainer(undoText, confirmText) {
        if (undoText == null || confirmText == null) {
            return null;
        }
        var msgContainer = sj_ce("div", null, "b_undoContainer b_hide");
        var confirmContainer = sj_ce("div", null, "confirmMsg");
        confirmContainer.innerHTML = confirmText;
        var undoLink = sj_ce("a");
        undoLink.setAttribute("href", "javascript:void(0);");
        undoLink.innerText = undoText;
        msgContainer.appendChild(confirmContainer);
        msgContainer.appendChild(undoLink);
        return msgContainer;
    }
    AnswerActionsHelper.createUndoContainer = createUndoContainer;
    function createErrorHandler(actionLink, errorString, isButtons) {
        return function () {
            // Let the action link be functional again and set error text
            actionLink["isHandling"] = false;
            actionLink.innerText = errorString;
            actionLink.classList.remove("b_demoteText");
            if (!isButtons) {
                actionLink.classList.add("b_accentColor");
            }
        };
    }
    AnswerActionsHelper.createErrorHandler = createErrorHandler;
    // For a given element, find the answer card it's contained within.
    function findContainingCard(element) {
        var card = SelectorHelper.findFirstAncestorWithSelector(element, "#b_pole,.b_ans,.b_ansSlice,.answer,.b_inlActions");
        var isInlineActionContainer = card.classList.contains("b_inlActions");
        if (isInlineActionContainer) {
            var ansCard = SelectorHelper.findFirstAncestorWithSelector(card, "#b_pole,.b_ans,.b_ansSlice,.answer");
            if (ansCard) {
                card = ansCard;
            }
        }
        return card;
    }
    AnswerActionsHelper.findContainingCard = findContainingCard;
    // Determines whether an element is a wrapper used for swapping.
    function isSwapWrapper(element) {
        return element.getAttribute("data-type") === "wrapper";
    }
    AnswerActionsHelper.isSwapWrapper = isSwapWrapper;
    function fade(element) {
        if (element == null) {
            return;
        }
        element.classList.add("b_anim");
        // For the animation to work correctly, it has to transition from one property to another.
        // So to transition to zero properly, we need to set the height explicitly first.
        element.style.height = _w.getComputedStyle(element).height;
        // Start the animation. We need a miniscule amount of time to have the above style change repaint.
        sb_st(function () {
            element.classList.add("b_hide");
            sj_evt.fire('elementgone', element);
        }, 1);
    }
    AnswerActionsHelper.fade = fade;
    function createResponseCard(content, oldCard) {
        if (!oldCard) {
            return null;
        }
        var container = sj_ce(oldCard.tagName, "", oldCard.className);
        container.innerHTML = content;
        return container;
    }
    AnswerActionsHelper.createResponseCard = createResponseCard;
    function swapElements(newElement, oldElement, fadeIfNoReplacement) {
        if (newElement == null || oldElement == null) {
            if (oldElement != null && fadeIfNoReplacement) {
                fade(oldElement);
            }
            return;
        }
        // Create a wrapper element that houses both the new and old elements.
        // Try to reuse an existing wrapper if we find one to keep the DOM shallow.
        var parent = oldElement.parentElement;
        var container;
        if (isSwapWrapper(parent)) {
            container = parent;
        }
        else {
            container = sj_ce("div");
            container.setAttribute("data-type", "wrapper");
            container.classList.add('b_anim');
            parent.insertBefore(container, oldElement);
            container.appendChild(oldElement);
        }
        // Move the new element to the wrapper too
        container.appendChild(newElement);
        // We want to ensure the container animates the height change. To do this we:
        //   1. Set the height to the old element's height
        //   2. Set the height to the new element's height after the above height change goes into effect.
        //   3. When the height has animated, reset the value so that the style is not affecting other transformations on page
        container.style.height = getTotalHeight(oldElement) + "px";
        sb_st(function () {
            container.style.height = getTotalHeight(newElement) + "px";
            sb_st(function () { return container.style.height = ''; }, 0);
        }, 0);
        // Fade out the old element
        fade(oldElement);
    }
    AnswerActionsHelper.swapElements = swapElements;
    function findImmediateChild(parent, descendant) {
        while (descendant && descendant.parentElement !== parent) {
            descendant = descendant.parentElement;
        }
        return descendant;
    }
    function wrapWithDiv(elements, excludedElements) {
        var wrapper = sj_ce("div");
        var i = 0;
        while (i < elements.length) {
            var child = elements[i];
            if (excludedElements == null || excludedElements.indexOf(child) < 0) {
                wrapper.appendChild(child);
            }
            else {
                i++;
            }
        }
        return wrapper;
    }
    function getTotalHeight(element) {
        return convertStyleToPixels(_w.getComputedStyle(element).height) + convertStyleToPixels(_w.getComputedStyle(element).paddingBottom);
    }
    function convertStyleToPixels(style) {
        // Cut off the "px" suffix
        return parseInt(style.substring(0, style.length - 2));
    }
    function insertScriptIntoHead(script) {
        var returnScript = sj_ce("script", "");
        returnScript.type = "text/javascript";
        if (script.src) {
            returnScript.src = script.src;
        }
        else {
            returnScript.innerHTML = script.innerHTML;
        }
        insertNodeIntoHead(returnScript);
    }
    function dismissCard(action) {
        var lastClickedCard = AnswerActionsHelper.findContainingCard(action);
        AnswerActionsHelper.fade(lastClickedCard);
        var answerContainer = SelectorHelper.findFirstAncestorWithSelector(lastClickedCard, "#b_pole,.b_ans");
        if (answerContainer) {
            sb_st(function () {
                var subAnswers = AnswerActionsHelper.findInCard(answerContainer, ".b_ansSlice", false);
                if (!subAnswers) {
                    AnswerActionsHelper.fade(answerContainer);
                }
                sj_evt.fire("dismissCard");
            }, 1);
        }
    }
    AnswerActionsHelper.dismissCard = dismissCard;
    function replaceCard(action, newContent) {
        // Find the old and new answer cards
        var oldCard = findContainingCard(action);
        var newCard = createResponseCard(newContent, oldCard);
        if (oldCard == null || newCard == null) {
            if (oldCard != null) {
                // No new card came back but the action was successfull. Just dismiss the card.
                fade(oldCard);
            }
            return;
        }
        var isSearchReversed = false;
        var ansSlices = oldCard.querySelectorAll("div.b_ansSlice");
        if (ansSlices) {
            isSearchReversed = true;
        }
        // Extract styles and throw them into the DOM
        var styles = newCard.querySelectorAll("style, link");
        if (styles) {
            for (var i = 0; i < styles.length; i++) {
                insertNodeIntoHead(styles[i]);
            }
        }
        // Find the old explanation
        var newExplanation = findExplanation(newCard, false);
        var oldExplanation = findExplanation(oldCard, isSearchReversed);
        // Find the old and new annotations
        var newAnnotation = findAnnotation(newCard, false);
        var oldAnnotation = findAnnotation(oldCard, false);
        // Find the old and new actions
        var newActions = findActions(newCard, false);
        var oldActions = findActions(oldCard, isSearchReversed);
        // Find and swap the old and new captions
        var newCaption = wrapCaption(newAnnotation, newActions, newExplanation);
        var oldCaption = wrapCaption(oldAnnotation, oldActions, oldExplanation);
        // Extract scripts to later throw them into the DOM
        var scripts = newCard.querySelectorAll("script");
        // All animations go! Note that each of these animate independantly.
        swapElements(newAnnotation, oldAnnotation, false);
        swapElements(newCaption, oldCaption, false);
        swapElements(newActions, oldActions, true);
        swapElements(newExplanation, oldExplanation, true);
        if (scripts) {
            for (var i = 0; i < scripts.length; i++) {
                insertScriptIntoHead(scripts[i]);
            }
        }
        sj_evt.fire("replaceCard");
    }
    AnswerActionsHelper.replaceCard = replaceCard;
    // Find the element having a parent with data-type = "infoldAction"
    function findInlineActionContainer(action) {
        while (action != null) {
            var parent = action.parentElement;
            if (parent && parent.getAttribute && parent.getAttribute("data-type") === "InlineActionsWrapper") {
                return action;
            }
            action = parent;
        }
        return null;
    }
    AnswerActionsHelper.findInlineActionContainer = findInlineActionContainer;
    function insertNodeIntoHead(node) {
        _d.head.appendChild(node);
    }
    function findAnnotation(card, isSearchReversed) {
        return findInCard(card, '.b_anno,[data-anno]', isSearchReversed);
    }
    AnswerActionsHelper.findAnnotation = findAnnotation;
    function findTitle(card) {
        return findInCard(card, '.b_anno~h2,.b_anno~.b_focusLabel', false);
    }
    AnswerActionsHelper.findTitle = findTitle;
    function nodeListContains(nodelist, elem) {
        for (var i = 0; i < nodelist.length; i++) {
            if (nodelist[i] == elem) {
                return true;
            }
        }
        return false;
    }
    AnswerActionsHelper.nodeListContains = nodeListContains;
    function findActions(card, isSearchReversed) {
        var expandableActions = findInCard(card, '[data-type="expandableActions"]', isSearchReversed);
        return expandableActions ? expandableActions : findInCard(card, '[data-type="actions"]', isSearchReversed);
    }
    AnswerActionsHelper.findActions = findActions;
    function findExplanation(card, isSearchReversed) {
        return findInCard(card, '.actExpl', isSearchReversed);
    }
    AnswerActionsHelper.findExplanation = findExplanation;
    function findInCard(card, selector, isSearchReversed) {
        if (card) {
            var elements = card.querySelectorAll(selector);
            for (var i = (isSearchReversed ? elements.length - 1 : 0); (!isSearchReversed && i < elements.length) || (isSearchReversed && i >= 0); isSearchReversed ? i-- : i++) {
                var element = elements[i];
                if (element.classList.contains('b_hide')) {
                    // If we find an already faded element, go ahead and do some housekeeping to just remove it from the DOM.
                    element.parentNode.removeChild(element);
                }
                else {
                    return element;
                }
            }
        }
        return null;
    }
    AnswerActionsHelper.findInCard = findInCard;
    function wrapCaption(annotation, actions, explanation) {
        if (!annotation) {
            return null;
        }
        var parent = findContainingCard(annotation);
        var annotationImmediateChild = findImmediateChild(parent, annotation);
        var caption = wrapWithDiv(parent.childNodes, [annotationImmediateChild, findImmediateChild(parent, actions), findImmediateChild(parent, explanation)]);
        return parent.insertBefore(caption, annotationImmediateChild.nextSibling);
    }
})(AnswerActionsHelper || (AnswerActionsHelper = {}));
;///<reference path="..\..\..\..\Shared\Content\Content\Script\Declarations\Shared.d.ts" />
///<reference path="..\..\..\..\Shared\Content\Content\Script\Declarations\Animation.d.ts" />
///<reference path="..\..\..\..\Threshold\src\Content\Script\Declarations\SearchAppWrapper.d.ts" />
var SearchPeek;
(function (SearchPeek) {
    // const aliases for perf
    var Load = "load";
    var Peek = "peek";
    var PeekExpand = "peekExpand";
    var HideClass = "b_hide";
    var content = _ge("b_content");
    var results = _ge("b_results");
    var resultsItems = results.querySelectorAll(".b_ans,.b_algo,.b_ad");
    var poleAnswer = _ge("b_pole");
    var isCat3a = poleAnswer != null && poleAnswer.querySelector(".b_anno") != null;
    var annotation = isCat3a ? poleAnswer.querySelector(".b_anno") : null;
    var title = isCat3a ? poleAnswer.querySelector(".b_anno~h2,.b_anno~.b_focusLabel") : null;
    var header = _ge("b_header");
    var pagination = results.querySelector(".b_pag");
    var footer = _d.querySelector(".b_footer");
    var messageModules = results.querySelectorAll(".b_msg");
    var recourseLink = results.querySelector(".recourseLink").parentNode;
    var feedbackDiv = _ge("sb_feedback");
    var feedbackBadge = feedbackDiv ? feedbackDiv.parentNode : null;
    var hasPeekActivated = false;
    function activatePeek() {
        if (hasPeekActivated) {
            return;
        }
        hasPeekActivated = true;
        // change the background color
        _d.documentElement.classList.remove(Peek);
        sj_b.classList.remove(Peek);
        _d.documentElement.classList.add(PeekExpand);
        sj_b.classList.add(PeekExpand);
        // hide the pole answer based on a flag set by the answer
        if (annotation.getAttribute("data-mainContent") === "1") {
            Animation.toggleSlide(poleAnswer);
        }
        else {
            // answer will be shown in Cat3B, show/hide/animate the elements
            if (title) {
                title.classList.remove(HideClass);
            }
            annotation.classList.add(HideClass);
        }
        // Hide the recourse links        
        recourseLink.classList.add(HideClass);
        // Fade in the header, results, pagination, footer, etc.
        Animation.toggleSlideTranslate(header);
        content.classList.add(PeekExpand);
        results.classList.add("b_slideListHide");
        for (var i = 0; i < resultsItems.length; i++) {
            var result = resultsItems[i];
            result.classList.remove(HideClass);
        }
        if (pagination != null) {
            pagination.classList.remove(HideClass);
        }
        footer.classList.remove(HideClass);
        Animation.cascadeList(results);
        // Hide the client header
        SearchAppWrapper.CortanaApp.setChromeState(7 /* NoHeader */);
        // Let others know the peek happened
        sj_evt.fire("peekexpand", true);
    }
    function showPeek() {
        if (isCat3a) {
            // The title stays hidden
            if (title != null) {
                title.classList.add(HideClass);
                title.classList.add(Peek);
            }
            annotation.classList.remove("b_anim");
            // The scope bar stays hidden
            header.classList.add(HideClass);
            header.classList.add(Peek);
            // results stay hidden
            results.classList.add(Peek);
            for (var i = 0; i < resultsItems.length; i++) {
                var result = resultsItems[i];
                result.classList.add(HideClass);
            }
            for (var i = 0; i < messageModules.length; i++) {
                var messageModule = messageModules[i];
                if (messageModule !== recourseLink && messageModule !== feedbackBadge) {
                    messageModule.classList.add(HideClass);
                }
            }
            // pagination stays hidden
            if (pagination != null) {
                pagination.classList.add(HideClass);
            }
            // The footer stays hidden
            footer.classList.add(HideClass);
            footer.classList.add(Peek);
            // Wait for user to click the recourse link.
            sj_evt.bind("peekactivate", activatePeek, true);
        }
        else {
            // Hide the recourse link
            recourseLink.classList.add(HideClass);
            // Fade in the header, results, footer, etc.
            header.classList.add(Peek);
            content.classList.add(PeekExpand);
            results.classList.add(PeekExpand);
            results.classList.add(Peek);
            footer.classList.add(Peek);
        }
        // Clean up event binding
        sj_ue(_w, Load, showPeek);
    }
    if (content != null && results != null && header != null && recourseLink != null && footer != null) {
        // Because of timing and dimensions-related issues related to the browser itself sliding up from the bottom of the screen,
        // we should just hide the results until after we load and have a chance to properly set peek padding.
        sj_be(_w, Load, showPeek);
    }
    // background color needs to be applied before onload so the initial paint gets the right background for cat3a
    if (isCat3a) {
        _d.documentElement.classList.add(Peek);
        sj_b.classList.add(Peek);
    }
})(SearchPeek || (SearchPeek = {}));
;///<reference path="..\..\..\..\Shared\Content\Content\Script\Declarations\Shared.d.ts" />
///<reference path="Declarations\PageDebug.d.ts" />
/*
 * This module defines methods to set PageDebug properties.
 */
var Feedback;
(function (Feedback) {
    var DebugCollector;
    (function (DebugCollector) {
        'use strict';
        function GetPageDebug() {
            _w["PageDebug"] = (typeof _w["PageDebug"] !== "undefined") ? _w["PageDebug"] : {};
            return _w["PageDebug"];
        }
        function SetFederationDebugInfo(debugInfo) {
            if (debugInfo.length < 1)
                return;
            GetPageDebug().FederationDebugInfo = debugInfo;
        }
        DebugCollector.SetFederationDebugInfo = SetFederationDebugInfo;
    })(DebugCollector = Feedback.DebugCollector || (Feedback.DebugCollector = {}));
})(Feedback || (Feedback = {}));
;Feedback.DebugCollector.SetFederationDebugInfo('QueryID : f7a547f3e6d74bc6a2eb8bf3dae9edb9');;
//]]></script><script type="text/javascript" data-rms="1" src="/rms/Framework/nj/92342395/b2d8ec0a.js?bu=rms+answers+BoxModel+config.threshold%2ccore%2ccore%24viewport%2ccore%24layout%2ccore%24metrics%2cmodules%24mutation%2cmodules%24error%2cmodules%24network%2cmodules%24cursor%2cmodules%24keyboard%2cmodules%24bot"></script></body></html>