<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:web="http://schemas.live.com/Web/" class="b_theme b_thDark peek"><head><script type="text/javascript">//<![CDATA[
si_ST=new Date;
//]]></script><!--pc--><title>Set a reminder. - Bing</title><meta content="text/html; charset=utf-8" http-equiv="content-type"><meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><meta name="mobileoptimized" content="0"><link href="/sa/simg/bing_p_rr_teal_min.ico" rel="shortcut icon"><script type="text/javascript">//<![CDATA[
_G={ST:(si_ST?si_ST:new Date),Mkt:"en-US",RTL:false,Ver:"39",IG:"4aed71533adb72fa437ea2a3e14abcac",EventID:"8F51D2F040854E27BAEA1780BD005BDC",MN:"SERP",V:"web",P:"SERP",DA:"HK2",SUIH:"WrX50t2N86GwbSu0QBwTmQ",gpUrl:"\/fd\/ls\/GLinkPing.aspx?" }; _G.lsUrl="/fd/ls/l?IG="+_G.IG ;curUrl="https:\/\/www.bing.com\/speech_render";_G.XLS="\/threshold\/xls.aspx";;_G.nclid='84BC810D3366EBAB1B271B076581C27E';0;;///<reference path="..\..\..\answers\services\Shared\Content\Content\script\Declarations\Shared.d.ts"/>
var logMetaError = function (str) {
    (new Image).src = _G.lsUrl + '&Type=Event.ClientInst&DATA=[{"T":"CI.MetaError","FID":"CI","Name":"MetaJSError","Text":"' + escape(str) + '"}]';
};
var getHref = function () {
    return location.href;
};
try {
    var jsve = window["jsve"];
    var regexEscape = function (str) {
        return str.replace(/([.?*+^$&[\]\\(){}|<>-])/g, "\\$1");
    };
    function jsErrorHandler(e) {
        try {
            if (jsve) {
                logMetaError("CanaryStart");
            }
            // if e["error"] doesn't exist, occasionally we can get information directly from e
            var error = e["error"] || e;
            // this is a default value to indicate the object passed to us had no message member (which we would put in the Text field of the error payload)
            var defaultMessage = '"noMessage"';
            var fileName = e["filename"];
            var lineno = e["lineno"];
            var colno = e["colno"];
            var extra = e["extra"];
            var eventType = error["severity"] || "Error";
            var message = error.message || defaultMessage;
            var stack = error.stack;
            var logText = '"' + escape(message.replace(/"/g, "")) + '"';
            var hrefRegex = new RegExp(regexEscape(getHref()), "g");
            if (stack) {
                // ---------------------------------------------------------------------------------------------------------------------
                // the stack has the potential to be very long with a lot of repeated filenames. The following is a small compression to
                // reduce the number of bits over the wire and make the stack easier to display 
                // ---------------------------------------------------------------------------------------------------------------------
                var sourceFileRegex = /\(([^\)]+):[0-9]+:[0-9]+\)/g;
                var fileNameFromStack;
                var fileNameCounts = {};
                while ((fileNameFromStack = sourceFileRegex.exec(stack)) !== null) {
                    var currentFileName = fileNameFromStack[1];
                    if (fileNameCounts[currentFileName]) {
                        fileNameCounts[currentFileName]++;
                    }
                    else {
                        fileNameCounts[currentFileName] = 1;
                    }
                }
                var regex;
                var replacedCount = 0;
                for (var potentialCompressable in fileNameCounts) {
                    // if a particular file has shown up more than once in the stack, it's wortwhile to compress it - otherwise we can leave it alone
                    if (fileNameCounts[potentialCompressable] > 1) {
                        var escapedFileName = regexEscape(potentialCompressable);
                        regex = new RegExp(escapedFileName, "g");
                        stack = stack.replace(regex, replacedCount);
                        // adding in a mapping at the end of our stack to see which condensed files are which
                        stack += "#" + replacedCount + "=" + escapedFileName;
                        replacedCount++;
                    }
                }
                stack = stack.replace(hrefRegex, "self").replace(/"/g, "");
                // end of compression
                logText += ',"Stack":"' + (escape(stack) + '"');
            }
            if (fileName) {
                logText += ',"Meta":"' + escape(fileName.replace(hrefRegex, "self")) + '"';
            }
            if (lineno) {
                logText += ',"Line":"' + lineno + '"';
            }
            if (colno) {
                logText += ',"Char":"' + colno + '"';
            }
            if (extra) {
                logText += ',"ExtraInfo":"' + extra + '"';
            }
            if (message === defaultMessage) {
                // if we couldn't get any error information we want to grab as much information as we can
                logText += ',"ObjectToString":"' + e.toString() + '"';
                if (JSON && JSON.stringify) {
                    logText += ',"' + 'JSON":"' + escape(JSON.stringify(e)) + '"';
                }
                else {
                    for (var prop in e) {
                        if (e.hasOwnProperty(prop)) {
                            logText += ',"' + prop + '":"' + e[prop] + '"';
                        }
                    }
                }
            }
            var url = "/fd/ls/lsp.aspx?";
            var time = new Date().getTime();
            var errorPayload = '"T":"CI.' + eventType + '","FID":"CI","Name":"JS' + eventType + '","Text":' + logText + '';
            var eventXML = "<E><T>Event.ClientInst</T><IG>" + _G.IG + "</IG><TS>" + time + "</TS><D><![CDATA[[{" + errorPayload + "}]]]></D></E>";
            var xml = "<ClientInstRequest><Events>" + eventXML + "</Events><STS>" + time + "</STS></ClientInstRequest>";
            var request = new XMLHttpRequest();
            request.open("POST", url, true);
            request.setRequestHeader("Content-Type", "text/xml");
            request.send(xml);
            if (typeof (sj_evt) !== "undefined") {
                sj_evt.fire("ErrorInstrumentation", logText);
            }
        }
        catch (e2) {
            logMetaError('Failed to execute error handler. ' + e2.message);
        }
    }
    if (window.addEventListener) {
        window.addEventListener("error", jsErrorHandler, false);
    }
    // si_RE is for Search Instrumentation, Report Error
    // lineNumber: will typically not be useful in the production system because of crunching.
    // ensure we don't stomp on a partner error handler by first checking to see if one exists
    if ((jsve || !window.addEventListener) && !window.onerror) {
        // Chrome recently started passing in 5th argument as errorObject that contains error stack
        window.onerror = function (message, url, lineNumber, columnNumber, errorObject) {
            // some error messages contain single quotes which break the log format if not removed
            var logText = "";
            if (typeof message === "object" && message.srcElement && message.srcElement.src) {
                //BUGBUG: 628140 -  JS Script Error Inst:  Investigate why we never hit the supposed special error 
                //                  handler for Chrome
                //Chrome passes only a ScriptError Object to the onerror function.
                logText = "\"ScriptSrc = '" + escape(message.srcElement.src.replace(/'/g, "")) + "'\"";
            }
            else {
                // Force transform this variable into string
                // Sometimes if message is of type "function", the following code will throw exception since replace method doesn't exist
                message = "" + message;
                //for others we get a message, url and a line number.
                logText = '"' + escape(message.replace(/"/g, "")) + '","Meta":"' + escape(url) + '","Line":' + lineNumber + ',"Char": ' + columnNumber;
                if (errorObject && errorObject.stack) {
                    var hrefRegex = new RegExp(regexEscape(getHref()), "g");
                    logText += ',"Stack":"' + escape(errorObject.stack.replace(hrefRegex, "self").replace(/"/g, "") + '"');
                }
            }
            (new Image).src = _G.lsUrl + '&Type=Event.ClientInst' + '&DATA=[{"T":"CI.GetError","FID":"CI","Name":"JSGetError","Text":' + logText + '}]';
            if (typeof (sj_evt) !== "undefined") {
                sj_evt.fire("ErrorInstrumentation", logText);
            }
        };
    }
}
catch (e) {
    logMetaError("Failed to bind error handler " + e.message);
}
;
//]]></script><style type="text/css">img,.cbtn,.sb_meta li,.exp_trwr .sc_rc1,.topBar .bg,.vidr cite.nowrap{vertical-align:bottom}img.img_fav,img.twss,img.twsi,img.sa_iconR{vertical-align:baseline}img.img_msn_icon,td.msn_btn_icon img{vertical-align:text-top}#sb_foot{margin-top:-3px}div.sb_adsWv2 h2.sb_title{display:block}#fbpgbt{background:#f2f2f2;border:1px solid #999;bottom:0;color:#36b;cursor:pointer;display:block;font-family:Arial,sans-serif;font-size:13px;font-weight:bold;height:28px;line-height:28px;min-width:110px;padding:0 5px;position:fixed;right:0;text-align:center;z-index:1000000}#fbpgbt:hover{background:#e5e5e5;text-decoration:none}#fbpgbt img{border:0;height:14px;margin:0 5px -4px 0;width:14px;vertical-align:baseline}a{a:1}/* Prevent pinch and zoom and double tap zoom */
html,body
{
    -ms-content-zooming: none;
}
/* set font-faces for Segoe UI typography */

@font-face {
    font-family: Segoe;
    font-weight: 200;
    src: local("Segoe UI Light"), local("Segoe WP Light");
}
@font-face {
    font-family: Segoe;
    font-weight: 300;
    src: local("Segoe UI Semilight"), local("Segoe WP Semilight");
}
@font-face {
    font-family: Segoe;
    font-weight: normal;
    src: local("Segoe UI"), local("Segoe WP");
}
@font-face {
    font-family: Segoe;
    font-weight: 600;
    src: local("Segoe UI Semibold"), local("Segoe WP Semibold");
}
@font-face {
    font-family: Segoe;
    font-weight: 700;
    src: local("Segoe UI Bold"), local("Segoe WP Bold");
}
/* File cannot be completely empty or else RMS will fail */
a{}/* The lang attribute match is a goofy hack to increase selector specificity on the top-level element. */

html[lang] {
  overflow-y: auto;
  -ms-overflow-style: -ms-autohiding-scrollbar;
}
/* register with SegoeFontFaces as a dependency */

header#b_header:not(:empty) {
  border-bottom/*bingcss-ignore hardcoding a Threshold-specific color */: 1px solid #cccccc;
}
#b_header:not(:empty),
.peek .b_msg/* See more recourse link also needs to be 15px */ {
  font: normal 15px/20px Segoe, Arial, sans-serif;
}
#b_header:not(:empty):-ms-lang(am, ti) {
  font-family: Ebrima, Arial, sans-serif;
}
#b_header:not(:empty):-ms-lang(as, bn, gu, hi, kn, kok, ml, mr, ne, or, pa, si, ta, te) {
  font-family: "Nirmala UI", Arial, sans-serif;
}
#b_header:not(:empty):-ms-lang(chr-CHER-US) {
  font-family: Gadugi, Arial, sans-serif;
}
#b_header:not(:empty):-ms-lang(ja) {
  font-family: "Yu Gothic UI", Arial, sans-serif;
}
#b_header:not(:empty):-ms-lang(ko) {
  font-family: "Malgun Gothic", Arial, sans-serif;
}
#b_header:not(:empty):-ms-lang(th, km, lo) {
  font-family: "Leelawadee UI", Arial, sans-serif;
}
#b_header:not(:empty):-ms-lang(zh-CN, zh-Hans, zh-SG) {
  font-family: "Microsoft YaHei UI", Arial, sans-serif;
}
#b_header:not(:empty):-ms-lang(zh-HK, zh-TW, zh-Hant, zh-MO) {
  font-family: "Microsoft JhengHei UI", Arial, sans-serif;
}
#b_header .square_mi,
.b_msg .square_mi {
  width: 24px;
  font-size: 24px;
  line-height: 24px;
}
body header:not(:empty):not(.b_hide)#b_header ~ #b_content {
  margin-top: 45px;
}
/* Peek pages want no top margin since they've hidden the header */

header.b_hide#b_header ~ #b_content,
header:empty#b_header ~ #b_content {
  margin-top: 0px;
}
#b_header .b_scopebar {
  background-color: #eeeeee;
}
#b_header .b_scopebar,
#b_header .b_scopebar a,
#b_header .b_scopebar a:visited,
#b_header .b_mystuff::before,
header#b_header .b_symb {
  color/*bingcss-ignore hardcoding a Threshold-specific color */: #767676;
}
#b_header .b_scopebar li.b_active a,
#b_header .b_scopebar li.b_active a:visited,
#b_header .b_scopebar span {
  color/*bingcss-ignore hardcoding a Threshold-specific color */: black;
  border-color/*bingcss-ignore hardcoding a Threshold-specific color */: #f84e29;
}
/* This is page-specific CSS in the header bundle that we need to retain */

#b_results a.sb_pagS {
  color/* bingcss-ignore: hardcoded from brand bundle header */: #333333;
  border: none;
  font-weight: normal;
}
#b_results .sb_pag a {
  padding/* bingcss-ignore: hardcoded from brand bundle header */: 9px 13px;
}
.sw_plus,
.b_cm,
.sw_up,
.sw_down,
.sw_st,
.sw_sth,
.sw_ste,
.idp_wlid,
.sw_meIc,
.sw_pref,
.sw_tpcbk,
.sw_play,
.sw_playd,
/* disabled */ .sw_playa,
/* active */ .sw_playp,
/* paused */ .sw_spd,
.b_fLogo,
.sb_pagIconN,
.sb_pagIconP {
  background-image: url(/sa/simg/sw_mg_l_4f_m_w2_mh0416.png?v=2);
  background-repeat: no-repeat;
  background-size: 320px 38px;
}
/* Add icon */

.sw_plus {
  background-position: -216px 0;
  height: 10px;
  width: 10px;
}
.idp_wlid,
.sw_meIc,
.sw_pref,
.sw_play,
/*Play icon*/ .sw_playa,
/* active */ .sw_playd,
/* disabled */ .sw_playp,
/* paused */ .sb_pagIconN,
.sb_pagIconP {
  height: 16px;
  width: 16px;
}
.sw_play {
  background-position: -228px 0;
}
.sw_playa,
.sw_playd {
  background-position: -246px 0;
}
.sw_playp {
  background-position: -264px 0;
}
.b_cm,
/* Check mark */ .sw_up,
/* Up (collapse) */ .sw_down/* down (expand) */ {
  height: 14px;
  width: 14px;
}
.sw_down {
  background-position: -184px 0;
}
.sw_up {
  background-position: -152px 0;
}
*:active > .sw_up,
*:focus > .sw_up {
  background-position: -168px 0;
}
*:active > .sw_down,
*:focus > .sw_down {
  background-position: -200px 0;
}
/* Check mark */

.b_cm {
  background-position: -282px 0;
}
/* rating star */

.sw_st,
/* full gold */ .sw_sth,
/* left half star */ .sw_ste/* empty (light grey) */ {
  height: 14px;
  width: 14px;
  display: inline-block;
}
.sw_st {
  background-position: -238px -22px;
}
.sw_sth {
  background-position: -270px -22px;
}
.sw_ste {
  background-position: -254px -22px;
}
/* Rewards */

.sw_meIc {
  background-position: -180px -22px;
}
#spcv .sw_meIc,
.rigleamon .sw_meIc {
  background-position: -198px -22px;
}
/* Preference */

.sw_pref {
  background-position: -301px -22px;
}
/* Windows Live ID Icon */

.idp_wlid {
  background-position: -75px -22px;
}
/* default user icon */

.sw_spd {
  background-position: -299px 0;
  height: 20px;
  width: 20px;
}
/* Footer logo */

.b_fLogo {
  background-position: -94px -22px;
  height: 16px;
  width: 81px;
}
.sw_tpcbk {
  background-position: -124px 0px;
}
.sb_pagIconN {
  background-position: -168px 0;
}
.sb_pagIconP {
  background-position: -200px 0;
}
.sb_pagIconN,
.sb_pagIconP {
  -webkit-transform: rotate(90deg);
  -moz-transform: rotate(90deg);
  -ms-transform: rotate(90deg);
  -o-transform: rotate(90deg);
  transform: rotate(90deg);
}
/* START COLORS */

html,
body {
  background-color: #e5e5e5;
}
#b_results > .b_pag/* Task 1249184 : [Mobile 1st][wholepage] Paginiation - Remove legacy style after change ajax pagination */ {
  background-color: #e5e5e5;
}
body,
.b_promoteText {
  color: #404040;
}
input[type="text"] {
  color: #bbbbbb;
  border-color: #bbbbbb;
}
input[type="text"]:focus {
  color: #404040;
  border-color: #404040;
}
#b_pole .b_ans {
  background-color: white;
}
#b_results,
#b_results .b_defaultText,
.cbl/* label in Factrow */ {
  color: #404040;
}
#b_results > li a {
  color: #1020d0;
}
.b_pag a.sb_pagS,
/* Task 1249184 : [Mobile 1st][wholepage] Paginiation - Remove legacy style after change ajax pagination */ #b_results > li,
#b_content > .sml/* Morepage pagination */ {
  background-color: white;
}
#b_results > .b_ad {
  color: #303030;
  background-color: #f9fcf7;
}
#b_results > .b_ad a {
  color: #0a0cd9;
}
#b_results > .b_ad a:visited {
  color: #600090;
}
#b_results p {
  color: #333333;
}
a,
#b_results .b_no a {
  color: #1020d0;
}
a:visited,
#b_results > li a:visited,
#sb_feedback:visited {
  color: #600090;
}
cite,
#b_results cite.sb_crmb a,
/* Even breadcrumb links in the cite tag need to respect its color */ #b_results cite a.sb_metalink/* Even attribution links in the cite tag need to respect its color */ {
  color: #008900;
}
.b_factrow,
.b_attribution,
.b_focusLabel,
.b_secondaryFocus,
.b_secondaryText,
.b_demoteText,
.b_footnote,
.b_footnote .cbl,
.b_entitySubTitle {
  color: #737373;
}
#b_content .b_imagePair .b_footnote a,
#b_content .b_imagePair .b_footnote a:visited,
#b_content .b_floatR_img .b_footnote a,
#b_content .b_floatR_img .b_footnote a:visited {
  color: #737373;
}
/* footer */

footer {
  color: #777777;
  background-color: #e5e5e5;
  /* Task 5408580 [change to transparent]: Need remove when flight mobvertcard ship */

}
footer a,
footer a:visited,
footer span {
  color: #333333;
}
/* end of footer */

/*secondary text styles*/

.sb_meta,
label {
  color: #737373;
}
/* highlighted buttons */

.cbtn input {
  color: #1020d0;
  background-color: white;
}
.cbtn input:active {
  color: white;
  background-color: #737373;
}
.s_btn.brd.b_highlighted,
.cbtn.b_highlighted input {
  background: #1020d0;
  border-color: #1020d0;
}
.cbtn.b_highlighted input,
input.b_highlighted:focus,
#b_results .s_btn.b_highlighted a:visited,
#b_results .s_btn.b_highlighted a,
#b_results .s_btn.b_highlighted/* #b_results is needed to fix a bug that the button text color remains blue when the background turns blue in highlighted mode, and it is to revert "#b_results>li a { color:blue}" */ {
  color: white;
}
.cbtn.b_highlighted input:active {
  background: #666666;
  border-color: #666666;
}
.b_touchable,
.b_touchable > li {
  border-color: #eeeeee;
}
select {
  background-color: white;
}
.b_subModule,
.b_suppModule {
  border-bottom-color: #e5e5e5;
}
/* Primary alteration in spell suggest */

#b_results .b_pAlt {
  color: #d90026;
}
.b_alert,
#b_results .b_no .b_alert {
  color: #d90026;
}
#b_results .b_alert {
  color: #d90026;
}
.pushpin {
  background: #4499ff;
  color: white;
}
.b_posText {
  color: #006d21;
}
.b_negText {
  color: #c80000;
}
/* END COLORS */

/*This file is intentionally left empty*/
z
{
    a:1;
}/*This file is intentionally left empty*/
z
{
    a:1;
}h3,
h4,
h5 {
  font: inherit;
  font-size: 100%;
}
body {
  font-family: "-apple-system", HelveticaNeue, Roboto, Arial, sans-serif;
  font-weight: normal;
  font-size: 14px;
  line-height: 18px;
}
cite {
  font-style: normal;
  white-space: nowrap;
}
.b_strong,
strong,
.b_no h4 {
  font-weight: 700;
  font-family: "-apple-system", HelveticaNeue, Roboto, Arial, sans-serif;
}
h1,
h2,
.b_focusLabel,
.b_secondaryFocus,
.b_groupLabel {
  font-size: 18px;
  line-height: 22px;
  font-weight: normal;
}
.b_anno {
  font-size: 20px;
  line-height: 24px;
  font-weight: normal;
}
select,
.cbtn input,
.s_btn.b_highlighted a,
input[type="text"] {
  font-size: 14px;
}
#fti3,
.sb_count {
  font-size: 12px;
  line-height: 14px;
}
.ftr_ans,
#ftrLnks,
#id_rwds_b {
  font-size: 13px;
  line-height: 16px;
}
/* medium text */

.b_mText {
  font-size: 16px;
  line-height: 20px;
}
/*Focus text styles*/

.b_xlText {
  font-size: 18px;
}
.b_secondaryFocus,
.b_focusTextExtraSmall {
  font-size: 18px;
  line-height: 22px;
}
.b_focusTextSmall {
  font-size: 23px;
  line-height: 28px;
  font-family: "-apple-system", HelveticaNeue, Roboto, Arial, sans-serif;
}
.b_focusTextMedium {
  font-size: 32px;
  line-height: 38px;
  font-family: "-apple-system", HelveticaNeue, Roboto, Arial, sans-serif;
}
.b_focusTextLarge {
  font-size: 44px;
  line-height: 53px;
  font-family: "-apple-system", HelveticaNeue, Roboto, Arial, sans-serif;
}
.b_footnote {
  font-size: 12px;
  line-height: 15px;
}
.b_smText {
  font-size: 11px;
}
.nowrap {
  white-space: nowrap;
}
a,
#b_results .b_rs li a {
  text-decoration: none;
}
#sp_requery a {
  font-style: italic;
}
th {
  font-weight: normal;
}
.pushpin {
  font-weight: 700;
  font-size: 12px;
}
.b_ad {
  line-height: 18px;
}
/* begin basic page values */

html,
body,
h1,
h2,
h3,
h4,
h5,
h6,
p,
img,
ol,
ul,
li,
form,
table,
tr,
th,
td,
blockquote {
  border: 0;
  border-collapse: collapse;
  border-spacing: 0;
  list-style: none;
  margin: 0;
  padding/* bingcss-ignore TFS: 641967 - Fix existing whitelist files to be complaint with CSS Cop rules */: 0;
}
html {
  overflow-y: scroll;
}
/* This ensures that any words that we will not fit in the width are wrapped */

/* We first try to hyphenate it, and only if that fails we break the word */

body {
  word-wrap: break-word;
  overflow-x: hidden;
  /* no left and right movement */
  -webkit-text-size-adjust: none;
  /* no text adjustment on phone rotation */

}
/* end basic page values */

header#b_header:not(:empty):not(.b_hide) ~ #b_content {
  margin-top: 89px;
}
.b_footnote {
  padding-bottom: 15px;
}
.b_imagePair .cico + .b_footnote,
.b_floatR_img .b_footnote,
img + .b_footnote {
  padding/* bingcss-ignore: we need to add padding between the image and the footnote */: 0 0 0;
}
.b_hList {
  padding-bottom: 15px;
}
input[type="text"] {
  -webkit-appearance: none;
  margin: 0 0 15px 0;
  padding: 0 10px;
  height: 38px;
  border-width: 1px;
  border-style: solid;
  border-radius: 0;
  max-width: 100%;
  min-width: 50%;
}
h2,
h4,
label,
.b_attribution,
.b_sSpace,
.b_label,
.btns,
.b_poiPair,
.b_focusLabel,
.b_secondaryFocus {
  padding-bottom: 0;
}
h2 a,
h3 a,
h4 a,
h5 a,
.b_rs a,
label {
  display: block;
}
.inline label {
  display: inline;
}
#sp_requery a {
  display: inline-block;
}
.b_focusTextLarge,
.b_focusTextMedium,
.b_focusTextSmall,
.b_focusTextExtraSmall {
  padding-bottom: 5px;
}
.b_lBMargin,
h2.b_entityTitle {
  padding-bottom: 10px;
}
.b_focusLabel,
.b_secondaryFocus {
  padding-bottom: 5px;
}
.b_rich {
  padding: 12px 0 15px;
}
.b_rich > *:last-child,
.b_caption > *:last-child {
  padding-bottom: 0;
  margin-bottom: 0;
}
.b_caption {
  padding-bottom: 13px;
}
.b_factrow {
  display: -webkit-box;
  -webkit-box-orient: vertical;
  margin-bottom: 0;
}
.b_attribution {
  width: 100%;
}
.cbtn input,
.b_attribution,
.b_factrow,
.b_1linetrunc {
  overflow: hidden;
  text-overflow: ellipsis;
}
/* truncating one line string */

.b_1linetrunc {
  white-space: nowrap;
}
.b_mBottom {
  padding-bottom: 5px;
}
.b_lBottom {
  padding-bottom: 10px;
}
.b_xlBottom {
  padding-bottom: 15px;
}
.b_xxlBottom {
  padding-bottom: 20px;
}
.b_xxxlBottom {
  padding-bottom: 25px;
}
.b_dataList > li > *,
.b_imagePair .b_attribution > *,
.b_factrow > * {
  display: inline;
}
.b_groupLabel {
  padding-bottom: 3px;
}
.b_anno {
  padding-bottom: 20px;
}
.b_anno + .b_rich,
.b_anno + h2 + .b_rich {
  padding-top/* bingcss-ignore: Need to eat the top padding from b_rich */: 0;
}
.b_vPanel > div {
  padding-bottom: 15px;
}
.b_vList > li {
  padding-bottom: 13px;
}
#b_results > li.si_pp,
.sb_hbop,
.b_hide,
#fRmsDefer,
#b_error,
#b_loadingmsg {
  display: none;
}
/* begin vertical lists */

.b_rich > *:last-child,
.b_rich > .b_vList:not(.b_touchable) > li:last-child,
.b_rich > .b_vPanel > div:last-child,
.b_vPanel .b_vList:not(.b_touchable) > li:last-child,
.b_vList .b_vPanel > div:last-child,
.b_hList .b_vList > li:last-child,
.b_hList .b_vPanel > div:last-child,
.b_vList > li > *:last-child:not(a),
/* the last non-link child of vertical list items should have no bottom padding */ .b_vPanel > div > *:last-child:not(a),
/* the last non-link child of vertical stack panel items should have no bottom padding */ .b_subModule > *:last-child,
.b_subModule .b_vPanel > *:last-child,
.b_subModule > .b_vList:last-child > *:last-child,
.b_suppModule > *:last-child,
.b_suppModule .b_vPanel > *:last-child,
.b_infocardContent > .b_vList:last-child > *:last-child,
.b_infocardContent > *:last-child,
.sa_uc > .b_vList > li:last-child,
.sa_uc > .b_vList > li:last-child > .b_vList:last-child > li:last-child,
.b_ans > .b_vList > li:last-child {
  padding-bottom: 0;
}
.b_vlist2col > ul {
  min-width: 40%;
  display: inline-block;
  word-wrap: break-word;
  vertical-align: top;
}
.b_vlist2col > ul:first-child {
  padding-right: 30px;
}
.b_vlist2col li {
  padding-bottom: 15px;
}
/* vertical touchable list adds borders and extra space between items */

.b_touchable > li {
  border-bottom-width: 1px;
  border-bottom-style: solid;
  padding-bottom: 13px;
  margin-bottom: 13px;
}
.b_touchable > li:first-child {
  border-top-width: 1px;
  border-top-style: solid;
  padding-top/* bingcss-ignore:  Top padding is OK before first element in a container */: 15px;
}
.b_rich > .b_touchable:last-child > li:last-child,
.b_vPanel .b_touchable:last-child > li:last-child {
  margin-bottom: 0;
}
/* end vertical lists */

/* horizontal stack panel */

.b_hPanel > span:not(:last-child),
.b_hList > li:not(:last-child) {
  padding-right: 10px;
}
.b_hList > li {
  vertical-align: top;
}
.b_hPanel.wide > span:not(:last-child) {
  padding-right: 20px;
}
.b_suffix {
  padding-left: 10px;
  /* intentionally matches horizontal stack panel spacing */

}
/* begin image/content horizontal pair */

.b_imagePair {
  padding-bottom: 10px;
}
.b_imagePair img {
  vertical-align: bottom;
}
.b_float_img > *:last-child,
.b_imagePair > *:last-child {
  overflow: hidden;
}
.b_float_img > *:first-child,
.b_imagePair > *:first-child {
  margin-right: 10px;
  float: left;
}
.b_floatR_img {
  float: right;
  padding-left: 10px;
}
.b_float_img {
  float: left;
  padding-bottom: 10px;
}
.b_float_img img {
  vertical-align: bottom;
}
.b_imagePair.reverse {
  display: -ms-flexbox;
  display: -webkit-flex;
  display: flexbox;
  display: -webkit-box;
  display: flex;
}
.b_imagePair.reverse > *:first-child {
  -o-box-flex: 1;
  /* opera */
  -webkit-box-flex: 1;
  /* OLD - iOS 6-, Safari 3.1-6 */
  -moz-box-flex: 1;
  /* OLD - Firefox 19- */
  -webkit-flex: 1;
  /* Chrome */
  -ms-flex: 1;
  /* IE 10 */
  flex: 0 1 100%;
  float: none;
}
.b_imagePair.reverse > *:last-child {
  -ms-flex: 0 0 auto;
  flex: 0 0 auto;
}
.b_imagePair.reverse > *:only-child {
  -ms-flex: 1;
  flex: 0 1 100%;
  margin-right: 0;
}
/* vm=vertial middle. This can be used in control/component/views to vertically middle align the content of the element who uses this class. */

.b_vmparent {
  display: -ms-flexbox;
  display: -webkit-flex;
  display: flexbox;
  display: -webkit-box;
  display: flex;
  -webkit-align-items: center;
  align-items: center;
}
/* end image/content horizontal pair */

button,
.button {
  /* The width and style are intentionally set separate so the color is not overridden */
  border-width: 3px;
  border-style: solid;
  padding/* bingcss-ignore TFS: 641967 - Fix existing whitelist files to be complaint with CSS Cop rules */: 8px 18px 12px;
}
.b_hPanel > span,
.b_moreLink,
.b_footnote .cico,
.b_hList > li,
.b_title div,
.csrc/*csrc - Mobile Common Star Rating Control*/ {
  display: inline-block;
}
.b_hPanel > span {
  vertical-align: middle;
}
.b_title h2/* inline title prefix and suffix */ {
  display: inline;
}
.b_title .b_imagePair .rms_img {
  margin-top: 3px;
  /* align with the title */

}
.b_relative {
  position: relative;
}
.b_footnote .cico {
  padding-left: 10px;
}
#b_error div {
  padding-bottom: 20px;
}
/* floats */

.b_mhdr h2,
.b_float {
  float: left;
}
.b_floatR {
  float: right;
}
/* end floats */

.b_rTxt {
  text-align: right;
}
.b_cTxt {
  text-align: center;
}
.b_jTxt {
  text-align: justify;
}
select::-ms-expand {
  display: none;
}
select {
  padding-left: 10px;
  margin-bottom: 15px;
  height: 40px;
  border-radius: 0;
  vertical-align: middle;
  border: 1px solid #bbbbbb;
}
.b_moreLink {
  padding-bottom: 15px;
}
.b_mhdr .b_floatR {
  margin-top/* bingcss-ignore: vertically align floated text in module header */: 4px;
}
.b_mhdr .b_moreLink {
  padding-bottom: 0;
}
.b_algo p,
.b_ans p {
  display: -webkit-box;
  -webkit-box-orient: vertical;
  overflow: hidden;
  -webkit-line-clamp: 3;
}
.b_factrow:after {
  content: "";
}
/* results stack */

#b_results > li,
#b_pole .b_ans {
  padding/* bingcss-ignore:  Top padding is OK before first element in a container */: 13px 10px;
  margin: 0 0 1px;
  border-bottom: 0 solid #e5e5e5;
}
#b_results > li .b_fullb,
#b_pole .b_ans .b_fullb {
  margin-left: -10px;
  margin-right: -10px;
}
#b_results > .b_ans {
  padding-bottom: 13px;
}
#b_results > .b_algo {
  padding-bottom: 13px;
}
#b_results > .b_ad {
  padding-bottom: 0;
}
/* Task 5408580 : Need remove when flight mobvertcard ship */

#b_results > .b_ad + .b_algo,
#b_results > .b_ad + .b_ans {
  padding-top/* bingcss-ignore: Top margin is OK between ads+algo and ads+ans */: 13px;
}
/* Task 5408580 : Need remove when flight mobvertcard ship */

#b_results .b_ans + .b_ad,
#b_results .b_ans + .b_algo,
#b_results .b_ans + .b_ans,
#b_results .b_algo + .b_ans,
#b_results .b_nav + .b_algo {
  margin-top/* bingcss-ignore:  Top margin is OK between ans+ans and ans+algo and algo+ans */: 9px;
  border-top: 0 solid #e5e5e5;
}
#b_results > li > *:last-child,
.b_caption > *:last-child,
.vlist > li:last-child,
.b_vPanel > li:last-child,
.lft > *:last-child {
  margin-bottom: 0;
  padding-bottom: 0;
}
/* Task 5408580 : Need remove when flight mobvertcard ship */

#b_results > .b_pag/* Task 1249184 : [Mobile 1st][wholepage] Paginiation - Remove legacy style after change ajax pagination */ {
  padding/* bingcss-ignore:  Top padding is OK before first element in a container */: 10px 10px;
}
#b_tween/* Task 1249184 : [Mobile 1st][wholepage] Paginiation - Remove legacy style after change ajax pagination */ {
  padding/* bingcss-ignore:  Top padding is OK before first element in a container */: 8px 10px;
  margin: 0 10px;
}
/* end of results stack */

/* related search and deeplink */

#b_results > li > .b_rs,
/*override the rule of #b_results > li > *:last-child which default is 0*/ #b_results > li .b_deep/*override the rule of #b_results > li > *:last-child which default is 0*/ {
  margin-bottom: -15px;
}
.b_deep li > a,
.b_deep li > span > a {
  width: 110px;
  text-overflow: ellipsis;
  display: block;
  white-space: nowrap;
  overflow: hidden;
}
.b_rs > .b_rich {
  padding-bottom: 0;
}
/* end of related search */

.clrfix:after,
/* Task 1249184 : [Mobile 1st][wholepage] Paginiation - Remove legacy style after change ajax pagination */ .crch:after,
.b_imagePair:after,
.b_clearfix:after,
.sb_vdl:after {
  clear: both;
  content: '.';
  display: block;
  visibility: hidden;
  height: 0;
}
/* footer styles */

#ftrLnks li {
  display: inline-block;
  padding: 0 20px 15px 0;
}
#ftrLnks > *:last-child {
  padding-right: 0;
}
footer {
  padding/* bingcss-ignore:  Top padding is OK before first element in a container */: 15px 0 10px 10px;
  border-top: 0;
}
/* begin table */

table {
  width: 100%;
}
th,
td {
  vertical-align: top;
  padding: 0 0 15px 15px;
}
th:first-child,
td:first-child {
  padding-left: 0;
}
th {
  text-align: left;
}
.b_caption > table:last-child tr:last-child td,
.b_caption > .b_vPanel:last-child > div:last-child > table:last-child tr:last-child td {
  padding-bottom: 0;
}
/* end table */

#fti3 {
  margin-bottom: 10px;
}
#id_rwds_b {
  margin-bottom: 15px;
  display: inline-block;
}
/*Label item styles*/

.b_label {
  padding-right: 5px;
}
/*Input button styles*/

.cbtn input {
  -webkit-appearance: none;
  border-radius: 0;
  border: 1px solid #bbbbbb;
  min-width: 50px;
  max-width: 100%;
  height: 40px;
  padding: 0 15px;
  margin: 0 0 10px 0;
  white-space: nowrap;
  display: inline-block;
}
.cbtn input,
.cbtn input.b_highlighted:focus {
  outline: none;
}
/*SubModule and SupplementaryModule*/

.b_subModule,
.b_suppModule {
  padding/* bingcss-ignore:  Top padding is OK before first element in a container */: 13px 0;
  border-bottom-width: 1px;
  border-bottom-style: solid;
}
.b_subModule h2 {
  padding-bottom: 10px;
}
.b_subModule h2.b_headerTitle {
  padding-bottom: 5px;
}
/*End SubModule and SupplementaryModule*/

.nowrap {
  white-space: nowrap;
}
.pushpin {
  border-radius: 9px;
  text-align: center;
  width: 16px;
  height: 16px;
  margin-top: 2px;
  padding-bottom: 0;
  /* override label padding */
  line-height: 16px;
}
#b_results .b_no {
  margin-bottom: 80px;
}
.b_no h1,
.b_no h4,
.b_no li {
  padding-bottom: 10px;
}
.b_factrow .csrc {
  margin-right: 5px;
}
.sw_next,
.sw_prev {
  display: none;
}
.sb_pagIconN,
.sb_pagIconP {
  margin-top: 2px;
}
.b_entitySubTitle {
  margin-top: -9px;
  padding-bottom: 10px;
}
#sb_dir {
  flex-grow: 1;
}
.b_clear {
  clear: both;
}
div#b_pole {
  margin-bottom: 10px;
}
#b_pole .b_ans + .b_ans {
  margin-top/* bingcss-ignore:  Top margin is OK between ans+ans and ans+algo and algo+ans */: 9px;
}
/*This file is intentionally left empty*/
z
{
    a:1;
}/*This file is intentionally left empty*/
z
{
    a:1;
}/*This file is intentionally left empty*/
z
{
    a:1;
}/*This file is intentionally left empty*/
z
{
    a:1;
}/* header colors for mobile threshold */

.b_scopebar {
  background-color: #e5e5e5;
}
.b_scopebar,
.b_scopebar a,
.b_scopebar a:visited,
.b_mystuff:before,
#b_header .b_symb {
  color: #666666;
}
.b_scopebar li.b_active a,
.b_scopebar li.b_active a:visited,
.b_scopebar span {
  border-color: transparent;
  color: #111111;
}
.b_scopebar a,
.b_scopebar span
{
    text-decoration: none;
    text-transform:uppercase;
}

.b_mystuff
{
    font-size:12px;
    line-height: 16px;
    height: 18px;
}

.b_mystuff:before
{
    font-size:16px;
    vertical-align: middle;
}

.b_scopebar a
{
    text-transform: capitalize;
}/* Scopebar styles */

#b_header:not(:empty) {
  border-bottom: 1px solid #e5e5e5;
  position: fixed;
  top: 0;
  width: 100%;
  z-index/* bingcss-ignore: to keep consistent with legacy mobile */: 1000;
}
#b_header .b_symb {
  float: left;
  margin: 10px 10px 0 10px;
}
.b_scopebar li {
  margin: 0 10px;
  /* Use margin for sides instead of padding so the active bottom border displays correctly. */
  display: inline-flex;
}
.b_scopebar li:last-child,
.b_mystuff {
  margin-right: 12px;
  flex: none;
}
.b_scopebar li:first-child {
  margin-left: 12px;
}
.b_scopebar ul {
  overflow-x: auto;
  white-space: nowrap;
  -ms-overflow-style: none;
}
.b_scopebar a,
.b_scopebar span,
.b_mystuff {
  padding/* bingcss-ignore: vertically align with padding */: 12px 0;
}
.b_scopebar li.b_active a,
.b_scopebar li.b_active span {
  padding-bottom: 10px;
  border-bottom-width: 2px;
  border-bottom-style: solid;
}
@media screen and (min-width: 641px) {
  #b_header nav li:first-child {
    margin-left: 0;
  }
  #b_header nav li:last-child {
    margin-right: 0;
  }
  #b_header nav,
  header nav {
    padding: 0 24px;
  }
}
.b_mystuff {
  display: block;
  text-align: right;
}
.b_mystuff:before {
  padding-right: 12px;
}
.linkAction {
  padding-bottom: 24px;
}
/*This file is intentionally left empty*/
z
{
    a:1;
}.b_accentColor,.b_accentColor strong,strong.b_accentColor,strong .b_accentColor,.qcard a,#sb_feedback,.b_anno,.appifyCaptionAccent,#b_results a.b_accentColor,#b_results a.b_accentColor:visited{color:#1ba0e1;}.b_accentColorStroke{stroke:#1ba0e1;}.b_accentColorFill{fill:#1ba0e1;}input[type="text"]:focus{border-color:#1ba0e1;}.b_accentColorBackground,select:active,.cbtn.b_highlighted input.b_accentColorBackground{background-color:#1ba0e1;}.b_accentColorBorder{border-color:#1ba0e1;}</style><script type="text/javascript">//<![CDATA[
// Declaring Feature Team ID for Win8App Error Handling
// <feature  id="8"  />
var amd;
(function (amd) {
    var defineMap = {};
    var cache = {};
    var initialized = false;
    function define(moduleName, dependencies, callback) {
        if (!defineMap[moduleName]) {
            defineMap[moduleName] = {
                dependencies: dependencies,
                callback: callback
            };
            // Invoke this module as it is registered
            require(moduleName);
        }
    }
    function require(requestedModuleName) {
        if (!requestedModuleName) {
            // Initialize all the modules and return the cache
            if (!initialized) {
                for (var moduleName in defineMap) {
                    requireModule(moduleName);
                }
                initialized = true;
            }
            return cache;
        }
        else if (requestedModuleName) {
            // Initialize just the module asked for
            return requireModule(requestedModuleName);
        }
    }
    function requireModule(moduleName) {
        // This should break the recursion in case of circular dependency
        if (cache[moduleName]) {
            return cache[moduleName];
        }
        // If the module has a define entry
        if (defineMap.hasOwnProperty(moduleName)) {
            // Create this module
            var moduleDetails = defineMap[moduleName];
            var deps = moduleDetails.dependencies;
            var callback = moduleDetails.callback;
            // add req and exports as first two dependencies
            var req = require;
            var exports = {};
            var dependencies = [req, exports];
            if (deps.length < 2) {
                throw "invalid usage";
            }
            else if (deps.length > 2) {
                // Recursively fetch dependencies
                var dependentModules = deps.slice(2, deps.length);
                for (var i = 0; i < dependentModules.length; i++) {
                    dependencies.push(requireModule(dependentModules[i]));
                }
            }
            // Call the callback -- this should add objects to exports
            // This means we do not support the callback itself returning an object.
            // It should be simple to support that. For now, STRADA generates
            // exports syntax.
            callback.apply(this, dependencies);
            // Cache the module
            cache[moduleName] = exports;
            return exports;
        }
    }
    amd.define = define;
    amd.require = require;
})(amd || (amd = {}));
var define = amd.define;
var require = amd.require;
;/// <reference path='../Declarations/Threshold.Utilities.d.ts' />
/// <reference path="../../../../../Threshold/src/Content/Script/Declarations/SearchAppWrapper.d.ts" />
// BUGBUG: TFS 780914: TypeScript throws build error when two ts file declare the same variable
var _w = window, _d = document, sb_ie = window["ActiveXObject"] !== undefined, sb_i6 = sb_ie && !_w["XMLHttpRequest"], _ge = function (id) { return _d.getElementById(id); }, sb_st = function (code, delay) { return setTimeout(code, delay); }, sb_rst = sb_st, sb_ct = function (id) {
    clearTimeout(id);
}, sb_gt = function () { return new Date().getTime(); }, sj_gx;
_w["sj_ce"] = function (tagName, id, cssClass) {
    var el = _d.createElement(tagName);
    if (id) {
        el.id = id;
    }
    if (cssClass) {
        el.className = cssClass;
    }
    return el;
};
// Under certain circumstances the clientCookies script
// fails to get added from frontdoor. Declaring sk_merge
// if it isn't already defined.
if (!_w["sk_merge"]) {
    _w["sk_merge"] = function (cookieHeader) {
        _d.cookie = cookieHeader;
    };
}
var AjaxWrapperThreshold = (function () {
    function AjaxWrapperThreshold() {
    }
    AjaxWrapperThreshold.applyMethodThatRequiresOpened = function (xhrObject, method, originalArguments) {
        /* send and setRequestHeader can only be done on xhr requests that are currently opened: http://www.w3.org/TR/2009/WD-XMLHttpRequest-20090820/#opened-state */
        if (xhrObject.readyState == xhrObject.OPENED) {
            method.apply(xhrObject, originalArguments);
            return true;
        }
        return false;
    };
    AjaxWrapperThreshold.wrapSend = function (originalObject, originalMethod) {
        var wrappedMethod = function () {
            var originalArguments = arguments;
            if (!AjaxWrapperThreshold.isRequestBlocked(originalObject) && originalObject.readyState == originalObject.OPENED) {
                // If we're sending to bing, we need to append custom client headers.
                // Some old Threshold app webviews do not have a SearchAppWrapper.  Those can just make the XHR call directly and hope for the best.
                if (typeof ThresholdUtilities !== "undefined" && SearchAppWrapper && SearchAppWrapper.CortanaApp && AjaxWrapperThreshold.hostIsBing(originalObject.url)) {
                    ThresholdUtilities.getCortanaHeaders(function (headers) {
                        if (headers) {
                            var xhrHeaders = originalObject[AjaxWrapperThreshold.headersLocation];
                            for (var headerName in headers) {
                                if (headers.hasOwnProperty(headerName) && (headerName.substring(0, 2) === "X-" || AjaxWrapperThreshold.copyableHeaders.indexOf(headerName) >= 0)) {
                                    if (!xhrHeaders[headerName]) {
                                        originalObject.setRequestHeader(headerName, headers[headerName]);
                                    }
                                }
                            }
                        }
                        AjaxWrapperThreshold.setFlightHeaders(originalObject);
                        AjaxWrapperThreshold.applyMethodThatRequiresOpened(originalObject, originalMethod, originalArguments);
                    });
                }
                else {
                    if (AjaxWrapperThreshold.hostIsBing(originalObject.url)) {
                        AjaxWrapperThreshold.setFlightHeaders(originalObject);
                    }
                    AjaxWrapperThreshold.applyMethodThatRequiresOpened(originalObject, originalMethod, originalArguments);
                }
            }
            else {
                // If we need to block the send we simulate that we did it successfully so no retries are triggered.
                Object.defineProperties(originalObject, {
                    "readyState": { get: function () {
                        return 4;
                    } },
                    "status": { get: function () {
                        return 200;
                    } },
                    "responseText": { get: function () {
                        return "";
                    } },
                    "responseBody": { get: function () {
                        return "";
                    } }
                });
                if (originalObject.onreadystatechange) {
                    originalObject.onreadystatechange.apply(originalObject, null);
                }
            }
        };
        return wrappedMethod;
    };
    AjaxWrapperThreshold.wrapOpen = function (originalObject, originalMethod) {
        var wrappedMethod = function () {
            // We always pass through open calls, but we record the url on the object.
            originalObject.url = arguments[1];
            originalMethod.apply(originalObject, arguments);
        };
        return wrappedMethod;
    };
    AjaxWrapperThreshold.wrapSetRequestHeader = function (originalObject, originalMethod) {
        return function (headerKey, headerValue) {
            var successfulApply = AjaxWrapperThreshold.applyMethodThatRequiresOpened(originalObject, originalMethod, arguments);
            if (successfulApply) {
                var originalObjectHeaders = originalObject[AjaxWrapperThreshold.headersLocation];
                if (originalObjectHeaders[headerKey]) {
                    originalObjectHeaders[headerKey].push(headerValue);
                }
                else {
                    originalObjectHeaders[headerKey] = [headerValue];
                }
            }
            return successfulApply;
        };
    };
    AjaxWrapperThreshold.hostIsBing = function (url) {
        // Assume it's Bing if we can't prove otherwise
        var returnValue = true;
        AjaxWrapperThreshold.testAnchor.href = url;
        var hostName = AjaxWrapperThreshold.testAnchor.hostname;
        if (hostName && hostName.indexOf(".") > 0) {
            var matchedAnyHost = false;
            for (var i in this.bingHosts) {
                if (hostName.indexOf(this.bingHosts[i]) > 0) {
                    matchedAnyHost = true;
                    break;
                }
            }
            if (!matchedAnyHost) {
                returnValue = false;
            }
        }
        return returnValue;
    };
    AjaxWrapperThreshold.blockRequestWrapper = function (originalObject) {
        var _this = this;
        return function () {
            return _this.isRequestBlocked(originalObject);
        };
    };
    AjaxWrapperThreshold.isRequestBlocked = function (originalObject) {
        return typeof SearchAppWrapper !== "undefined" && SearchAppWrapper && SearchAppWrapper.CortanaApp && !SearchAppWrapper.CortanaApp.isBingEnabled && AjaxWrapperThreshold.hostIsBing(originalObject.url);
    };
    AjaxWrapperThreshold.createAjaxWrapper = function () {
        var wrappedObject = new XMLHttpRequest();
        wrappedObject[this.headersLocation] = {};
        wrappedObject.send = this.wrapSend(wrappedObject, wrappedObject.send);
        wrappedObject.open = this.wrapOpen(wrappedObject, wrappedObject.open);
        wrappedObject.setRequestHeader = this.wrapSetRequestHeader(wrappedObject, wrappedObject.setRequestHeader);
        wrappedObject.isRequestBlocked = this.blockRequestWrapper(wrappedObject);
        return wrappedObject;
    };
    AjaxWrapperThreshold.setFlightHeaders = function (request) {
        // set http headers for setting external flights
        if (typeof (_CachedFlights) !== "undefined" && _CachedFlights.sort) {
            var headersSet = request[AjaxWrapperThreshold.headersLocation];
            if (!headersSet[AjaxWrapperThreshold.externalExpType]) {
                request.setRequestHeader(AjaxWrapperThreshold.externalExpType, "JointCoord");
            }
            if (!headersSet[AjaxWrapperThreshold.externalExp]) {
                request.setRequestHeader(AjaxWrapperThreshold.externalExp, _CachedFlights.sort().join(","));
            }
        }
    };
    AjaxWrapperThreshold.bingHosts = [".bing.com", ".staging-bing-int.com", ".working-bing-int.com", ".bing-int.com", ".bing-exp.com"];
    AjaxWrapperThreshold.testAnchor = document.createElement("a");
    AjaxWrapperThreshold.externalExpType = "X-MSEdge-ExternalExpType";
    AjaxWrapperThreshold.externalExp = "X-MSEdge-ExternalExp";
    AjaxWrapperThreshold.headersLocation = "headers";
    AjaxWrapperThreshold.copyableHeaders = ["Authorization"];
    return AjaxWrapperThreshold;
})();
sj_gx = function () { return AjaxWrapperThreshold.createAjaxWrapper(); };
;///<reference path="..\Declarations\Shared.d.ts"/>
function lb() {
    _w["si_sendCReq"] && sb_st(_w["si_sendCReq"], 800);
    // look for any other scripts that needs to be called/initialized, and call them
    // we need a cleaner way to allow other scripts to register for a callback during onload
    // initialization (Bug 94997)
    _w["lbc"] && _w["lbc"]();
}
;///<reference path="..\Declarations\Shared.d.ts"/>
// This files modifies appendChild function to check if a SCRIPT tag is being appended.
// If yes and the script tag does not have a src attribute i.e. it is an inlined script
// then a "//@ sourceURL=BingDynamicScriptX.js" comment is added to the script so that
// modern browsers can parse it and add it to the javascript sources in debug window.
(function () {
    var scriptCount = 0;
    var scriptPrefix = "//@ sourceURL=BingDynamicScript";
    var scriptSuffix = ".js\n";
    if (window["Element"] && Element.prototype && window.location.pathname.indexOf("/mapspreview") !== 0) {
        var appendChild = Element.prototype.appendChild;
        Element.prototype.appendChild = function (elem) {
            if (elem && elem.tagName === "SCRIPT" && !elem.src && elem.textContent) {
                // Adding the sourceURL comment to the beginning of the file in case someone already
                // has this logic for their specific file then the latest one will take effect
                elem.textContent = scriptPrefix + scriptCount + scriptSuffix + elem.textContent;
                scriptCount++;
            }
            return appendChild.apply(this, arguments);
        };
    }
})();
;
//]]></script><script type="text/javascript" src="/rms/BingCore.Bundle/nj/55a93bd5/a3f7810d.js?bu=rms+answers+Shared+BingCore%24ClientInstV2%24DuplicateXlsDefaultConfig%2cBingCore%24ClientInstV2%24SharedLocalStorageConfigDefault%2cBingCore%24shared%2cBingCore%24env.override%2cBingCore%24debug.noop%2cBingCore%24event.custom.nodep%2cBingCore%24event.native%2cBingCore%24dom%2cBingCore%24cookies_parser%2cBingCore%24XHRPrefetch%24rmsajax_xhrprefetch%2cBingCore%24ClientInstV2%24InstrumentationConfigDefault%2cBingCore%24ClientInstV2%24LogUploadCapFeatureDisabled%2cBingCore%24ClientInstV2%24ClientInstConfigSeparateOfflineQueue%2cBingCore%24ClientInstV2%24clientinst_xls%2cEmpty%2cBingCore%24CoreUtilities%2cBingCore%24ClientInstV2%24LogHelper%2cBingCore%24ClientInstV2%24VisibilityChangeEventHelper%2cBingCore%24Animation%2cBingCore%24fadeAnimation%2cBingCore%24framework%2cBingCore%24ShowWebView%2cBingCore%24ClientInstV2%24LogOfflineFalseConfig%2cBingCore%24mobile2cortanahooks"></script><script type="text/javascript">//<![CDATA[
var SloppyClickHandler;
(function (SloppyClickHandler) {
    var listTag = ["LI", "TR"];
    var tableTag = ["TR"];
    var anchorTag = ["A"];
    var inputTag = ["INPUT", "SELECT"];
    var getElementsByTagName = "getElementsByTagName";
    var notTargetElementClass = "b_noTarget";
    var poleContainerClassName = "b_poleContent";
    var space = " ";
    function findCardFromElement(element) {
        var link = getParentContainer(element, anchorTag);
        var returnObject = { element: element, card: link, link: link, containsLink: true };
        var input = getParentContainer(element, inputTag);
        if (!input) {
            var card = getParentContainer(element, listTag, poleContainerClassName);
            if (card) {
                // If there's only one viable link in the entire LI then we'll use it by default
                var viableLink = findLinkInAnchorTags(card);
                // If the link is not found in the table, try again at levels above it
                // Won't work for nested tables or lists
                if (!viableLink && tableTag.indexOf(card.tagName) >= 0) {
                    card = getParentContainer(card.parentNode, listTag, poleContainerClassName);
                    viableLink = findLinkInAnchorTags(card);
                }
                // If there's more than one link we still need to see if there's a header common control.  If there's a single
                // header control we're willing to shift the click to that.
                if (!viableLink && card && _w['TCH']) {
                    var reservedTags = _w['TCH'].rTags;
                    for (var i = 0; i < reservedTags.length; i++) {
                        viableLink = getViableLinkFromList(card[getElementsByTagName](reservedTags[i]));
                        if (viableLink) {
                            break;
                        }
                    }
                }
                if (viableLink && (!link || viableLink === link)) {
                    returnObject = { element: element, card: card, link: viableLink, containsLink: true };
                }
            }
        }
        else {
            returnObject = null;
        }
        // Don't return anything if we don't have a link.
        if (returnObject && !returnObject.link) {
            returnObject = null;
        }
        // If we have a link, but it's the same as or a parent of our source element we mark the object as non-clickable.
        // Clicking is not required here as normal event bubbling will work.
        // But we do need to track the object still, as it is animatable.
        if (returnObject && (containsElement(returnObject.link, element) || returnObject.link === returnObject.element)) {
            returnObject.containsLink = false;
        }
        return returnObject;
    }
    SloppyClickHandler.findCardFromElement = findCardFromElement;
    var containsElement = function (parent, element) {
        if (element) {
            var candidates = parent[getElementsByTagName](element.tagName);
            for (var i = 0; i < candidates.length; i++) {
                if (candidates[i] === element) {
                    return true;
                }
            }
        }
        return false;
    };
    var getViableLinkFromList = function (elements) {
        var viableLink = null;
        for (var i = 0; i < elements.length; i++) {
            var possibleLink = findLinkInAnchorTags(elements[i]);
            if (possibleLink) {
                if (!viableLink) {
                    viableLink = possibleLink;
                }
                else if (possibleLink.href !== viableLink.href) {
                    // We found more than one heading with a viable link - the click is ambiguous so there is no click.
                    viableLink = null;
                    break;
                }
            }
            else if (elements[i][getElementsByTagName](anchorTag).length > 1) {
                // A single header has more than one link, and they're not viable - we're confused so we stop.
                viableLink = null;
                break;
            }
        }
        return viableLink;
    };
    var isViableLink = function (element) { return element && element.className.indexOf(notTargetElementClass) < 0; };
    var findLinkInAnchorTags = function (element) {
        var viableLink = null;
        if (element) {
            var anchorTags = element[getElementsByTagName](anchorTag);
            var anchorTagCount = anchorTags.length;
            var linksMatch = true;
            var matchingLink = null;
            var firstLinkUrl = null;
            for (var i = 0; i < anchorTagCount; i++) {
                /* Only compare the viable links */
                if (isViableLink(anchorTags[i])) {
                    if (!firstLinkUrl) {
                        matchingLink = anchorTags[i];
                        firstLinkUrl = anchorTags[i].href;
                    }
                    else if (firstLinkUrl !== anchorTags[i].href) {
                        linksMatch = false;
                        break;
                    }
                }
            }
            /* We need to have found at least one viable link */
            if (linksMatch && firstLinkUrl) {
                viableLink = matchingLink;
            }
        }
        return viableLink;
    };
    var getParentContainer = function (target, tags, className) {
        for (; target !== document && target; target = target.parentNode) {
            if (target) {
                for (var i = 0; i < tags.length; ++i) {
                    if (target.tagName === tags[i] || (className && target.className && (space + target.className + space).indexOf(space + className + space) >= 0)) {
                        return target;
                    }
                }
            }
        }
    };
})(SloppyClickHandler || (SloppyClickHandler = {}));
;///<reference path="..\Declarations\Shared.d.ts"/>
///<reference path="..\..\..\..\..\Web\Content\Content\Script\Declarations\SloppyClickHandler.d.ts"/>
// See Hyperlink and FdHyperlink at the FD for what this all means
// BUGBUG: TFS 780914: TypeScript throws build error when two ts file declare the same variable
_w["si_ct"] = function (el, noRecurse, evt) {
    var getAttribute = "getAttribute", ct, ctf, found;
    try {
        for (; el !== document.body; el = el.parentNode) {
            // The 'h' or '_ct' attribute contains the payload for the click tracking function
            // Stop on the first anchor with an 'h' attribute or the first element found with a '_ct' attribute present
            ct = (el.tagName == "A" && el[getAttribute]("h")) || el[getAttribute]("_ct") || el[getAttribute]("data-h");
            if (ct) {
                // The '_ctf' attribute contains the name of the overriden global click
                // tracking function which is optional, default is si_T
                ctf = el[getAttribute]("_ctf");
                var clickType = -1;
                if (evt != null && evt.button != null) {
                    clickType = evt.button;
                }
                if (!ctf || !_w[ctf]) {
                    ctf = "si_T";
                }
                // Try to fire the gping by calling the click-tracking function with the 'ct' payload and the clicked element
                _w[ctf] && _w[ctf]('&' + ct, el, evt, clickType);
                break;
            }
            if (noRecurse)
                break;
        }
    }
    catch (ignored) {
    }
    return true;
};
(function () {
    function leftClickHandler(evt) {
        _w["si_ct"](sb_ie ? _w.event.srcElement : evt.target, false, _w.event || evt);
    }
    function rightClickHandler(evt) {
        var clickedObject = _w["SloppyClickHandler"] ? SloppyClickHandler.findCardFromElement(sj_et(evt)) : null;
        var target = (clickedObject && clickedObject.link) ? clickedObject.link : (sb_ie ? _w.event.srcElement : evt.target);
        _w["si_ct"](target, false, _w.event || evt);
    }
    if (_w["_G"]) {
        _G["si_ct_e"] = "click";
    }
    // sj_be: Indicates bubble-phase handler (supported on all browsers as opposed to capture which IE doesn't support)
    sj_be(document, "click", leftClickHandler, false);
    sj_be(document, "contextmenu", rightClickHandler, false);
})();
;var wlc_d = 1500, wlc_t =63609952226;;///<reference path="..\..\..\answers\services\Shared\Content\Content\script\Declarations\Shared.d.ts"/>
// IE11 with window.external.IsMetaReferrerAvailable has ability to interprate meta referrer tag.
if (!_w.external || !("msIsMetaReferrerAvailable" in _w.external)) {
    _w["rdr_T"] = function (kValue, el, evt) {
        evt = evt || _w.event;
        var sendDefaultGping = true;
        var getAttribute = "getAttribute";
        var setAttribute = "setAttribute";
        var MUID = "MUID";
        var host = location.host;
        var protocol = location.protocol.toLowerCase();
        // force bing protocol only if we are on http
        protocol = protocol === "http:" ? protocol : "";
        var gpUrl = host + "/cr?";
        // Do not modify HREF on right-clicks to support copying and sharing of link URL
        if (evt && (evt.button < 2) && (el = (el || (evt.target || evt.srcElement)))) {
            for (; el !== _d.body; el = el.parentNode) {
                if (el.tagName == "A")
                    break;
            }
            // TFS 1224001: use "ID" instead of "p" parameter for K-Value on Edge redirection end-point
            var modifiedKValue = kValue.replace("ID=", "p=");
            // read url hash
            var hash = el[getAttribute]("_h");
            var version = el[getAttribute]("_v");
            var linkHost = el.host;
            // Do not render new redirect url if the target url is internal
            var isInternal = linkHost === host;
            if (hash && version && !isInternal) {
                var href = el[getAttribute]("href");
                var url = (protocol || el.protocol || "http:") + "//" + gpUrl + "h=" + hash + "&v=" + version + "&r=" + encodeURIComponent(href) + '&IG=' + _G.IG;
                // Passing MUID value if it's available in the document cookie
                var muid;
                if (_w["sj_cook"] && (muid = sj_cook.get(MUID))) {
                    // the value of muid looks like "MUID=123456...", so "MUID=" needs to be stripped off
                    url += "&CID=" + muid.substring(5);
                }
                // Passing query string parameters if the link is an ad
                // r.msn.com will include: adcenter.msn.com, r.msn.com
                var query;
                if ((linkHost.indexOf("r.msn.com") >= 0 || linkHost.indexOf("r.bing.com") >= 0 || linkHost.indexOf("rd.listing.yahoo.co.jp") >= 0) && (query = getQuery())) {
                    url += "&q=" + query;
                    modifiedKValue = modifiedKValue.replace(",Ads", "");
                }
                url += modifiedKValue;
                var tagKval = el[getAttribute]("h");
                // Check to make sure that the link is not just adding a hash.
                // Here we look at the query string match. There could be a scenario where 
                // pathname or host might be different but query string is same. Since this
                // is extremely rare scenario favoring simplicity of check (IE for relative 
                // url returns empty pathname and host) over enabling gping redirection for 
                // these cases. 
                var isHash = el.hash ? el.search === _w.location.search : false;
                // Edge appears to ignore any URL requests that have query string greater than 2048 characters
                // This behavior is unique to Edge and r.msn.com doesn't suffer from the same limitation
                // While we figure out a fix on Edge side, updating code below to fall back to legacy perf-ping whenever this edge case
                if (tagKval && ("&" + tagKval) === kValue && el.protocol && el.protocol.indexOf('http') > -1 && url.length < 2048 && href.indexOf(".pdf", href.length - 4) === -1 && !isHash) {
                    // Disable legacy gping now that all checks have passed
                    // and we are ready to update href
                    sendDefaultGping = false;
                    // don't re-update the href if it's already been updated
                    if (href && href.indexOf(gpUrl) < 0) {
                        el[setAttribute]("href", url);
                    }
                }
            }
        }
        if (sendDefaultGping && _w["si_T"]) {
            _w["si_T"](kValue);
        }
        function getQuery() {
            var re = new RegExp("[\?&]{1}q=([^&]+)");
            var match = location.search.match(re);
            return match ? match[1] : null;
        }
        return true;
    };
}
;var perf;
(function (perf) {
    var perfKeyArray = [
        "redirectStart",
        "redirectEnd",
        "fetchStart",
        "domainLookupStart",
        "domainLookupEnd",
        "connectStart",
        "secureConnectionStart",
        "connectEnd",
        "requestStart",
        "responseStart",
        "responseEnd",
        "domLoading",
        "domInteractive",
        "domContentLoadedEventStart",
        "domContentLoadedEventEnd",
        "domComplete",
        "loadEventStart",
        "loadEventEnd",
        "unloadEventStart",
        "unloadEventEnd",
        "firstChunkEnd",
        "secondChunkStart",
        "htmlEnd",
        "pageEnd",
        "msFirstPaint"
    ];
    var versionString = "v:1.1";
    // For now the key compression is based on array index. The assumption is 
    // that this is a fixed list that will not change often and tightly contolled.
    // This is not very flexible as any addition in between can essentially
    // break the reporting side. Two possible solutions to try would be to
    // have the keyMap logged in nif. Advantage of this would be it is easy to
    // maintain but the disadvantage is no real time reporting. The other way
    // to have a package that defines the keyMap. Advantage is the keyMap can 
    // be consumed by multiple sources but the disadvantage is it would need 
    // version control.
    var perfKeyMap = {};
    var i;
    for (i = 0; i < perfKeyArray.length; i++) {
        perfKeyMap[perfKeyArray[i]] = i;
    }
    function compressKey(key) {
        return perfKeyMap.hasOwnProperty(key) ? perfKeyMap[key] : key;
    }
    function typeToString(type) {
        var typeString = "S";
        if (type == 0 /* Mark */) {
            typeString = "P";
        }
        else if (type == 2 /* Measure */) {
            typeString = "M";
        }
        return typeString;
    }
    // Creates an array of strings that are essentially are of the form "${key}:${value}"
    function compress(q) {
        var data = [];
        var typeArrays = {}, typeArray;
        for (var i = 0; i < q.length; i++) {
            var obj = q[i];
            var value = obj.v, qType = obj.t, key = obj.k;
            if (qType === 0 /* Mark */) {
                key = compressKey(key);
                value = value.toString(36);
            }
            if (qType === 3 /* None */) {
                data.push("" + key + ":" + value);
            }
            else {
                typeArray = typeArrays[qType] = typeArrays[qType] || [];
                typeArray.push("" + key + ":" + value);
            }
        }
        for (var t in typeArrays) {
            if (typeArrays.hasOwnProperty(t)) {
                typeArray = typeArrays[t];
                data.push("" + typeToString(t) + ":\"" + typeArray.join(",") + "\"");
            }
        }
        data.push(versionString);
        return data;
    }
    perf.compress = compress;
})(perf || (perf = {}));
;///<reference path="..\..\..\..\..\Shared\Content\Content\script\Declarations\Shared.d.ts"/>
window["perf"] = window["perf"] || {};
(function (perf) {
    perf.log = function (perfData, time) {
        var data = perf.compress(perfData);
        data.push("T:\"CI.Perf\",FID:\"CI\",Name:\"PerfV2\"");
        var url = "/fd/ls/lsp.aspx?";
        var sendBeacon = "sendBeacon";
        // if eventData contains the raw string "]]>", it'll end the CDATA section prematurely
        var eventXML = "<E><T>Event.ClientInst</T><IG>" + _G.IG + "</IG><TS>" + time + "</TS><D><![CDATA[{" + data.join(",") + "}]]></D></E>";
        var xml = "<ClientInstRequest><Events>" + eventXML + "</Events><STS>" + time + "</STS></ClientInstRequest>";
        if (!_w.navigator || !navigator[sendBeacon] || !navigator[sendBeacon](url, xml)) {
            var request = sj_gx();
            request.open("POST", url, true);
            request.setRequestHeader("Content-Type", "text/xml");
            request.send(xml);
        }
    };
})(window["perf"]);
;///<reference path="..\..\..\..\..\Shared\Content\Content\script\Declarations\Shared.d.ts"/>
var perf;
(function (perf) {
    var perfName = "performance";
    var hasPerformanceObject = !!_w[perfName];
    var perfObj = _w[perfName];
    var highResTimeAvailable = hasPerformanceObject && !!perfObj.now;
    var roundOf = Math.round;
    var q = [];
    // The data is only flushed after the first time flush is called.
    // We bind flush to onload so that pings are restricted to before onload.
    var firstFlushCalled = false;
    var navigationStart;
    var startTimestamp;
    if (hasPerformanceObject) {
        navigationStart = startTimestamp = perfObj.timing.navigationStart;
    }
    else {
        startTimestamp = _w["si_ST"] ? _w["si_ST"] : +new Date();
    }
    function createUniqueId() {
        return roundOf(Math.random() * 10000);
    }
    var uniqueId = createUniqueId();
    function getTime() {
        if (highResTimeAvailable) {
            return roundOf(perfObj.now()) + navigationStart;
        }
        else {
            return +new Date;
        }
    }
    function queue(key, value, qType) {
        if (q.length === 0 && firstFlushCalled) {
            sb_st(flush, 1000);
        }
        q.push({ k: key, v: value, t: qType });
    }
    function setStartTime(time) {
        if (!firstFlushCalled) {
            startTimestamp = time;
        }
        return !firstFlushCalled;
    }
    perf.setStartTime = setStartTime;
    function mark(key, value) {
        if (!value) {
            value = getTime();
        }
        queue(key, value, 0 /* Mark */);
    }
    perf.mark = mark;
    function record(key, value) {
        queue(key, value, 1 /* Record */);
    }
    perf.record = record;
    function flush() {
        if (q.length) {
            for (var i = 0; i < q.length; i++) {
                var obj = q[i];
                if (obj.t === 0 /* Mark */) {
                    obj.v -= startTimestamp;
                }
            }
            q.push({ k: "id", v: uniqueId, t: 3 /* None */ });
            perf.log(q, getTime());
            q = [];
            firstFlushCalled = true;
        }
    }
    perf.flush = flush;
    function reset() {
        startTimestamp = getTime();
        uniqueId = createUniqueId();
        firstFlushCalled = false;
        sj_evt.bind("onP1", flush);
    }
    perf.reset = reset;
    sj_be(window, "load", flush, false);
    sj_be(window, "beforeunload", flush, false);
})(perf || (perf = {}));
;///<reference path="..\..\..\..\..\..\Shared\Content\Content\script\Declarations\Shared.d.ts"/>
// Performance ping instrumentation for browsers supporting the W3C Web Timing API.
// si_PP() is the PerformancePing function used to report back performance data.
// currentTime - a javascript Date object
// state - "A" for abandoned, "L" for load.
// This function is called after pageload. However, some verticals may
// choose to call it at a different time, after setting the sb_ppCPL (custom page load) flag
_w.si_PP = function (currentTime, state, ajaxRequest) {
    // Only fire one perf ping
    if (_G.PPS) {
        return;
    }
    // Include the impression GUID (IG)
    // The DATA field contains a JSON blob of the event.
    // pp is the name of the event.
    // S is the status to report, from parameter b.
    // PC is the elapsed time between when the <BODY> tag is opened (_G.PCT) and the start time
    // FC is the elapsed time between when the first chunk is complete (_G.FCT) and the start time.
    //    For non-CTE rendering, the value is -1
    // BC is the elapsed time between when the second chunk arrives (_G.BCT) and the start time.
    //    If there is no second chunk, the timer is inserted right after _G.PPCT
    // BS is the elapsed time between right before the BOP scripts are inserted (_G.BST) and the start time
    // H is the elapsed time between when the HTML finished being downloaded and the last inline script got executed (_G.HT), and the start time
    // FE is the elapsed time between the beginning of the first embeded image chunk and the start time, if there are embedded image chunks
    //    Otherwise, the value is -1
    // LE is the elapsed time between the end of last embedded image chunk and the start time, if there are embedded image chunks
    //    Otherwise, the value is -1
    // C1 and C2 are custom ppMetrics, available in each vertical to be overridden with vertical specific elapsed times from the start time.
    //    To use, a page can simply set
    //           _G.C1T=new Date()
    // BP is the elapsed time between when the pageLoad event begins (_G.BPT) and the start time.
    // KP is the page's KeyPoint - the point the page's owner has decided is key to users.
    //    For example, on the SERP, this could be when web results and top answers are loaded, but not BOP answers.
    //    To use, insert the following in-lined JS to the place of interest
    //           _G.KPT=new Date()
    // CT is the total client elapsed time to "Page Load", calculated from the difference between the currentTime parameter and _G.ST
    // IL is the numbers of images
    // If CID is explicitly specified in the response
    //    it should be included in our instrumention as well
    // Collect a small number of PerfPing Metrics
    // --------------------------------------------------
    var key;
    var ppMetrics = ['FC', 'BC', 'H', 'BP', null];
    while (key = ppMetrics.shift()) {
        ppMetrics.push('"' + key + '":' + (_G[key + 'T'] ? _G[key + 'T'] - _G.ST : -1));
    }
    // --------------------------------------------------
    var w3cTimings = ajaxRequest || (_w.performance && _w.performance.timing);
    var w3cPayload = null;
    if (w3cTimings) {
        var w3cFields = [
            "unloadEventStart",
            "unloadEventEnd",
            "redirectStart",
            "redirectEnd",
            "fetchStart",
            "domainLookupStart",
            "domainLookupEnd",
            "connectStart",
            "connectEnd",
            "secureConnectionStart",
            "requestStart",
            "responseStart",
            "domLoading",
            "domInteractive",
            "domContentLoadedEventStart",
            "domContentLoadedEventEnd",
            "domComplete",
            "loadEventStart",
            "loadEventEnd",
            "msFirstPaint",
            "responseEnd",
            ""
        ];
        // Check that navigationStart is a number >= 0
        var navigationStart = w3cTimings.navigationStart;
        if (navigationStart >= 0) {
            var i, t, mask, prev;
            for (mask = prev = i = 0; key = w3cFields.shift(); i++) {
                t = w3cTimings[key];
                if (t > 0) {
                    mask |= 1 << i;
                    t -= navigationStart;
                    w3cFields.push(t === prev ? '' : (t - prev).toString(16));
                    prev = t;
                }
            }
            var navigation = "navigation";
            w3cPayload = ',"w3c":"' + mask.toString(16) + "," + w3cFields.join() + '","nav":' + (navigation in w3cTimings ? w3cTimings[navigation] : performance[navigation].type);
        }
    }
    // NOTE: Any changes to the following part of the string 'DATA={"pp":{' should be communicated to lsdmft because
    //       they could break some features dependent on PP.
    var payLoad = '{"pp":{"S":"' + (state || 'L') + '",' + ppMetrics.join(',') + ',"CT":' + (currentTime - _G.ST) + ',"IL":' + _d.images.length + '}' + (_G.C1 ? ',' + _G.C1 : '') + (w3cPayload !== null ? w3cPayload : '') + '}';
    if (_w['Log2']) {
        Log2.LogEvent("CPT", JSON.parse(payLoad), null, null, null, null, null, null);
    }
    else {
        _G.PPImg = new Image();
        _G.PPImg.src = _G.lsUrl + '&Type=Event.CPT&DATA=' + payLoad + (_G.P ? '&P=' + _G.P : '');
    }
    _G.PPS = 1; // flag set if perfping has fired
    sb_st(function () {
        sj_evt.fire('onPP');
        sj_evt.fire(_w.p1);
    }, 1);
};
// Bind onbefore unload so we can capture the cases of people leaving the page before
// it has loaded (called the abandon state, denoted as 'A').
// Note that onbeforeunload is bound to directly because this should be just about the very first script executing on the page,
// so we don't have to worry about tromping on an existing event handler.
_w.onbeforeunload = function () {
    si_PP(new Date, 'A');
};
;///<reference path="..\..\..\answers\services\Shared\Content\Content\script\Declarations\Shared.d.ts"/>
(function (perfping) {
    if (document.querySelector) {
        var logText = [];
        var customField = "ad";
        function run() {
            var start = sb_gt();
            var de = document.documentElement;
            var body = document.body;
            var adsHeight = -1;
            var adsTop = -1;
            var fold = de.clientHeight;
            var selectors = ["#b_results .b_ad", ".sb_adsWv2", ".ads"];
            // Do not attempt to log anything if body itself is missing
            if (!body)
                return;
            for (var i = 0; i < selectors.length; i++) {
                var selector = selectors[i];
                var ads = document.querySelector(selector);
                if (ads && ads.offsetTop < fold) {
                    adsHeight = ads.offsetHeight;
                    adsTop = ads.offsetTop;
                    break;
                }
            }
            // Data in following order: Ads Top, Ads Height, Viewport Width, Viewport Height, Page Width, Page Height, Cost
            logText = [adsTop, adsHeight, de.clientWidth, fold, body.offsetWidth, body.offsetHeight, sb_gt() - start];
        }
        // Adding payload to perf-ping
        if (perfping) {
            var fn = perfping.onbeforefire;
            perfping.onbeforefire = function () {
                if (fn)
                    fn();
                run();
                perfping.mark(customField, logText);
            };
        }
        else {
            var fn = si_PP;
            si_PP = function () {
                run();
                var customLog = '"' + customField + '":[' + logText.join() + ']';
                _G.C1 = _G.C1 ? _G.C1 + ',' + customLog : customLog;
                fn.apply(null, [].slice.apply(arguments));
            };
        }
    }
})(_w["pp"]);
;///<reference path="..\..\..\..\..\..\Shared\Content\Content\script\Declarations\Shared.d.ts"/>
(function (fn) {
    function extractTimestampParam(qs, key) {
        var param = '&' + key + '=';
        var pos = qs.indexOf(param);
        if (pos < 0) {
            return -1;
        }
        var offset = pos + param.length;
        var ts = qs.substr(offset);
        return parseInt(ts, 10);
    }
    _w.si_PP = function (currentTime, state) {
        var t = _w.performance && _w.performance.timing;
        if (t) {
            var data = '"NS":"' + t.navigationStart + '"';
            var location = window.location;
            var qs = window.location && location.search;
            if (qs) {
                var st = extractTimestampParam(qs, "sbts");
                if (!st || st < 0) {
                    var nclidts = extractTimestampParam(qs, "nclidts");
                    var tsms = extractTimestampParam(qs, "tsms");
                    if (nclidts > 0 && tsms >= 0) {
                        st = (nclidts * 1000) + tsms;
                    }
                }
                if (st > 0) {
                    data += ',"E2E_PLT":"' + (t.loadEventEnd - st) + '"';
                    // 
                    // Attempt to remove the timestamp parameters from the URL for the following reasons:
                    // (1) User refreshes the page 
                    // (2) Navigates forward and then uses the back button
                    // (3) User adds the page as a bookmark
                    // 
                    // In these cases the timestamps from the first impression are used in the E2E PLT calculation as well as the
                    // browser launch time calculation which yields unusable times. There is currently no way to properly sanitize
                    // all instances of these values. It also decreases perf coverage for those affected impressions.
                    if (window.history && history.replaceState) {
                        var historyUrl = location.href.replace(/(&(sbts|nclidts|tsms)=\d+)/g, "");
                        if (historyUrl !== location.href) {
                            history.replaceState(null, null, historyUrl);
                        }
                    }
                }
            }
            _G.C1 = _G.C1 ? _G.C1 + ',' + data : data;
        }
        if (fn) {
            fn(currentTime, state);
        }
    };
})(_w.si_PP);
;// BoxModel Rules
// Format: [x, y, includeChildren]
// E.g. "#b_tween": [100, 140, 1] ==>
//          Look for #b_tween and validate that it's (x,y) matches (100,140)
//          And, since third parameter is 1, also grab coordinates for all children elements
// Value of -1 for x or y coordinate indicates wildcard, i.e., no validation on that particular coordinate
var BM = BM || {};
BM.rules = {
    ".b_scopebar": [-1, -1, 0],
    ".b_scopebar ul": [-1, -1, 1],
    "#b_results": [-1, -1, 1],
    ".b_hList": [-1, -1, 1],
    ".b_flex": [-1, -1, 1],
    ".b_flex span": [-1, -1, 0],
    "img,div[data-src]": [-1, -1, 0],
    "#root": [-1, -1, 1],
    ".suggestion": [-1, -1, 0],
    "#topResult": [-1, -1, 0],
    ".groupHeader": [-1, -1, 0]
};
;var BM = BM || {};
(function (BM) {
    var items = {};
    var unloads = {};
    var computes = {};
    function wireup(moduleID, q) {
        if (!(moduleID in items))
            items[moduleID] = [];
        if (q.compute && !(moduleID in computes))
            computes[moduleID] = q.compute;
        if (q.unload && !(moduleID in unloads))
            unloads[moduleID] = q.unload;
        if (q.load)
            q.load();
    }
    function enqueue(moduleID, item) {
        items[moduleID].push({ t: getElapsedTime(), i: item });
    }
    function dequeue(moduleID) {
        if (moduleID in unloads)
            unloads[moduleID]();
        if (moduleID in items)
            return items[moduleID];
    }
    function trigger() {
        for (var moduleID in computes) {
            computes[moduleID]();
        }
    }
    function getElapsedTime() {
        return window.performance && performance.now ? Math.round(performance.now()) : (new Date()) - window["si_ST"];
    }
    BM.wireup = wireup;
    BM.enqueue = enqueue;
    BM.dequeue = dequeue;
    BM.trigger = trigger;
})(BM);
;///<reference path="..\queue.ts"/>
(function (BM) {
    var moduleID = "V";
    // Viewport computation
    function compute() {
        var de = document.documentElement;
        var body = document.body;
        var screenWidth = "innerWidth" in window ? window.innerWidth : de.clientWidth;
        var screenHeight = "innerHeight" in window ? window.innerHeight : de.clientHeight;
        var screenLeft = window["pageXOffset"] || de.scrollLeft;
        var screenTop = window["pageYOffset"] || de.scrollTop;
        var state = document["visibilityState"] || "default";
        BM.enqueue(moduleID, { x: screenLeft, y: screenTop, w: screenWidth, h: screenHeight, dw: body.clientWidth, dh: body.clientHeight, v: state });
    }
    // Initialize queue
    BM.wireup(moduleID, { load: null, compute: compute, unload: null });
})(BM);
;///<reference path="..\queue.ts"/>
(function (BM) {
    var moduleID = "L";
    // Viewport computation
    function compute() {
        // Bail out if querySelector API doesn't exist
        // Eventually, post page load, we will log the error via core framework
        if (!document.querySelector || !document.querySelectorAll) {
            return;
        }
        var nodes = [];
        var rules = BM.rules;
        for (var selector in rules) {
            var rule = rules[selector];
            selector += !!rule[2] ? " >*" : "";
            var elements = document.querySelectorAll(selector);
            for (var e = 0; e < elements.length; e++) {
                var el = elements[e];
                var x = 0, y = 0, w = el.offsetWidth, h = el.offsetHeight;
                do {
                    x += el.offsetLeft;
                    y += el.offsetTop;
                } while (el = el.offsetParent);
                nodes.push({ _e: elements[e], x: x, y: y, w: w, h: h });
            }
        }
        BM.enqueue(moduleID, nodes);
    }
    // Initialize queue
    BM.wireup(moduleID, { load: null, compute: compute, unload: null });
})(BM);
;///<reference path="..\queue.ts"/>
(function (BM) {
    var moduleID = "EVT";
    // Storing events for later reference
    var events = ["click", "mousedown", "mouseup", "touchstart", "touchend", "mousemove", "touchmove", "scroll", "keydown", "resize"];
    function load() {
        eventManager(sj_be, enqueue);
    }
    function enqueue(evt) {
        // Do not attempt to queue if evt is not natively supported by the browser
        // In older versions of IE, it's possible to lookup _w.event synchronously 
        // but it doesn't work when you try to queue the reference and use it later
        // As per stackoverflow: http://stackoverflow.com/questions/3531751/member-not-found-ie-error-ie-6-7-8-9
        // As a possible future work item, it's possible to get around this by making a copy in another variable for IE8 & IE9
        if (evt) {
            BM.enqueue(moduleID, evt);
        }
        return true;
    }
    function unload() {
        eventManager(sj_ue, enqueue);
    }
    function eventManager(api, handler) {
        for (var i = 0; i < events.length; i++) {
            var evt = events[i];
            api(evt === "resize" ? window : document, window.navigator.pointerEnabled ? evt.replace("mouse", "pointer") : evt, handler, false);
        }
    }
    // Initialize queue with a callback to teardown event bindings later
    BM.wireup(moduleID, { load: load, compute: null, unload: unload });
})(BM);
;_TC={SP:"search,images,images\/search,videos\/search,local,local\/fetchlocalpivot,local\/fetchlocalelv,news,news\/search,devicecontent,people411,meetingprep,tasklineth\/search,stores,profile\/interests\/v2,account\/permissions,cabs\/search,cabs\/searchasync,cabs\/book,cabs\/driver,cabs\/driverupdate,events\/search,showtimesth,showmoremoviesth,themebasedlocalrecommendation\/search,transitline,transitstop,morescholarinfo\/search,financemywatchlist\/search,trainschedule,billpay,nearbyshowmore\/search,skywalk\/seemore,UserDataDictionary\/search,cortanalocal\/placesearch,\/interesttracking,\/interesttracking\/packagetracking,\/entityexplore,todolists,CortanaBootstrap\/MeetingLocation,AbnormalCommute\/ConfirmUpdateAgent,CortanaMallAssist\/search", BP:"videos\/search?view=detail", NW:false};;
//]]></script><style type="text/css">[tabindex]:focus { outline: none; }</style></head><body onload="if(_w.lb)lb();" class="peek"><header id="b_header" class="b_hide peek"><nav class="b_scopebar" role="navigation" data-bm="0"><ul><li class="b_active" data-bm="1"><a _ctf="rdr_T" href="/search?q=Set+a+reminder.&amp;FORM=HDRSC1" h="ID=SERP,5019.1">Web</a></li><li data-bm="2"><a _ctf="rdr_T" href="/images/search?q=Set+a+reminder.&amp;FORM=HDRSC2" h="ID=SERP,5020.1">Images</a></li><li data-bm="3"><a _ctf="rdr_T" href="/videos/search?q=Set+a+reminder.&amp;FORM=HDRSC3" h="ID=SERP,5021.1">Videos</a></li><li data-bm="4"><a _ctf="rdr_T" href="/news/search?q=Set+a+reminder.&amp;FORM=HDRSC4" h="ID=SERP,5022.1">News</a></li></ul></nav></header><script type="text/javascript">//<![CDATA[
/***********************************************************
 * winjs-promise.js start
 **********************************************************/
var globalHolder = { WinJS: { Namespace: {}}};

/***********************************************************
 * base.js
 **********************************************************/
(function baseInit(global, undefined) {
    "use strict";

    function initializeProperties(target, members, prefix) {
        var keys = Object.keys(members);
        var properties;
        var i, len;
        for (i = 0, len = keys.length; i < len; i++) {
            var key = keys[i];
            var enumerable = key.charCodeAt(0) !== /*_*/95;
            var member = members[key];
            if (member && typeof member === 'object') {
                if (member.value !== undefined || typeof member.get === 'function' || typeof member.set === 'function') {
                    if (member.enumerable === undefined) {
                        member.enumerable = enumerable;
                    }
                    if (prefix && member.setName && typeof member.setName === 'function') {
                        member.setName(prefix + "." + key)
                    }
                    properties = properties || {};
                    properties[key] = member;
                    continue;
                }
            }
            if (!enumerable) {
                properties = properties || {};
                properties[key] = { value: member, enumerable: enumerable, configurable: true, writable: true }
                continue;
            }
            target[key] = member;
        }
        if (properties) {
            Object.defineProperties(target, properties);
        }
    }

    (function (rootNamespace) {

        // Create the rootNamespace in the global namespace
        if (!global[rootNamespace]) {
            global[rootNamespace] = Object.create(Object.prototype);
        }

        // Cache the rootNamespace we just created in a local variable
        var _rootNamespace = global[rootNamespace];
        if (!_rootNamespace.Namespace) {
            _rootNamespace.Namespace = Object.create(Object.prototype);
        }

        function defineWithParent(parentNamespace, name, members) {
            /// <signature helpKeyword="WinJS.Namespace.defineWithParent">
            /// <summary locid="WinJS.Namespace.defineWithParent">
            /// Defines a new namespace with the specified name under the specified parent namespace.
            /// </summary>
            /// <param name="parentNamespace" type="Object" locid="WinJS.Namespace.defineWithParent_p:parentNamespace">
            /// The parent namespace.
            /// </param>
            /// <param name="name" type="String" locid="WinJS.Namespace.defineWithParent_p:name">
            /// The name of the new namespace.
            /// </param>
            /// <param name="members" type="Object" locid="WinJS.Namespace.defineWithParent_p:members">
            /// The members of the new namespace.
            /// </param>
            /// <returns type="Object" locid="WinJS.Namespace.defineWithParent_returnValue">
            /// The newly-defined namespace.
            /// </returns>
            /// </signature>
            var currentNamespace = parentNamespace || {};

            if (name) {
                var namespaceFragments = name.split(".");
                for (var i = 0, len = namespaceFragments.length; i < len; i++) {
                    var namespaceName = namespaceFragments[i];
                    if (!currentNamespace[namespaceName]) {
                        Object.defineProperty(currentNamespace, namespaceName,
                            { value: {}, writable: false, enumerable: true, configurable: true }
                        );
                    }
                    currentNamespace = currentNamespace[namespaceName];
                }
            }

            if (members) {
                initializeProperties(currentNamespace, members, name || "<ANONYMOUS>");
            }

            return currentNamespace;
        }

        function define(name, members) {
            /// <signature helpKeyword="WinJS.Namespace.define">
            /// <summary locid="WinJS.Namespace.define">
            /// Defines a new namespace with the specified name.
            /// </summary>
            /// <param name="name" type="String" locid="WinJS.Namespace.define_p:name">
            /// The name of the namespace. This could be a dot-separated name for nested namespaces.
            /// </param>
            /// <param name="members" type="Object" locid="WinJS.Namespace.define_p:members">
            /// The members of the new namespace.
            /// </param>
            /// <returns type="Object" locid="WinJS.Namespace.define_returnValue">
            /// The newly-defined namespace.
            /// </returns>
            /// </signature>
            return defineWithParent(global, name, members);
        }

        var LazyStates = {
            uninitialized: 1,
            working: 2,
            initialized: 3,
        };

        function lazy(f) {
            if (typeof f === "string") {
                var target = f;
                f = function () {
                    return WinJS.Utilities.getMember(target);
                };
            }
            var name;
            var state = LazyStates.uninitialized;
            var result;
            return {
                setName: function (value) {
                    name = value;
                },
                get: function () {
                    switch (state) {
                        case LazyStates.initialized:
                            return result;

                        case LazyStates.uninitialized:
                            state = LazyStates.working;
                            try {
                                msWriteProfilerMark("WinJS.Namespace._lazy:" + name + ",StartTM");
                                result = f();
                            } finally {
                                msWriteProfilerMark("WinJS.Namespace._lazy:" + name + ",StopTM");
                                state = LazyStates.uninitialized;
                            }
                            f = null;
                            state = LazyStates.initialized;
                            return result;

                        case LazyStates.working:
                            throw "Illegal: reentrancy on initialization";

                        default:
                            throw "Illegal";
                    }
                },
                set: function (value) {
                    switch (state) {
                        case LazyStates.working:
                            throw "Illegal: reentrancy on initialization";
                        
                        default:
                            state = LazyStates.initialized;
                            result = value;
                            break;
                    }
                },
                enumerable: true,
                configurable: true,
            }
        }

        // Establish members of the "WinJS.Namespace" namespace
        Object.defineProperties(_rootNamespace.Namespace, {

            defineWithParent: { value: defineWithParent, writable: true, enumerable: true, configurable: true },

            define: { value: define, writable: true, enumerable: true, configurable: true },

            _lazy: { value: lazy, writable: true, enumerable: true, configurable: true },

        });

    })("WinJS");

    (function (WinJS) {

        function define(constructor, instanceMembers, staticMembers) {
            /// <signature helpKeyword="WinJS.Class.define">
            /// <summary locid="WinJS.Class.define">
            /// Defines a class using the given constructor and the specified instance members.
            /// </summary>
            /// <param name="constructor" type="Function" locid="WinJS.Class.define_p:constructor">
            /// A constructor function that is used to instantiate this class.
            /// </param>
            /// <param name="instanceMembers" type="Object" locid="WinJS.Class.define_p:instanceMembers">
            /// The set of instance fields, properties, and methods made available on the class.
            /// </param>
            /// <param name="staticMembers" type="Object" locid="WinJS.Class.define_p:staticMembers">
            /// The set of static fields, properties, and methods made available on the class.
            /// </param>
            /// <returns type="Function" locid="WinJS.Class.define_returnValue">
            /// The newly-defined class.
            /// </returns>
            /// </signature>
            constructor = constructor || function () { };
            WinJS.Utilities.markSupportedForProcessing(constructor);
            if (instanceMembers) {
                initializeProperties(constructor.prototype, instanceMembers);
            }
            if (staticMembers) {
                initializeProperties(constructor, staticMembers);
            }
            return constructor;
        }

        function derive(baseClass, constructor, instanceMembers, staticMembers) {
            /// <signature helpKeyword="WinJS.Class.derive">
            /// <summary locid="WinJS.Class.derive">
            /// Creates a sub-class based on the supplied baseClass parameter, using prototypal inheritance.
            /// </summary>
            /// <param name="baseClass" type="Function" locid="WinJS.Class.derive_p:baseClass">
            /// The class to inherit from.
            /// </param>
            /// <param name="constructor" type="Function" locid="WinJS.Class.derive_p:constructor">
            /// A constructor function that is used to instantiate this class.
            /// </param>
            /// <param name="instanceMembers" type="Object" locid="WinJS.Class.derive_p:instanceMembers">
            /// The set of instance fields, properties, and methods to be made available on the class.
            /// </param>
            /// <param name="staticMembers" type="Object" locid="WinJS.Class.derive_p:staticMembers">
            /// The set of static fields, properties, and methods to be made available on the class.
            /// </param>
            /// <returns type="Function" locid="WinJS.Class.derive_returnValue">
            /// The newly-defined class.
            /// </returns>
            /// </signature>
            if (baseClass) {
                constructor = constructor || function () { };
                var basePrototype = baseClass.prototype;
                constructor.prototype = Object.create(basePrototype);
                WinJS.Utilities.markSupportedForProcessing(constructor);
                Object.defineProperty(constructor.prototype, "constructor", { value: constructor, writable: true, configurable: true, enumerable: true });
                if (instanceMembers) {
                    initializeProperties(constructor.prototype, instanceMembers);
                }
                if (staticMembers) {
                    initializeProperties(constructor, staticMembers);
                }
                return constructor;
            } else {
                return define(constructor, instanceMembers, staticMembers);
            }
        }

        function mix(constructor) {
            /// <signature helpKeyword="WinJS.Class.mix">
            /// <summary locid="WinJS.Class.mix">
            /// Defines a class using the given constructor and the union of the set of instance members
            /// specified by all the mixin objects. The mixin parameter list is of variable length.
            /// </summary>
            /// <param name="constructor" locid="WinJS.Class.mix_p:constructor">
            /// A constructor function that is used to instantiate this class.
            /// </param>
            /// <returns type="Function" locid="WinJS.Class.mix_returnValue">
            /// The newly-defined class.
            /// </returns>
            /// </signature>
            constructor = constructor || function () { };
            var i, len;
            for (i = 1, len = arguments.length; i < len; i++) {
                initializeProperties(constructor.prototype, arguments[i]);
            }
            return constructor;
        }

        // Establish members of "WinJS.Class" namespace
        WinJS.Namespace.define("WinJS.Class", {
            define: define,
            derive: derive,
            mix: mix
        });

    })(WinJS);

})(this);

 /***********************************************************
 * baseUtils.js
 **********************************************************/
 (function baseUtilsInit(global, WinJS) {
    "use strict";

    var hasWinRT = !!global.Windows;

    var strings = {
        get notSupportedForProcessing() { return WinJS.Resources._getWinJSString("base/notSupportedForProcessing").value; }
    };

    function nop(v) {
        return v;
    }

    function getMemberFiltered(name, root, filter) {
        return name.split(".").reduce(function (currentNamespace, name) {
            if (currentNamespace) {
                return filter(currentNamespace[name]);
            }
            return null;
        }, root);
    }

    // Establish members of "WinJS.Utilities" namespace
    WinJS.Namespace.define("WinJS.Utilities", {
        // Used for mocking in tests
        _setHasWinRT: {
            value: function (value) {
                hasWinRT = value;
            },
            configurable: false,
            writable: false,
            enumerable: false
        },

        /// <field type="Boolean" locid="WinJS.Utilities.hasWinRT" helpKeyword="WinJS.Utilities.hasWinRT">Determine if WinRT is accessible in this script context.</field>
        hasWinRT: {
            get: function () { return hasWinRT; },
            configurable: false,
            enumerable: true
        },

        _getMemberFiltered: getMemberFiltered,

        getMember: function (name, root) {
            /// <signature helpKeyword="WinJS.Utilities.getMember">
            /// <summary locid="WinJS.Utilities.getMember">
            /// Gets the leaf-level type or namespace specified by the name parameter.
            /// </summary>
            /// <param name="name" locid="WinJS.Utilities.getMember_p:name">
            /// The name of the member.
            /// </param>
            /// <param name="root" locid="WinJS.Utilities.getMember_p:root">
            /// The root to start in. Defaults to the global object.
            /// </param>
            /// <returns type="Object" locid="WinJS.Utilities.getMember_returnValue">
            /// The leaf-level type or namespace in the specified parent namespace.
            /// </returns>
            /// </signature>
            if (!name) {
                return null;
            }
            return getMemberFiltered(name, root || global, nop);
        },

        ready: function (callback, async) {
            /// <signature helpKeyword="WinJS.Utilities.ready">
            /// <summary locid="WinJS.Utilities.ready">
            /// Ensures that the specified function executes only after the DOMContentLoaded event has fired
            /// for the current page.
            /// </summary>
            /// <returns type="WinJS.Promise" locid="WinJS.Utilities.ready_returnValue">A promise that completes after DOMContentLoaded has occurred.</returns>
            /// <param name="callback" optional="true" locid="WinJS.Utilities.ready_p:callback">
            /// A function that executes after DOMContentLoaded has occurred.
            /// </param>
            /// <param name="async" optional="true" locid="WinJS.Utilities.ready_p:async">
            /// If true, the callback is executed asynchronously.
            /// </param>
            /// </signature>
            return new WinJS.Promise(function (c, e) {
                function complete() {
                    if (callback) {
                        try {
                            callback();
                            c();
                        }
                        catch (err) {
                            e(err);
                        }
                    }
                    else {
                        c();
                    }
                }

                var readyState = WinJS.Utilities.testReadyState;
                if (!readyState) {
                    if (global.document) {
                        readyState = document.readyState;
                    }
                    else {
                        readyState = "complete";
                    }
                }
                if (readyState === "complete" || (global.document && document.body !== null)) {
                    if (async) {
                        WinJS.Utilities.Scheduler.schedule(function () {
                            complete();
                        }, WinJS.Utilities.Scheduler.Priority.normal, null, "WinJS.Utilities.ready");
                    }
                    else {
                        complete();
                    }
                }
                else {
                    global.addEventListener("DOMContentLoaded", complete, false);
                }
            });
        },

        /// <field type="Boolean" locid="WinJS.Utilities.strictProcessing" helpKeyword="WinJS.Utilities.strictProcessing">Determines if strict declarative processing is enabled in this script context.</field>
        strictProcessing: {
            get: function () { return true; },
            configurable: false,
            enumerable: true,
        },

        markSupportedForProcessing: {
            value: function (func) {
                /// <signature helpKeyword="WinJS.Utilities.markSupportedForProcessing">
                /// <summary locid="WinJS.Utilities.markSupportedForProcessing">
                /// Marks a function as being compatible with declarative processing, such as WinJS.UI.processAll
                /// or WinJS.Binding.processAll.
                /// </summary>
                /// <param name="func" type="Function" locid="WinJS.Utilities.markSupportedForProcessing_p:func">
                /// The function to be marked as compatible with declarative processing.
                /// </param>
                /// <returns type="Function" locid="WinJS.Utilities.markSupportedForProcessing_returnValue">
                /// The input function.
                /// </returns>
                /// </signature>
                func.supportedForProcessing = true;
                return func;
            },
            configurable: false,
            writable: false,
            enumerable: true
        },

        requireSupportedForProcessing: {
            value: function (value) {
                /// <signature helpKeyword="WinJS.Utilities.requireSupportedForProcessing">
                /// <summary locid="WinJS.Utilities.requireSupportedForProcessing">
                /// Asserts that the value is compatible with declarative processing, such as WinJS.UI.processAll
                /// or WinJS.Binding.processAll. If it is not compatible an exception will be thrown.
                /// </summary>
                /// <param name="value" type="Object" locid="WinJS.Utilities.requireSupportedForProcessing_p:value">
                /// The value to be tested for compatibility with declarative processing. If the
                /// value is a function it must be marked with a property 'supportedForProcessing'
                /// with a value of true.
                /// </param>
                /// <returns type="Object" locid="WinJS.Utilities.requireSupportedForProcessing_returnValue">
                /// The input value.
                /// </returns>
                /// </signature>
                var supportedForProcessing = true;

                supportedForProcessing = supportedForProcessing && !(value === global);
                supportedForProcessing = supportedForProcessing && !(value === global.location);
                supportedForProcessing = supportedForProcessing && !(value instanceof HTMLIFrameElement);
                supportedForProcessing = supportedForProcessing && !(typeof value === "function" && !value.supportedForProcessing);

                switch (global.frames.length) {
                    case 0:
                        break;

                    case 1:
                        supportedForProcessing = supportedForProcessing && !(value === global.frames[0]);
                        break;

                    default:
                        for (var i = 0, len = global.frames.length; supportedForProcessing && i < len; i++) {
                            supportedForProcessing = supportedForProcessing && !(value === global.frames[i]);
                        }
                        break;
                }

                if (supportedForProcessing) {
                    return value;
                }

                throw new WinJS.ErrorFromName("WinJS.Utilities.requireSupportedForProcessing", WinJS.Resources._formatString(strings.notSupportedForProcessing, value));
            },
            configurable: false,
            writable: false,
            enumerable: true
        },

        _shallowCopy: function _shallowCopy(a) {
            // Shallow copy a single object.
            return this._mergeAll([a]);
        },

        _merge: function _merge(a, b) {
            // Merge 2 objects together into a new object
            return this._mergeAll([a, b]);
        },

        _mergeAll: function _mergeAll(list) {
            // Merge a list of objects together
            var o = {};
            list.forEach(function (part) {
                Object.keys(part).forEach(function (k) {
                    o[k] = part[k];
                });
            });
            return o;
        },
        
        _getProfilerMarkIdentifier: function (element) {
            var profilerMarkIdentifier = "";
            if (element.id) {
                profilerMarkIdentifier += " id='" + element.id + "'";
            }
            if (element.className) {
                profilerMarkIdentifier += " class='" + element.className + "'";
            }
            return profilerMarkIdentifier;
        }
    });

    WinJS.Namespace.define("WinJS", {
        validation: false,

        strictProcessing: {
            value: function () {
                /// <signature helpKeyword="WinJS.strictProcessing">
                /// <summary locid="WinJS.strictProcessing">
                /// Strict processing is always enforced, this method has no effect.
                /// </summary>
                /// </signature>
            },
            configurable: false,
            writable: false,
            enumerable: false
        },
    });
})(this, WinJS);

 /***********************************************************
 * errors.js
 **********************************************************/
(function errorsInit(global, WinJS) {
    "use strict";


    WinJS.Namespace.define("WinJS", {
        // ErrorFromName establishes a simple pattern for returning error codes.
        //
        ErrorFromName: WinJS.Class.derive(Error, function (name, message) {
            /// <signature helpKeyword="WinJS.ErrorFromName">
            /// <summary locid="WinJS.ErrorFromName">
            /// Creates an Error object with the specified name and message properties.
            /// </summary>
            /// <param name="name" type="String" locid="WinJS.ErrorFromName_p:name">The name of this error. The name is meant to be consumed programmatically and should not be localized.</param>
            /// <param name="message" type="String" optional="true" locid="WinJS.ErrorFromName_p:message">The message for this error. The message is meant to be consumed by humans and should be localized.</param>
            /// <returns type="Error" locid="WinJS.ErrorFromName_returnValue">Error instance with .name and .message properties populated</returns>
            /// </signature>
            this.name = name;
            this.message = message || name;
        }, {
            /* empty */
        }, {
            supportedForProcessing: false,
        })
    });

})(this, WinJS);



 /***********************************************************
 * events.js
 **********************************************************/
 (function eventsInit(WinJS, undefined) {
    "use strict";


    function createEventProperty(name) {
        var eventPropStateName = "_on" + name + "state";

        return {
            get: function () {
                var state = this[eventPropStateName];
                return state && state.userHandler;
            },
            set: function (handler) {
                var state = this[eventPropStateName];
                if (handler) {
                    if (!state) {
                        state = { wrapper: function (evt) { return state.userHandler(evt); }, userHandler: handler };
                        Object.defineProperty(this, eventPropStateName, { value: state, enumerable: false, writable:true, configurable: true });
                        this.addEventListener(name, state.wrapper, false);
                    }
                    state.userHandler = handler;
                } else if (state) {
                    this.removeEventListener(name, state.wrapper, false);
                    this[eventPropStateName] = null;
                }
            },
            enumerable: true
        }
    }

    function createEventProperties(events) {
        /// <signature helpKeyword="WinJS.Utilities.createEventProperties">
        /// <summary locid="WinJS.Utilities.createEventProperties">
        /// Creates an object that has one property for each name passed to the function.
        /// </summary>
        /// <param name="events" locid="WinJS.Utilities.createEventProperties_p:events">
        /// A variable list of property names.
        /// </param>
        /// <returns type="Object" locid="WinJS.Utilities.createEventProperties_returnValue">
        /// The object with the specified properties. The names of the properties are prefixed with 'on'.
        /// </returns>
        /// </signature>
        var props = {};
        for (var i = 0, len = arguments.length; i < len; i++) {
            var name = arguments[i];
            props["on" + name] = createEventProperty(name);
        }
        return props;
    }

    var EventMixinEvent = WinJS.Class.define(
        function EventMixinEvent_ctor(type, detail, target) {
            this.detail = detail;
            this.target = target;
            this.timeStamp = Date.now();
            this.type = type;
        },
        {
            bubbles: { value: false, writable: false },
            cancelable: { value: false, writable: false },
            currentTarget: {
                get: function () { return this.target; }
            },
            defaultPrevented: {
                get: function () { return this._preventDefaultCalled; }
            },
            trusted: { value: false, writable: false },
            eventPhase: { value: 0, writable: false },
            target: null,
            timeStamp: null,
            type: null,

            preventDefault: function () {
                this._preventDefaultCalled = true;
            },
            stopImmediatePropagation: function () {
                this._stopImmediatePropagationCalled = true;
            },
            stopPropagation: function () {
            }
        }, {
            supportedForProcessing: false,
        }
    );

    var eventMixin = {
        _listeners: null,

        addEventListener: function (type, listener, useCapture) {
            /// <signature helpKeyword="WinJS.Utilities.eventMixin.addEventListener">
            /// <summary locid="WinJS.Utilities.eventMixin.addEventListener">
            /// Adds an event listener to the control.
            /// </summary>
            /// <param name="type" locid="WinJS.Utilities.eventMixin.addEventListener_p:type">
            /// The type (name) of the event.
            /// </param>
            /// <param name="listener" locid="WinJS.Utilities.eventMixin.addEventListener_p:listener">
            /// The listener to invoke when the event is raised.
            /// </param>
            /// <param name="useCapture" locid="WinJS.Utilities.eventMixin.addEventListener_p:useCapture">
            /// if true initiates capture, otherwise false.
            /// </param>
            /// </signature>
            useCapture = useCapture || false;
            this._listeners = this._listeners || {};
            var eventListeners = (this._listeners[type] = this._listeners[type] || []);
            for (var i = 0, len = eventListeners.length; i < len; i++) {
                var l = eventListeners[i];
                if (l.useCapture === useCapture && l.listener === listener) {
                    return;
                }
            }
            eventListeners.push({ listener: listener, useCapture: useCapture });
        },
        dispatchEvent: function (type, details) {
            /// <signature helpKeyword="WinJS.Utilities.eventMixin.dispatchEvent">
            /// <summary locid="WinJS.Utilities.eventMixin.dispatchEvent">
            /// Raises an event of the specified type and with the specified additional properties.
            /// </summary>
            /// <param name="type" locid="WinJS.Utilities.eventMixin.dispatchEvent_p:type">
            /// The type (name) of the event.
            /// </param>
            /// <param name="details" locid="WinJS.Utilities.eventMixin.dispatchEvent_p:details">
            /// The set of additional properties to be attached to the event object when the event is raised.
            /// </param>
            /// <returns type="Boolean" locid="WinJS.Utilities.eventMixin.dispatchEvent_returnValue">
            /// true if preventDefault was called on the event.
            /// </returns>
            /// </signature>
            var listeners = this._listeners && this._listeners[type];
            if (listeners) {
                var eventValue = new EventMixinEvent(type, details, this);
                // Need to copy the array to protect against people unregistering while we are dispatching
                listeners = listeners.slice(0, listeners.length);
                for (var i = 0, len = listeners.length; i < len && !eventValue._stopImmediatePropagationCalled; i++) {
                    listeners[i].listener(eventValue);
                }
                return eventValue.defaultPrevented || false;
            }
            return false;
        },
        removeEventListener: function (type, listener, useCapture) {
            /// <signature helpKeyword="WinJS.Utilities.eventMixin.removeEventListener">
            /// <summary locid="WinJS.Utilities.eventMixin.removeEventListener">
            /// Removes an event listener from the control.
            /// </summary>
            /// <param name="type" locid="WinJS.Utilities.eventMixin.removeEventListener_p:type">
            /// The type (name) of the event.
            /// </param>
            /// <param name="listener" locid="WinJS.Utilities.eventMixin.removeEventListener_p:listener">
            /// The listener to remove.
            /// </param>
            /// <param name="useCapture" locid="WinJS.Utilities.eventMixin.removeEventListener_p:useCapture">
            /// Specifies whether to initiate capture.
            /// </param>
            /// </signature>
            useCapture = useCapture || false;
            var listeners = this._listeners && this._listeners[type];
            if (listeners) {
                for (var i = 0, len = listeners.length; i < len; i++) {
                    var l = listeners[i];
                    if (l.listener === listener && l.useCapture === useCapture) {
                        listeners.splice(i, 1);
                        if (listeners.length === 0) {
                            delete this._listeners[type];
                        }
                        // Only want to remove one element for each call to removeEventListener
                        break;
                    }
                }
            }
        }
    };

    WinJS.Namespace.define("WinJS.Utilities", {
        _createEventProperty: createEventProperty,
        createEventProperties: createEventProperties,
        eventMixin: eventMixin
    });

})(WinJS);
 
  /***********************************************************
 * promise.js
 **********************************************************/
 (function promiseInit(global, undefined) {
    "use strict";

    var ListenerType = WinJS.Class.mix(WinJS.Class.define(null, { /*empty*/ }, { supportedForProcessing: false }), WinJS.Utilities.eventMixin);
    var promiseEventListeners = new ListenerType();
    // make sure there is a listeners collection so that we can do a more trivial check below
    promiseEventListeners._listeners = {};
    var errorET = "error";
    var canceledName = "Canceled";
    var tagWithStack = false;
    var tag = {
        promise: 0x01,
        thenPromise: 0x02,
        errorPromise: 0x04,
        exceptionPromise: 0x08,
        completePromise: 0x10,
    };
    tag.all = tag.promise | tag.thenPromise | tag.errorPromise | tag.exceptionPromise | tag.completePromise;

    //
    // Global error counter, for each error which enters the system we increment this once and then
    // the error number travels with the error as it traverses the tree of potential handlers.
    //
    // When someone has registered to be told about errors (WinJS.Promise.callonerror) promises
    // which are in error will get tagged with a ._errorId field. This tagged field is the
    // contract by which nested promises with errors will be identified as chaining for the
    // purposes of the callonerror semantics. If a nested promise in error is encountered without
    // a ._errorId it will be assumed to be foreign and treated as an interop boundary and
    // a new error id will be minted.
    //
    var error_number = 1;

    //
    // The state machine has a interesting hiccup in it with regards to notification, in order
    // to flatten out notification and avoid recursion for synchronous completion we have an
    // explicit set of *_notify states which are responsible for notifying their entire tree
    // of children. They can do this because they know that immediate children are always
    // ThenPromise instances and we can therefore reach into their state to access the
    // _listeners collection.
    //
    // So, what happens is that a Promise will be fulfilled through the _completed or _error
    // messages at which point it will enter a *_notify state and be responsible for to move
    // its children into an (as appropriate) success or error state and also notify that child's
    // listeners of the state transition, until leaf notes are reached.
    //

    var state_created,              // -> working
        state_working,              // -> error | error_notify | success | success_notify | canceled | waiting
        state_waiting,              // -> error | error_notify | success | success_notify | waiting_canceled
        state_waiting_canceled,     // -> error | error_notify | success | success_notify | canceling
        state_canceled,             // -> error | error_notify | success | success_notify | canceling
        state_canceling,            // -> error_notify
        state_success_notify,       // -> success
        state_success,              // -> .
        state_error_notify,         // -> error
        state_error;                // -> .

    // Noop function, used in the various states to indicate that they don't support a given
    // message. Named with the somewhat cute name '_' because it reads really well in the states.

    function _() { }

    // Initial state
    //
    state_created = {
        name: "created",
        enter: function (promise) {
            promise._setState(state_working);
        },
        cancel: _,
        done: _,
        then: _,
        _completed: _,
        _error: _,
        _notify: _,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Ready state, waiting for a message (completed/error/progress), able to be canceled
    //
    state_working = {
        name: "working",
        enter: _,
        cancel: function (promise) {
            promise._setState(state_canceled);
        },
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Waiting state, if a promise is completed with a value which is itself a promise
    // (has a then() method) it signs up to be informed when that child promise is
    // fulfilled at which point it will be fulfilled with that value.
    //
    state_waiting = {
        name: "waiting",
        enter: function (promise) {
            var waitedUpon = promise._value;
            // We can special case our own intermediate promises which are not in a 
            //  terminal state by just pushing this promise as a listener without 
            //  having to create new indirection functions
            if (waitedUpon instanceof ThenPromise &&
                waitedUpon._state !== state_error &&
                waitedUpon._state !== state_success) {
                pushListener(waitedUpon, { promise: promise });
            } else {
                var error = function (value) {
                    if (waitedUpon._errorId) {
                        promise._chainedError(value, waitedUpon);
                    } else {
                        // Because this is an interop boundary we want to indicate that this 
                        //  error has been handled by the promise infrastructure before we
                        //  begin a new handling chain.
                        //
                        callonerror(promise, value, detailsForHandledError, waitedUpon, error);
                        promise._error(value);
                    }
                };
                error.handlesOnError = true;
                waitedUpon.then(
                    promise._completed.bind(promise),
                    error,
                    promise._progress.bind(promise)
                );
            }
        },
        cancel: function (promise) {
            promise._setState(state_waiting_canceled);
        },
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Waiting canceled state, when a promise has been in a waiting state and receives a
    // request to cancel its pending work it will forward that request to the child promise
    // and then waits to be informed of the result. This promise moves itself into the
    // canceling state but understands that the child promise may instead push it to a
    // different state.
    //
    state_waiting_canceled = {
        name: "waiting_canceled",
        enter: function (promise) {
            // Initiate a transition to canceling. Triggering a cancel on the promise
            // that we are waiting upon may result in a different state transition
            // before the state machine pump runs again.
            promise._setState(state_canceling);
            var waitedUpon = promise._value;
            if (waitedUpon.cancel) {
                waitedUpon.cancel();
            }
        },
        cancel: _,
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Canceled state, moves to the canceling state and then tells the promise to do
    // whatever it might need to do on cancelation.
    //
    state_canceled = {
        name: "canceled",
        enter: function (promise) {
            // Initiate a transition to canceling. The _cancelAction may change the state
            // before the state machine pump runs again.
            promise._setState(state_canceling);
            promise._cancelAction();
        },
        cancel: _,
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Canceling state, commits to the promise moving to an error state with an error
    // object whose 'name' and 'message' properties contain the string "Canceled"
    //
    state_canceling = {
        name: "canceling",
        enter: function (promise) {
            var error = new Error(canceledName);
            error.name = error.message;
            promise._value = error;
            promise._setState(state_error_notify);
        },
        cancel: _,
        done: _,
        then: _,
        _completed: _,
        _error: _,
        _notify: _,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Success notify state, moves a promise to the success state and notifies all children
    //
    state_success_notify = {
        name: "complete_notify",
        enter: function (promise) {
            promise.done = CompletePromise.prototype.done;
            promise.then = CompletePromise.prototype.then;
            if (promise._listeners) {
                var queue = [promise];
                var p;
                while (queue.length) {
                    p = queue.shift();
                    p._state._notify(p, queue);
                }
            }
            promise._setState(state_success);
        },
        cancel: _,
        done: null, /*error to get here */
        then: null, /*error to get here */
        _completed: _,
        _error: _,
        _notify: notifySuccess,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Success state, moves a promise to the success state and does NOT notify any children.
    // Some upstream promise is owning the notification pass.
    //
    state_success = {
        name: "success",
        enter: function (promise) {
            promise.done = CompletePromise.prototype.done;
            promise.then = CompletePromise.prototype.then;
            promise._cleanupAction();
        },
        cancel: _,
        done: null, /*error to get here */
        then: null, /*error to get here */
        _completed: _,
        _error: _,
        _notify: notifySuccess,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Error notify state, moves a promise to the error state and notifies all children
    //
    state_error_notify = {
        name: "error_notify",
        enter: function (promise) {
            promise.done = ErrorPromise.prototype.done;
            promise.then = ErrorPromise.prototype.then;
            if (promise._listeners) {
                var queue = [promise];
                var p;
                while (queue.length) {
                    p = queue.shift();
                    p._state._notify(p, queue);
                }
            }
            promise._setState(state_error);
        },
        cancel: _,
        done: null, /*error to get here*/
        then: null, /*error to get here*/
        _completed: _,
        _error: _,
        _notify: notifyError,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Error state, moves a promise to the error state and does NOT notify any children.
    // Some upstream promise is owning the notification pass.
    //
    state_error = {
        name: "error",
        enter: function (promise) {
            promise.done = ErrorPromise.prototype.done;
            promise.then = ErrorPromise.prototype.then;
            promise._cleanupAction();
        },
        cancel: _,
        done: null, /*error to get here*/
        then: null, /*error to get here*/
        _completed: _,
        _error: _,
        _notify: notifyError,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    //
    // The statemachine implementation follows a very particular pattern, the states are specified
    // as static stateless bags of functions which are then indirected through the state machine
    // instance (a Promise). As such all of the functions on each state have the promise instance
    // passed to them explicitly as a parameter and the Promise instance members do a little
    // dance where they indirect through the state and insert themselves in the argument list.
    //
    // We could instead call directly through the promise states however then every caller
    // would have to remember to do things like pumping the state machine to catch state transitions.
    //

    var PromiseStateMachine = WinJS.Class.define(null, {
        _listeners: null,
        _nextState: null,
        _state: null,
        _value: null,

        cancel: function () {
            /// <signature helpKeyword="WinJS.PromiseStateMachine.cancel">
            /// <summary locid="WinJS.PromiseStateMachine.cancel">
            /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't
            /// already been fulfilled and cancellation is supported, the promise enters
            /// the error state with a value of Error("Canceled").
            /// </summary>
            /// </signature>
            this._state.cancel(this);
            this._run();
        },
        done: function Promise_done(onComplete, onError, onProgress) {
            /// <signature helpKeyword="WinJS.PromiseStateMachine.done">
            /// <summary locid="WinJS.PromiseStateMachine.done">
            /// Allows you to specify the work to be done on the fulfillment of the promised value,
            /// the error handling to be performed if the promise fails to fulfill
            /// a value, and the handling of progress notifications along the way.
            ///
            /// After the handlers have finished executing, this function throws any error that would have been returned
            /// from then() as a promise in the error state.
            /// </summary>
            /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.done_p:onComplete">
            /// The function to be called if the promise is fulfilled successfully with a value.
            /// The fulfilled value is passed as the single argument. If the value is null,
            /// the fulfilled value is returned. The value returned
            /// from the function becomes the fulfilled value of the promise returned by
            /// then(). If an exception is thrown while executing the function, the promise returned
            /// by then() moves into the error state.
            /// </param>
            /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onError">
            /// The function to be called if the promise is fulfilled with an error. The error
            /// is passed as the single argument. If it is null, the error is forwarded.
            /// The value returned from the function is the fulfilled value of the promise returned by then().
            /// </param>
            /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onProgress">
            /// the function to be called if the promise reports progress. Data about the progress
            /// is passed as the single argument. Promises are not required to support
            /// progress.
            /// </param>
            /// </signature>
            this._state.done(this, onComplete, onError, onProgress);
        },
        then: function Promise_then(onComplete, onError, onProgress) {
            /// <signature helpKeyword="WinJS.PromiseStateMachine.then">
            /// <summary locid="WinJS.PromiseStateMachine.then">
            /// Allows you to specify the work to be done on the fulfillment of the promised value,
            /// the error handling to be performed if the promise fails to fulfill
            /// a value, and the handling of progress notifications along the way.
            /// </summary>
            /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.then_p:onComplete">
            /// The function to be called if the promise is fulfilled successfully with a value.
            /// The value is passed as the single argument. If the value is null, the value is returned.
            /// The value returned from the function becomes the fulfilled value of the promise returned by
            /// then(). If an exception is thrown while this function is being executed, the promise returned
            /// by then() moves into the error state.
            /// </param>
            /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onError">
            /// The function to be called if the promise is fulfilled with an error. The error
            /// is passed as the single argument. If it is null, the error is forwarded.
            /// The value returned from the function becomes the fulfilled value of the promise returned by then().
            /// </param>
            /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onProgress">
            /// The function to be called if the promise reports progress. Data about the progress
            /// is passed as the single argument. Promises are not required to support
            /// progress.
            /// </param>
            /// <returns type="WinJS.Promise" locid="WinJS.PromiseStateMachine.then_returnValue">
            /// The promise whose value is the result of executing the complete or
            /// error function.
            /// </returns>
            /// </signature>
            return this._state.then(this, onComplete, onError, onProgress);
        },

        _chainedError: function (value, context) {
            var result = this._state._error(this, value, detailsForChainedError, context);
            this._run();
            return result;
        },
        _completed: function (value) {
            var result = this._state._completed(this, value);
            this._run();
            return result;
        },
        _error: function (value) {
            var result = this._state._error(this, value, detailsForError);
            this._run();
            return result;
        },
        _progress: function (value) {
            this._state._progress(this, value);
        },
        _setState: function (state) {
            this._nextState = state;
        },
        _setCompleteValue: function (value) {
            this._state._setCompleteValue(this, value);
            this._run();
        },
        _setChainedErrorValue: function (value, context) {
            var result = this._state._setErrorValue(this, value, detailsForChainedError, context);
            this._run();
            return result;
        },
        _setExceptionValue: function (value) {
            var result = this._state._setErrorValue(this, value, detailsForException);
            this._run();
            return result;
        },
        _run: function () {
            while (this._nextState) {
                this._state = this._nextState;
                this._nextState = null;
                this._state.enter(this);
            }
        }
    }, {
        supportedForProcessing: false
    });

    //
    // Implementations of shared state machine code.
    //

    function completed(promise, value) {
        var targetState;
        if (value && typeof value === "object" && typeof value.then === "function") {
            targetState = state_waiting;
        } else {
            targetState = state_success_notify;
        }
        promise._value = value;
        promise._setState(targetState);
    }
    function createErrorDetails(exception, error, promise, id, parent, handler) {
        return {
            exception: exception,
            error: error,
            promise: promise,
            handler: handler,
            id: id,
            parent: parent
        };
    }
    function detailsForHandledError(promise, errorValue, context, handler) {
        var exception = context._isException;
        var errorId = context._errorId;
        return createErrorDetails(
            exception ? errorValue : null,
            exception ? null : errorValue,
            promise,
            errorId,
            context,
            handler
        );
    }
    function detailsForChainedError(promise, errorValue, context) {
        var exception = context._isException;
        var errorId = context._errorId;
        setErrorInfo(promise, errorId, exception);
        return createErrorDetails(
            exception ? errorValue : null,
            exception ? null : errorValue,
            promise,
            errorId,
            context
        );
    }
    function detailsForError(promise, errorValue) {
        var errorId = ++error_number;
        setErrorInfo(promise, errorId);
        return createErrorDetails(
            null,
            errorValue,
            promise,
            errorId
        );
    }
    function detailsForException(promise, exceptionValue) {
        var errorId = ++error_number;
        setErrorInfo(promise, errorId, true);
        return createErrorDetails(
            exceptionValue,
            null,
            promise,
            errorId
        );
    }
    function done(promise, onComplete, onError, onProgress) {
        var asyncOpID = "WinJS.Promise.done";
        pushListener(promise, { c: onComplete, e: onError, p: onProgress, asyncOpID: asyncOpID });
    }
    function error(promise, value, onerrorDetails, context) {
        promise._value = value;
        callonerror(promise, value, onerrorDetails, context);
        promise._setState(state_error_notify);
    }
    function notifySuccess(promise, queue) {
        var value = promise._value;
        var listeners = promise._listeners;
        if (!listeners) {
            return;
        }
        promise._listeners = null;
        var i, len;
        for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {
            var listener = len === 1 ? listeners : listeners[i];
            var onComplete = listener.c;
            var target = listener.promise;

            if (target) {
                try {
                    target._setCompleteValue(onComplete ? onComplete(value) : value);
                } catch (ex) {
                    target._setExceptionValue(ex);
                } finally {
                }
                if (target._state !== state_waiting && target._listeners) {
                    queue.push(target);
                }
            } else {
                CompletePromise.prototype.done.call(promise, onComplete);
            }
        }
    }
    function notifyError(promise, queue) {
        var value = promise._value;
        var listeners = promise._listeners;
        if (!listeners) {
            return;
        }
        promise._listeners = null;
        var i, len;
        for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {
            var listener = len === 1 ? listeners : listeners[i];
            var onError = listener.e;
            var target = listener.promise;

            if (target) {
                var asyncCallbackStarted = false;
                try {
                    if (onError) {
                        asyncCallbackStarted = true;
                        if (!onError.handlesOnError) {
                            callonerror(target, value, detailsForHandledError, promise, onError);
                        }
                        target._setCompleteValue(onError(value))
                    } else {
                        target._setChainedErrorValue(value, promise);
                    }
                } catch (ex) {
                    target._setExceptionValue(ex);
                } finally {
                }
                if (target._state !== state_waiting && target._listeners) {
                    queue.push(target);
                }
            } else {
                ErrorPromise.prototype.done.call(promise, null, onError);
            }
        }
    }
    function callonerror(promise, value, onerrorDetailsGenerator, context, handler) {
        if (promiseEventListeners._listeners[errorET]) {
            if (value instanceof Error && value.message === canceledName) {
                return;
            }
            promiseEventListeners.dispatchEvent(errorET, onerrorDetailsGenerator(promise, value, context, handler));
        }
    }
    function progress(promise, value) {
        var listeners = promise._listeners;
        if (listeners) {
            var i, len;
            for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {
                var listener = len === 1 ? listeners : listeners[i];
                var onProgress = listener.p;
                if (onProgress) {
                    try { onProgress(value); } catch (ex) { }
                }
                if (!(listener.c || listener.e) && listener.promise) {
                    listener.promise._progress(value);
                }
            }
        }
    }
    function pushListener(promise, listener) {
        var listeners = promise._listeners;
        if (listeners) {
            // We may have either a single listener (which will never be wrapped in an array)
            // or 2+ listeners (which will be wrapped). Since we are now adding one more listener
            // we may have to wrap the single listener before adding the second.
            listeners = Array.isArray(listeners) ? listeners : [listeners];
            listeners.push(listener);
        } else {
            listeners = listener;
        }
        promise._listeners = listeners;
    }
    // The difference beween setCompleteValue()/setErrorValue() and complete()/error() is that setXXXValue() moves
    // a promise directly to the success/error state without starting another notification pass (because one
    // is already ongoing).
    function setErrorInfo(promise, errorId, isException) {
        promise._isException = isException || false;
        promise._errorId = errorId;
    }
    function setErrorValue(promise, value, onerrorDetails, context) {
        promise._value = value;
        callonerror(promise, value, onerrorDetails, context);
        promise._setState(state_error);
    }
    function setCompleteValue(promise, value) {
        var targetState;
        if (value && typeof value === "object" && typeof value.then === "function") {
            targetState = state_waiting;
        } else {
            targetState = state_success;
        }
        promise._value = value;
        promise._setState(targetState);
    }
    function then(promise, onComplete, onError, onProgress) {
        var result = new ThenPromise(promise);
        var asyncOpID = "WinJS.Promise.then";
        pushListener(promise, { promise: result, c: onComplete, e: onError, p: onProgress, asyncOpID: asyncOpID });
        return result;
    }

    //
    // Internal implementation detail promise, ThenPromise is created when a promise needs
    // to be returned from a then() method.
    //
    var ThenPromise = WinJS.Class.derive(PromiseStateMachine,
        function (creator) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.thenPromise))) {
                this._stack = WinJS.Promise._getStack();
            }

            this._creator = creator;
            this._setState(state_created);
            this._run();
        }, {
            _creator: null,

            _cancelAction: function () { if (this._creator) { this._creator.cancel(); } },
            _cleanupAction: function () { this._creator = null; }
        }, {
            supportedForProcessing: false
        }
    );

    //
    // Slim promise implementations for already completed promises, these are created
    // under the hood on synchronous completion paths as well as by WinJS.Promise.wrap
    // and WinJS.Promise.wrapError.
    //

    var ErrorPromise = WinJS.Class.define(
        function ErrorPromise_ctor(value) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.errorPromise))) {
                this._stack = WinJS.Promise._getStack();
            }

            this._value = value;
            callonerror(this, value, detailsForError);
        }, {
            cancel: function () {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.cancel">
                /// <summary locid="WinJS.PromiseStateMachine.cancel">
                /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't
                /// already been fulfilled and cancellation is supported, the promise enters
                /// the error state with a value of Error("Canceled").
                /// </summary>
                /// </signature>
            },
            done: function ErrorPromise_done(unused, onError) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.done">
                /// <summary locid="WinJS.PromiseStateMachine.done">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                ///
                /// After the handlers have finished executing, this function throws any error that would have been returned
                /// from then() as a promise in the error state.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.done_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The fulfilled value is passed as the single argument. If the value is null,
                /// the fulfilled value is returned. The value returned
                /// from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while executing the function, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function is the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onProgress">
                /// the function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// </signature>
                var value = this._value;
                if (onError) {
                    try {
                        if (!onError.handlesOnError) {
                            callonerror(null, value, detailsForHandledError, this, onError);
                        }
                        var result = onError(value);
                        if (result && typeof result === "object" && typeof result.done === "function") {
                            // If a promise is returned we need to wait on it.
                            result.done();
                        }
                        return;
                    } catch (ex) {
                        value = ex;
                    }
                }
                if (value instanceof Error && value.message === canceledName) {
                    // suppress cancel
                    return;
                }
                // force the exception to be thrown asyncronously to avoid any try/catch blocks
                //
                WinJS.Utilities.Scheduler.schedule(function () {
                    throw value;
                }, WinJS.Utilities.Scheduler.Priority.normal, null, "WinJS.Promise._throwException");
            },
            then: function ErrorPromise_then(unused, onError) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.then">
                /// <summary locid="WinJS.PromiseStateMachine.then">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.then_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The value is passed as the single argument. If the value is null, the value is returned.
                /// The value returned from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while this function is being executed, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function becomes the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onProgress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.PromiseStateMachine.then_returnValue">
                /// The promise whose value is the result of executing the complete or
                /// error function.
                /// </returns>
                /// </signature>

                // If the promise is already in a error state and no error handler is provided
                // we optimize by simply returning the promise instead of creating a new one.
                //
                if (!onError) { return this; }
                var result;
                var value = this._value;
                try {
                    if (!onError.handlesOnError) {
                        callonerror(null, value, detailsForHandledError, this, onError);
                    }
                    result = new CompletePromise(onError(value));
                } catch (ex) {
                    // If the value throw from the error handler is the same as the value
                    // provided to the error handler then there is no need for a new promise.
                    //
                    if (ex === value) {
                        result = this;
                    } else {
                        result = new ExceptionPromise(ex);
                    }
                }
                return result;
            }
        }, {
            supportedForProcessing: false
        }
    );

    var ExceptionPromise = WinJS.Class.derive(ErrorPromise,
        function ExceptionPromise_ctor(value) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.exceptionPromise))) {
                this._stack = WinJS.Promise._getStack();
            }

            this._value = value;
            callonerror(this, value, detailsForException);
        }, {
            /* empty */
        }, {
            supportedForProcessing: false
        }
    );

    var CompletePromise = WinJS.Class.define(
        function CompletePromise_ctor(value) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.completePromise))) {
                this._stack = WinJS.Promise._getStack();
            }

            if (value && typeof value === "object" && typeof value.then === "function") {
                var result = new ThenPromise(null);
                result._setCompleteValue(value);
                return result;
            }
            this._value = value;
        }, {
            cancel: function () {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.cancel">
                /// <summary locid="WinJS.PromiseStateMachine.cancel">
                /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't
                /// already been fulfilled and cancellation is supported, the promise enters
                /// the error state with a value of Error("Canceled").
                /// </summary>
                /// </signature>
            },
            done: function CompletePromise_done(onComplete) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.done">
                /// <summary locid="WinJS.PromiseStateMachine.done">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                ///
                /// After the handlers have finished executing, this function throws any error that would have been returned
                /// from then() as a promise in the error state.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.done_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The fulfilled value is passed as the single argument. If the value is null,
                /// the fulfilled value is returned. The value returned
                /// from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while executing the function, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function is the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onProgress">
                /// the function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// </signature>
                if (!onComplete) { return; }
                try {
                    var result = onComplete(this._value);
                    if (result && typeof result === "object" && typeof result.done === "function") {
                        result.done();
                    }
                } catch (ex) {
                    // force the exception to be thrown asynchronously to avoid any try/catch blocks
                    WinJS.Utilities.Scheduler.schedule(function () {
                        throw ex;
                    }, WinJS.Utilities.Scheduler.Priority.normal, null, "WinJS.Promise._throwException");
                }
            },
            then: function CompletePromise_then(onComplete) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.then">
                /// <summary locid="WinJS.PromiseStateMachine.then">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.then_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The value is passed as the single argument. If the value is null, the value is returned.
                /// The value returned from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while this function is being executed, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function becomes the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onProgress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.PromiseStateMachine.then_returnValue">
                /// The promise whose value is the result of executing the complete or
                /// error function.
                /// </returns>
                /// </signature>
                try {
                    // If the value returned from the completion handler is the same as the value
                    // provided to the completion handler then there is no need for a new promise.
                    //
                    var newValue = onComplete ? onComplete(this._value) : this._value;
                    return newValue === this._value ? this : new CompletePromise(newValue);
                } catch (ex) {
                    return new ExceptionPromise(ex);
                }
            }
        }, {
            supportedForProcessing: false
        }
    );

    //
    // Promise is the user-creatable WinJS.Promise object.
    //

    function timeout(timeoutMS) {
        var id;
        return new WinJS.Promise(
            function (c) {
                if (timeoutMS) {
                    id = setTimeout(c, timeoutMS);
                } else {
                    setImmediate(c);
                }
            },
            function () {
                if (id) {
                    clearTimeout(id);
                }
            }
        );
    }

    function timeoutWithPromise(timeout, promise) {
        var cancelPromise = function () { promise.cancel(); }
        var cancelTimeout = function () { timeout.cancel(); }
        timeout.then(cancelPromise);
        promise.then(cancelTimeout, cancelTimeout);
        return promise;
    }

    var staticCanceledPromise;

    var Promise = WinJS.Class.derive(PromiseStateMachine,
        function Promise_ctor(init, oncancel) {
            /// <signature helpKeyword="WinJS.Promise">
            /// <summary locid="WinJS.Promise">
            /// A promise provides a mechanism to schedule work to be done on a value that
            /// has not yet been computed. It is a convenient abstraction for managing
            /// interactions with asynchronous APIs.
            /// </summary>
            /// <param name="init" type="Function" locid="WinJS.Promise_p:init">
            /// The function that is called during construction of the  promise. The function
            /// is given three arguments (complete, error, progress). Inside this function
            /// you should add event listeners for the notifications supported by this value.
            /// </param>
            /// <param name="oncancel" optional="true" locid="WinJS.Promise_p:oncancel">
            /// The function to call if a consumer of this promise wants
            /// to cancel its undone work. Promises are not required to
            /// support cancellation.
            /// </param>
            /// </signature>

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.promise))) {
                this._stack = WinJS.Promise._getStack();
            }

            this._oncancel = oncancel;
            this._setState(state_created);
            this._run();

            try {
                var complete = this._completed.bind(this);
                var error = this._error.bind(this);
                var progress = this._progress.bind(this);
                init(complete, error, progress);
            } catch (ex) {
                this._setExceptionValue(ex);
            }
        }, {
            _oncancel: null,

            _cancelAction: function () {
                if (this._oncancel) {
                    try { this._oncancel(); } catch (ex) { }
                }
            },
            _cleanupAction: function () { this._oncancel = null; }
        }, {

            addEventListener: function Promise_addEventListener(eventType, listener, capture) {
                /// <signature helpKeyword="WinJS.Promise.addEventListener">
                /// <summary locid="WinJS.Promise.addEventListener">
                /// Adds an event listener to the control.
                /// </summary>
                /// <param name="eventType" locid="WinJS.Promise.addEventListener_p:eventType">
                /// The type (name) of the event.
                /// </param>
                /// <param name="listener" locid="WinJS.Promise.addEventListener_p:listener">
                /// The listener to invoke when the event is raised.
                /// </param>
                /// <param name="capture" locid="WinJS.Promise.addEventListener_p:capture">
                /// Specifies whether or not to initiate capture.
                /// </param>
                /// </signature>
                promiseEventListeners.addEventListener(eventType, listener, capture);
            },
            any: function Promise_any(values) {
                /// <signature helpKeyword="WinJS.Promise.any">
                /// <summary locid="WinJS.Promise.any">
                /// Returns a promise that is fulfilled when one of the input promises
                /// has been fulfilled.
                /// </summary>
                /// <param name="values" type="Array" locid="WinJS.Promise.any_p:values">
                /// An array that contains promise objects or objects whose property
                /// values include promise objects.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.any_returnValue">
                /// A promise that on fulfillment yields the value of the input (complete or error).
                /// </returns>
                /// </signature>
                return new Promise(
                    function (complete, error, progress) {
                        var keys = Object.keys(values);
                        var errors = Array.isArray(values) ? [] : {};
                        if (keys.length === 0) {
                            complete();
                        }
                        var canceled = 0;
                        keys.forEach(function (key) {
                            Promise.as(values[key]).then(
                                function () { complete({ key: key, value: values[key] }); },
                                function (e) {
                                    if (e instanceof Error && e.name === canceledName) {
                                        if ((++canceled) === keys.length) {
                                            complete(WinJS.Promise.cancel);
                                        }
                                        return;
                                    }
                                    error({ key: key, value: values[key] });
                                }
                            );
                        });
                    },
                    function () {
                        var keys = Object.keys(values);
                        keys.forEach(function (key) {
                            var promise = Promise.as(values[key]);
                            if (typeof promise.cancel === "function") {
                                promise.cancel();
                            }
                        });
                    }
                );
            },
            as: function Promise_as(value) {
                /// <signature helpKeyword="WinJS.Promise.as">
                /// <summary locid="WinJS.Promise.as">
                /// Returns a promise. If the object is already a promise it is returned;
                /// otherwise the object is wrapped in a promise.
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.as_p:value">
                /// The value to be treated as a promise.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.as_returnValue">
                /// A promise.
                /// </returns>
                /// </signature>
                if (value && typeof value === "object" && typeof value.then === "function") {
                    return value;
                }
                return new CompletePromise(value);
            },
            /// <field type="WinJS.Promise" helpKeyword="WinJS.Promise.cancel" locid="WinJS.Promise.cancel">
            /// Canceled promise value, can be returned from a promise completion handler
            /// to indicate cancelation of the promise chain.
            /// </field>
            cancel: {
                get: function () {
                    return (staticCanceledPromise = staticCanceledPromise || new ErrorPromise(new WinJS.ErrorFromName(canceledName)));
                }
            },
            dispatchEvent: function Promise_dispatchEvent(eventType, details) {
                /// <signature helpKeyword="WinJS.Promise.dispatchEvent">
                /// <summary locid="WinJS.Promise.dispatchEvent">
                /// Raises an event of the specified type and properties.
                /// </summary>
                /// <param name="eventType" locid="WinJS.Promise.dispatchEvent_p:eventType">
                /// The type (name) of the event.
                /// </param>
                /// <param name="details" locid="WinJS.Promise.dispatchEvent_p:details">
                /// The set of additional properties to be attached to the event object.
                /// </param>
                /// <returns type="Boolean" locid="WinJS.Promise.dispatchEvent_returnValue">
                /// Specifies whether preventDefault was called on the event.
                /// </returns>
                /// </signature>
                return promiseEventListeners.dispatchEvent(eventType, details);
            },
            is: function Promise_is(value) {
                /// <signature helpKeyword="WinJS.Promise.is">
                /// <summary locid="WinJS.Promise.is">
                /// Determines whether a value fulfills the promise contract.
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.is_p:value">
                /// A value that may be a promise.
                /// </param>
                /// <returns type="Boolean" locid="WinJS.Promise.is_returnValue">
                /// true if the specified value is a promise, otherwise false.
                /// </returns>
                /// </signature>
                return value && typeof value === "object" && typeof value.then === "function";
            },
            join: function Promise_join(values) {
                /// <signature helpKeyword="WinJS.Promise.join">
                /// <summary locid="WinJS.Promise.join">
                /// Creates a promise that is fulfilled when all the values are fulfilled.
                /// </summary>
                /// <param name="values" type="Object" locid="WinJS.Promise.join_p:values">
                /// An object whose fields contain values, some of which may be promises.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.join_returnValue">
                /// A promise whose value is an object with the same field names as those of the object in the values parameter, where
                /// each field value is the fulfilled value of a promise.
                /// </returns>
                /// </signature>
                return new Promise(
                    function (complete, error, progress) {
                        var keys = Object.keys(values);
                        var errors = Array.isArray(values) ? [] : {};
                        var results = Array.isArray(values) ? [] : {};
                        var undefineds = 0;
                        var pending = keys.length;
                        var argDone = function (key) {
                            if ((--pending) === 0) {
                                var errorCount = Object.keys(errors).length;
                                if (errorCount === 0) {
                                    complete(results);
                                } else {
                                    var canceledCount = 0;
                                    keys.forEach(function (key) {
                                        var e = errors[key];
                                        if (e instanceof Error && e.name === canceledName) {
                                            canceledCount++;
                                        }
                                    });
                                    if (canceledCount === errorCount) {
                                        complete(WinJS.Promise.cancel);
                                    } else {
                                        error(errors);
                                    }
                                }
                            } else {
                                progress({ Key: key, Done: true });
                            }
                        };
                        keys.forEach(function (key) {
                            var value = values[key];
                            if (value === undefined) {
                                undefineds++;
                            } else {
                                Promise.then(value,
                                    function (value) { results[key] = value; argDone(key); },
                                    function (value) { errors[key] = value; argDone(key); }
                                );
                            }
                        });
                        pending -= undefineds;
                        if (pending === 0) {
                            complete(results);
                            return;
                        }
                    },
                    function () {
                        Object.keys(values).forEach(function (key) {
                            var promise = Promise.as(values[key]);
                            if (typeof promise.cancel === "function") {
                                promise.cancel();
                            }
                        });
                    }
                );
            },
            removeEventListener: function Promise_removeEventListener(eventType, listener, capture) {
                /// <signature helpKeyword="WinJS.Promise.removeEventListener">
                /// <summary locid="WinJS.Promise.removeEventListener">
                /// Removes an event listener from the control.
                /// </summary>
                /// <param name='eventType' locid="WinJS.Promise.removeEventListener_eventType">
                /// The type (name) of the event.
                /// </param>
                /// <param name='listener' locid="WinJS.Promise.removeEventListener_listener">
                /// The listener to remove.
                /// </param>
                /// <param name='capture' locid="WinJS.Promise.removeEventListener_capture">
                /// Specifies whether or not to initiate capture.
                /// </param>
                /// </signature>
                promiseEventListeners.removeEventListener(eventType, listener, capture);
            },
            supportedForProcessing: false,
            then: function Promise_then(value, onComplete, onError, onProgress) {
                /// <signature helpKeyword="WinJS.Promise.then">
                /// <summary locid="WinJS.Promise.then">
                /// A static version of the promise instance method then().
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.then_p:value">
                /// the value to be treated as a promise.
                /// </param>
                /// <param name="onComplete" type="Function" locid="WinJS.Promise.then_p:complete">
                /// The function to be called if the promise is fulfilled with a value.
                /// If it is null, the promise simply
                /// returns the value. The value is passed as the single argument.
                /// </param>
                /// <param name="onError" type="Function" optional="true" locid="WinJS.Promise.then_p:error">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument.
                /// </param>
                /// <param name="onProgress" type="Function" optional="true" locid="WinJS.Promise.then_p:progress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.then_returnValue">
                /// A promise whose value is the result of executing the provided complete function.
                /// </returns>
                /// </signature>
                return Promise.as(value).then(onComplete, onError, onProgress);
            },
            thenEach: function Promise_thenEach(values, onComplete, onError, onProgress) {
                /// <signature helpKeyword="WinJS.Promise.thenEach">
                /// <summary locid="WinJS.Promise.thenEach">
                /// Performs an operation on all the input promises and returns a promise
                /// that has the shape of the input and contains the result of the operation
                /// that has been performed on each input.
                /// </summary>
                /// <param name="values" locid="WinJS.Promise.thenEach_p:values">
                /// A set of values (which could be either an array or an object) of which some or all are promises.
                /// </param>
                /// <param name="onComplete" type="Function" locid="WinJS.Promise.thenEach_p:complete">
                /// The function to be called if the promise is fulfilled with a value.
                /// If the value is null, the promise returns the value.
                /// The value is passed as the single argument.
                /// </param>
                /// <param name="onError" type="Function" optional="true" locid="WinJS.Promise.thenEach_p:error">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument.
                /// </param>
                /// <param name="onProgress" type="Function" optional="true" locid="WinJS.Promise.thenEach_p:progress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.thenEach_returnValue">
                /// A promise that is the result of calling Promise.join on the values parameter.
                /// </returns>
                /// </signature>
                var result = Array.isArray(values) ? [] : {};
                Object.keys(values).forEach(function (key) {
                    result[key] = Promise.as(values[key]).then(onComplete, onError, onProgress);
                });
                return Promise.join(result);
            },
            timeout: function Promise_timeout(time, promise) {
                /// <signature helpKeyword="WinJS.Promise.timeout">
                /// <summary locid="WinJS.Promise.timeout">
                /// Creates a promise that is fulfilled after a timeout.
                /// </summary>
                /// <param name="timeout" type="Number" optional="true" locid="WinJS.Promise.timeout_p:timeout">
                /// The timeout period in milliseconds. If this value is zero or not specified
                /// setImmediate is called, otherwise setTimeout is called.
                /// </param>
                /// <param name="promise" type="Promise" optional="true" locid="WinJS.Promise.timeout_p:promise">
                /// A promise that will be canceled if it doesn't complete before the
                /// timeout has expired.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.timeout_returnValue">
                /// A promise that is completed asynchronously after the specified timeout.
                /// </returns>
                /// </signature>
                var to = timeout(time);
                return promise ? timeoutWithPromise(to, promise) : to;
            },
            wrap: function Promise_wrap(value) {
                /// <signature helpKeyword="WinJS.Promise.wrap">
                /// <summary locid="WinJS.Promise.wrap">
                /// Wraps a non-promise value in a promise. You can use this function if you need
                /// to pass a value to a function that requires a promise.
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.wrap_p:value">
                /// Some non-promise value to be wrapped in a promise.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.wrap_returnValue">
                /// A promise that is successfully fulfilled with the specified value
                /// </returns>
                /// </signature>
                return new CompletePromise(value);
            },
            wrapError: function Promise_wrapError(error) {
                /// <signature helpKeyword="WinJS.Promise.wrapError">
                /// <summary locid="WinJS.Promise.wrapError">
                /// Wraps a non-promise error value in a promise. You can use this function if you need
                /// to pass an error to a function that requires a promise.
                /// </summary>
                /// <param name="error" locid="WinJS.Promise.wrapError_p:error">
                /// A non-promise error value to be wrapped in a promise.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.wrapError_returnValue">
                /// A promise that is in an error state with the specified value.
                /// </returns>
                /// </signature>
                return new ErrorPromise(error);
            },

            _veryExpensiveTagWithStack: {
                get: function () { return tagWithStack; },
                set: function (value) { tagWithStack = value; }
            },
            _veryExpensiveTagWithStack_tag: tag,
            _getStack: function () {
                try { throw new Error(); } catch (e) { return e.stack; }
            },

            _cancelBlocker: function Promise__cancelBlocker(input) {
                //
                // Returns a promise which on cancelation will still result in downstream cancelation while
                //  protecting the promise 'input' from being  canceled which has the effect of allowing 
                //  'input' to be shared amoung various consumers.
                //
                if (!Promise.is(input)) {
                    return Promise.wrap(input);
                }
                var complete;
                var error;
                var output = new WinJS.Promise(
                    function (c, e) {
                        complete = c;
                        error = e;
                    },
                    function () {
                        complete = null;
                        error = null;
                    }
                );
                input.then(
                    function (v) { complete && complete(v); },
                    function (e) { error && error(e); }
                );
                return output;
            },

        }
    );
    Object.defineProperties(Promise, WinJS.Utilities.createEventProperties(errorET));

    var SignalPromise = WinJS.Class.derive(PromiseStateMachine,
        function (cancel) {
            this._oncancel = cancel;
            this._setState(state_created);
            this._run();
        }, {
            _cancelAction: function () { this._oncancel && this._oncancel(); },
            _cleanupAction: function () { this._oncancel = null; }
        }, {
            supportedForProcessing: false
        }
    );

    var Signal = WinJS.Class.define(
        function Signal_ctor(oncancel) {
            this._promise = new SignalPromise(oncancel);
        }, {
            promise: {
                get: function () { return this._promise; }
            },

            cancel: function Signal_cancel() {
                this._promise.cancel();
            },
            complete: function Signal_complete(value) {
                this._promise._completed(value);
            },
            error: function Signal_error(value) {
                this._promise._error(value);
            },
            progress: function Signal_progress(value) {
                this._promise._progress(value);
            }
        }, {
            supportedForProcessing: false,
        }
    );

    // Publish WinJS.Promise
    //
    WinJS.Namespace.define("WinJS", {
        Promise: Promise,
        _Signal: Signal
    });

}(this));

 /***********************************************************
 * winjs-promise.js end
 **********************************************************/
//globalHolder.WinJS.Promise.all = globalHolder.WinJS.Promise.join;

 /***********************************************************
 * assign to global Class
 **********************************************************/
Promise = WinJS.Promise;
;var CoreUtilities;
(function (CoreUtilities) {
    // Contains utility functions that are common to Threshold clients - Cortana, Spartan OneBox etc.
    // Do not include client specfic code here.
    function deferFunction(functionPointer) {
        var originalArgs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            originalArgs[_i - 1] = arguments[_i];
        }
        return deferMethod.apply(null, [null, functionPointer].concat(originalArgs));
    }
    CoreUtilities.deferFunction = deferFunction;
    function deferMethod(sourceObject, functionPointer) {
        var originalArgs = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            originalArgs[_i - 2] = arguments[_i];
        }
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            if (!args || args.length === 0) {
                args = originalArgs;
            }
            else {
                for (var i in originalArgs) {
                    if (originalArgs.hasOwnProperty(i)) {
                        args.push(originalArgs[i]);
                    }
                }
            }
            return functionPointer.apply(sourceObject, args);
        };
    }
    CoreUtilities.deferMethod = deferMethod;
    // gets a property out of an object. 
    // should be used in cases where object has a lot of layers of properties.
    // the arguments will be object, list of properties. 
    // it works recursively so it will keep calling itself with the current object and the rest of the properties.
    // e.g. var a = { b: { c: { d: "e" } } } to get to "e", you can call getProperty(a, b, c, d)
    // will return null if any of the layers don't have what was passed in (e. g. getProperty(a, b, d))
    function getProperty() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        var currentState = args[0];
        for (var i = 1; i < args.length; i++) {
            if (currentState) {
                currentState = currentState[args[i]];
            }
            else {
                return null;
            }
        }
        return currentState;
    }
    CoreUtilities.getProperty = getProperty;
    // Legacy Support
    window["sj_df"] = deferFunction;
    window["sj_dm"] = deferMethod;
    window["sj_gp"] = getProperty;
})(CoreUtilities || (CoreUtilities = {}));
;/// <reference path="..\Declarations\Shared.d.ts"/>
/// <reference path="..\Declarations\Threshold.Utilities.d.ts"/>
/// <reference path="..\..\..\..\..\Feedback\src\Content\Script\Declarations\DebugCollector.d.ts" />
var ThresholdDiagnosticsProd = (function () {
    function ThresholdDiagnosticsProd() {
        this.debugStrings = [];
        sj_evt.bind("ajax.feedback.initialized", sj_dm(this, this.registerFeedbackDebugCallback), true);
        sj_evt.bind("ajax.threshold.pageStart", sj_dm(this, this.clearDebugStrings));
    }
    ThresholdDiagnosticsProd.prototype.recordApiString = function (debugString) {
        console.log(debugString);
        this.debugStrings.push(debugString);
    };
    ThresholdDiagnosticsProd.prototype.clearDebugStrings = function () {
        this.debugStrings.length = 0;
    };
    ThresholdDiagnosticsProd.prototype.collectDebugInfo = function (includePII) {
        var values = {};
        if (includePII) {
            values["apiDebug"] = this.debugStrings.toString();
        }
        return values;
    };
    ThresholdDiagnosticsProd.prototype.registerFeedbackDebugCallback = function (args) {
        var debugCollector = args[1]["debugCollector"];
        debugCollector.registerCollectionCallback(sj_dm(this, this.collectDebugInfo));
    };
    return ThresholdDiagnosticsProd;
})();
_w["ThresholdDiagnostics"] = new ThresholdDiagnosticsProd();
;
//]]></script><script type="text/javascript" src="/rms/rms%20answers%20Shared%20Threshold$Threshold.UtilitiesM2/nj/c4a5689c/6f3adeb8.js"></script><script type="text/javascript">//<![CDATA[
// ------------------------------------------------------------------------------
// <copyright file="SearchAppAndroid.Async.ts" company="Microsoft Corporation">
//     Copyright (c) Microsoft Corporation. All Rights Reserved.
//     Information Contained Herein is Proprietary and Confidential.
// </copyright>
// ------------------------------------------------------------------------------
/// <reference path="Declarations\CortanaSearch.d.ts" />
/// <reference path="..\..\..\..\Shared\Content\Content\Script\Declarations\Promise.Mock.d.ts" />
/// <reference path="..\..\..\..\Shared\Content\Content\Script\Declarations\Threshold.Utilities.d.ts" />
var WrapApi;
(function (WrapApi) {
    function completePromise(completionFunction) {
        if (WrapApi.AndroidReturnAsync) {
            // Set a timeout to finish resolution after the current call stack of execution finished.
            sb_st(function () { return completionFunction(); }, 0);
        }
        else {
            // To maintain current behavior, resolve synchronously.
            completionFunction();
        }
    }
    // This method clones an object while providing a wrapMethod bridges between one implementation of a function and another.
    // We use it to make sure the object we get back from Cortana API calls can fall back to our mock implementations if Cortana APIs fail or are not implemented.
    function wrapAndroidApiAsynchronousable(cortanaObject) {
        if (!cortanaObject) {
            return;
        }
        // we don't implement the following as QF and device search are not part of CoA
        // searchResultsView: ISearchResultsView;
        // searchBox: ISearchBox;
        var uniqueEventId = 1;
        function getRandomId() {
            return uniqueEventId++;
        }
        function callNativeAsync(apiName) {
            var params = Array.prototype.slice.call(arguments, 1);
            return new Promise(function (resolve, reject) {
                if (!apiName || typeof cortanaObject[apiName] !== 'function') {
                    completePromise(reject);
                }
                var eventId = getRandomId();
                var eventName = 'callNativeAsync_' + apiName + '_' + eventId;
                function eventHandler(jsonParams) {
                    removeCortanaEventListener(eventName, eventHandler);
                    if (!jsonParams) {
                        return;
                    }
                    var result = jsonParams.result || null;
                    if (jsonParams.status === 'resolved') {
                        resolve(result);
                    }
                    else {
                        reject(result);
                    }
                }
                // Add event listener
                addCortanaEventListener(eventName, eventHandler);
                // Call native projected API
                params.push(eventName);
                cortanaObject[apiName].apply(cortanaObject, params);
            });
        }
        var nativeEventListenerMap = {};
        function addCortanaEventListener(eventName, handler) {
            if (!eventName) {
                return;
            }
            if (nativeEventListenerMap[eventName] !== undefined) {
                SharedLogHelper.LogWarning("addCortanaEventListener", "CoA projected API", "eventName exists");
                return;
            }
            nativeEventListenerMap[eventName] = handler;
            cortanaObject.registerEventListener(eventName, "CortanaApp.triggerCortanaEventListenerFromNative");
        }
        function removeCortanaEventListener(eventName, handler) {
            if (!eventName) {
                return;
            }
            if (nativeEventListenerMap[eventName] === undefined) {
                SharedLogHelper.LogWarning("removeCortanaEventListener", "CoA projected API", "eventName not exists");
                return;
            }
            delete nativeEventListenerMap[eventName];
            cortanaObject.removeEventListener(eventName);
        }
        cortanaObject.triggerCortanaEventListenerFromNative = function (eventName, params) {
            if (!eventName) {
                return;
            }
            var eventHandler = nativeEventListenerMap[eventName];
            if (!eventHandler) {
                return;
            }
            var jsonParams = {};
            try {
                jsonParams = JSON.parse(params);
            }
            catch (ex) {
                SharedLogHelper.LogError("triggerCortanaEventListenerFromNative", "CoA projected API", ex);
            }
            if (typeof eventHandler === 'function') {
                eventHandler.call(null, jsonParams);
            }
        };
        cortanaObject.isCortanaEnabled = cortanaObject.getIsCortanaEnabled();
        cortanaObject.isBingEnabled = cortanaObject.getIsBingEnabled();
        cortanaObject.isMobile = cortanaObject.getIsMobile();
        cortanaObject.region = cortanaObject.getRegion(); // The country code for the current region  
        cortanaObject.uiLanguage = cortanaObject.getUiLanguage(); // the language code for localized resources  
        cortanaObject.sessionId = cortanaObject.getSessionId(); // Logged in the Client to identify App open -> App close "sessions"  
        cortanaObject.impressionId = cortanaObject.getImpressionId(); // Produced by the client & logged by the server to identify each Keystroke  
        if (typeof cortanaObject.getCurrentState === 'function') {
            cortanaObject.currentState = cortanaObject.getCurrentState();
        }
        cortanaObject.launcher = cortanaObject.launcher || {
            launchUriAsync: function (uri, options) {
                return callNativeAsync.call(null, 'launchUriSync', uri, options);
            },
            launchRAFAsync: function (rawQuery, formCode) {
                cortanaObject.launchRAFSync(rawQuery, formCode);
            },
            startPhoneCallAsync: function (phoneNumber, displayName) {
                return new Promise(function (resolve, reject) {
                    cortanaObject.startPhoneCallSync(phoneNumber, displayName);
                    completePromise(function () { return resolve(true); });
                });
            },
            navigateReactiveViewAsync: function (rawQuery, formCode) {
                return new Promise(function (resolve, reject) {
                    var result = false;
                    if (cortanaObject.navigateReactiveViewSync) {
                        result = cortanaObject.navigateReactiveViewSync(rawQuery, formCode);
                    }
                    completePromise(function () { return resolve(result); });
                });
            }
        };
        cortanaObject.proactiveView = cortanaObject.proactiveView || {
            invalidateCacheAsync: function () {
                return new Promise(function (resolve, reject) {
                    var result = false;
                    if (cortanaObject.invalidateCacheSync) {
                        result = cortanaObject.invalidateCacheSync();
                    }
                    completePromise(function () { return resolve(result); });
                });
            },
            perfMetrics: {
                lookup: function (perfMetricKey) {
                    var result = 0;
                    if (cortanaObject.perfMetricLookup) {
                        result = cortanaObject.perfMetricLookup(perfMetricKey);
                    }
                    return new Date(result);
                }
            }
        };
        cortanaObject.getQueryHeadersAsync = function () {
            return new Promise(function (resolve, reject) {
                var headerString = cortanaObject.getQueryHeadersSync();
                var headers = JSON.parse(headerString);
                completePromise(function () { return resolve(headers); });
            });
        };
        if (typeof cortanaObject.navigateWebViewSync === 'function') {
            cortanaObject.navigateWebViewAsync = function (uri) {
                return new Promise(function (resolve, reject) {
                    cortanaObject.navigateWebViewSync(uri);
                    completePromise(function () { return resolve(true); });
                });
            };
        }
        cortanaObject.navigateWebViewWithPostAsync = function (uri, parameters) {
            return new Promise(function (resolve, reject) {
                var postDataStringified = JSON.stringify(parameters);
                cortanaObject.navigateWebViewWithPostSync(uri, postDataStringified);
                completePromise(function () { return resolve(true); });
            });
        };
        cortanaObject.navigateWebViewBackAsync = function (frameCount) {
            return new Promise(function (resolve, reject) {
                cortanaObject.navigateWebViewBackSync(frameCount);
                completePromise(function () { return resolve(true); });
            });
        };
        cortanaObject.showWebViewAsync = function () {
            return new Promise(function (resolve, reject) {
                cortanaObject.showWebViewSync();
                completePromise(function () { return resolve(true); });
            });
        };
        cortanaObject.launchExperienceByName = function (experienceName, parameters) {
            var experienceDataStringified = JSON.stringify(parameters);
            cortanaObject.launchExperienceByNameSync(experienceName, experienceDataStringified);
        };
        var eventListenerMap = {};
        function triggerElement(element, index, array) {
            element();
        }
        ;
        cortanaObject.addEventListener = function (eventName, cb) {
            if (eventListenerMap[eventName] === undefined) {
                eventListenerMap[eventName] = [];
            }
            eventListenerMap[eventName].push(cb);
        };
        cortanaObject.triggerEventListener = function (eventName) {
            if (eventListenerMap[eventName] !== undefined) {
                eventListenerMap[eventName].forEach(triggerElement);
            }
        };
        function doneablePromise(fn) {
            var promise = new Promise(fn);
            if (typeof Promise.prototype.done !== 'function') {
                promise.done = function (onFulfilled, onRejected) {
                    promise.then(onFulfilled, onRejected);
                };
            }
            return promise;
        }
        var Screenshot = function (fileName, content, type) {
            this.fileName = fileName;
            this.contentType = type;
            var base64Content = content;
            this.getBase64ContentAsync = function () {
                return doneablePromise(function (resolve, reject) {
                    completePromise(function () { return resolve(base64Content); });
                });
            };
        };
        cortanaObject.getFeedbackFilesAsync = function () {
            return doneablePromise(function (resolve, reject) {
                var data = JSON.parse(cortanaObject.getFeedbackFilesSync());
                if (!data) {
                    completePromise(function () { return reject("Get feedback files failed."); });
                    return;
                }
                var screenshots = data.screenshots;
                var files = {};
                var i = 0;
                var iLength = 0;
                if (screenshots && screenshots.length > 0) {
                    for (i = 0, iLength = screenshots.length; i < iLength; i++) {
                        files[i] = new Screenshot(screenshots[i].fileName, screenshots[i].content, screenshots[i].type);
                    }
                }
                files['size'] = iLength;
                completePromise(function () { return resolve(files); });
            });
        };
        //TFS 5227831: [CoA] In order to support proactive peek, implement cortanaApp.logMeasure() and cortanaApp.setNonAnimatingCortanaText(…)
        cortanaObject.logMeasure = function () {
        };
        cortanaObject.setNonAnimatingCortanaText = function () {
        };
        cortanaObject.processNLCommandAsync = function (commandTaskFrame, impressionId) {
            return new Promise(function (resolve, reject) {
                var result = cortanaObject.processNLCommandSync(commandTaskFrame, impressionId);
                completePromise(function () { return resolve(result); });
            });
        };
        cortanaObject.searchResultsView = {};
        cortanaObject.searchResultsView.executeSearchAsync = function (query) {
            return new Promise(function (resolve, reject) {
                var result = cortanaObject.executeSearchSync(query);
                completePromise(function () { return resolve(result); });
            });
        };
        cortanaObject.searchResultsView.deviceSearch = {};
        cortanaObject.searchResultsView.deviceSearch.findAppsAsync = function (appIds, impressionId) {
            return new Promise(function (resolve, reject) {
                var appMapString = cortanaObject.findAppsSync(appIds, impressionId);
                var appMap;
                if (appMapString) {
                    try {
                        appMap = JSON.parse(appMapString);
                    }
                    catch (e) {
                        alert(e);
                    }
                }
                completePromise(function () { return resolve(appMap); });
            });
        };
        // SPA - Potable Cortana
        cortanaObject.spaDialogRuntime = cortanaObject.spaDialogRuntime || {
            // NL APIs
            startLanguageUnderstandingFromVoiceAsync: function (cuInput) {
                return new Promise(function (resolve, reject) {
                    var result = cortanaObject.startLanguageUnderstandingFromVoiceSync(cuInput);
                    completePromise(function () { return resolve(result); });
                });
            },
            startDictationAsync: function (cuInput) {
                return new Promise(function (resolve, reject) {
                    cortanaObject.startDictationSync(cuInput);
                    completePromise(function () { return resolve(true); });
                });
            },
            endpointAudio: function (operationId) {
                cortanaObject.endpointAudio(operationId);
            },
            dialogComplete: function (spaIdentifier, completionState) {
                cortanaObject.dialogComplete(spaIdentifier, completionState);
            },
            // TTS APIs
            playEarconAsync: function (earConType) {
                return new Promise(function (resolve, reject) {
                    cortanaObject.playEarconSync(earConType);
                    completePromise(function () { return resolve(true); });
                });
            },
            // 
            speakAsync: function (ssmlData) {
                return callNativeAsync.call(null, 'speakSync', ssmlData);
            },
            // 
            stopSpeakingAsync: function () {
                return new Promise(function (resolve, reject) {
                    cortanaObject.stopSpeakingSync();
                    completePromise(function () { return resolve(true); });
                });
            },
            // UI update APIs
            // 
            updateTrex: function (trexText) {
                cortanaObject.updateTrex(trexText);
            },
            // 
            updateGui: function (uiState) {
                cortanaObject.updateGui(uiState);
            },
            changeSticMode: function (isEnabled) {
                cortanaObject.changeSticMode(isEnabled);
            },
            changeSticStateAndInputMode: function (spaSticState, spaSticInputMode) {
                cortanaObject.changeSticStateAndInputMode(spaSticState, spaSticInputMode);
            },
            addEventListener: function (eventName, handler) {
                if (!eventName) {
                    return;
                }
                addCortanaEventListener(eventName, handler);
            },
            removeEventListener: function (eventName, handler) {
                if (!eventName) {
                    return;
                }
                removeCortanaEventListener(eventName, handler);
            }
        };
        return cortanaObject;
    }
    WrapApi.wrapAndroidApiAsynchronousable = wrapAndroidApiAsynchronousable;
})(WrapApi || (WrapApi = {}));
var SearchAppWrapper = {
    CortanaApp: (_w['CortanaApp'] ? WrapApi.wrapAndroidApiAsynchronousable(_w['CortanaApp']) : _w['MockCortanaAppInstance'])
};
;///<reference path="..\Declarations\Shared.d.ts"/>
var sj_b = _d.body;
;///<reference path="queue.ts"/>
BM.trigger();
;_G.AppVer="8_1_2_5116612";
//]]></script><script type="text/javascript">//<![CDATA[
_G.FCT=new Date;
//]]></script><script type="text/javascript">//<![CDATA[
_G.BCT=new Date;
//]]></script><style type="text/css">/*
    Use the javascipt methods in Animation.ts to toggle the animation instead of directly setting the class.      
        
    b_slide - Use this class when an element may slide up/down via animation.  Used by toggleSlide in Animation.ts.
    b_fade - Use this class when an element may fade in/out via animation. Upon completion of animation, element will completely disappear and occupies no space in view. Used by toggleFade in Animation.ts
    b_fadeUp - Use this class when an element may fade up/down via animation. Upon completion of animation, element will completely disappear and occupies no space in view. Used by toggleFadeUp in Animation.ts
    b_slideListUp - Use this class to animate a list of items slide up from bottom and arrive at destination one by one. Used by cascadeList in Animation.ts
    b_anim - Use this class when an element may show/hide via animation.     
    Animate by toggling the b_hide class. We override the default behavior of b_hide here.
*/

.b_fade,
.b_slide,
.b_anim,
.b_fadeUp,
.b_slideListHide,
.b_slideTranslate {
  overflow: hidden;
}
.b_fade.b_hide,
.b_slide.b_hide,
.b_slideTranslate.b_hide,
.b_anim.b_hide,
.b_fadeUp.b_hide,
.b_slideListHide {
  display: block;
  /* Needs to be important to override the values from other classes */
  padding-top/* bingcss-ignore */: 0 !important;
  padding-bottom/* bingcss-ignore */: 0 !important;
  margin-top/* bingcss-ignore */: 0 !important;
  margin-bottom/* bingcss-ignore */: 0 !important;
  border-top/* bingcss-ignore */: 0 !important;
  border-bottom/* bingcss-ignore */: 0 !important;
}
.b_slide.b_hide,
.b_anim.b_hide,
.b_slideListHide {
  /* Needs to be important to override the values from other classes */
  height/* bingcss-ignore */: 0 !important;
}
/* slide up/down the element with fixed/known height */

.b_anim {
  -webkit-transition: all 250ms;
  -moz-transition: all 250ms;
  -o-transition: all 250ms;
  transition: all 250ms;
}
/* fade out the element and makes sure no space is occupied upon completion*/

.b_fade {
  opacity: 1;
  max-height: 9999px;
  /* open up the container first, then fade in the content*/
  -webkit-transition: opacity linear 250ms, max-height linear 0ms 0ms;
  -moz-transition: opacity linear 250ms, max-height linear 0ms 0ms;
  -o-transition: opacity linear 250ms, max-height linear 0ms 0ms;
  transition: opacity linear 250ms, max-height linear 0ms 0ms;
}
.b_fade.b_hide {
  opacity: 0;
  max-height: 0;
  /* fade out the content first, then collapse the container*/
  -webkit-transition: opacity linear 250ms, max-height linear 0ms 250ms;
  -moz-transition: opacity linear 250ms, max-height linear 0ms 250ms;
  -o-transition: opacity linear 250ms, max-height linear 0ms 250ms;
  transition: opacity linear 250ms, max-height linear 0ms 250ms;
}
/* fade up the element and makes sure no space is occupied upon completion.  This is usually used for text animation*/

.b_fadeUp {
  opacity: 1;
  max-height: 9999px;
  -webkit-transform: translateY(0);
  -moz-transform: translateY(0);
  -o-transform: translateY(0);
  transform: translateY(0);
  -webkit-transition: opacity linear 170ms, -webkit-transform cubic-bezier(0.15, 0.85, 0.35, 1) 500ms, max-height linear 0ms;
  -moz-transition: opacity linear 170ms, -moz-transform cubic-bezier(0.15, 0.85, 0.35, 1) 500ms, max-height linear 0ms;
  -o-transition: opacity linear 170ms, -o-transform cubic-bezier(0.15, 0.85, 0.35, 1) 500ms, max-height linear 0ms;
  transition: opacity linear 170ms, transform cubic-bezier(0.15, 0.85, 0.35, 1) 500ms, max-height linear 0ms;
}
.b_fadeUp.b_hide {
  opacity: 0;
  max-height: 0;
  -webkit-transform: translateY(10px);
  -moz-transform: translateY(10px);
  -o-transform: translateY(10px);
  transform: translateY(10px);
  -webkit-transition: opacity linear 170ms, -webkit-transform cubic-bezier(0.15, 0.85, 0.35, 1) 500ms, max-height linear 0ms 500ms;
  -moz-transition: opacity linear 170ms, -moz-transform cubic-bezier(0.15, 0.85, 0.35, 1) 500ms, max-height linear 0ms 500ms;
  -o-transition: opacity linear 170ms, -o-transform cubic-bezier(0.15, 0.85, 0.35, 1) 500ms, max-height linear 0ms 500ms;
  transition: opacity linear 170ms, transform cubic-bezier(0.15, 0.85, 0.35, 1) 500ms, max-height linear 0ms 500ms;
}
/* slide up/down the element */

.b_slide,
.b_slide.b_hide {
  -webkit-transition: height cubic-bezier(0.15, 0.85, 0.35, 1) 250ms;
  -moz-transition: height cubic-bezier(0.15, 0.85, 0.35, 1) 250ms;
  -o-transition: height cubic-bezier(0.15, 0.85, 0.35, 1) 250ms;
  transition: height cubic-bezier(0.15, 0.85, 0.35, 1) 250ms;
}
.b_slideTranslate {
  max-height: 9999px;
  -webkit-transform: translateY(0);
  -moz-transform: translateY(0);
  -o-transform: translateY(0);
  transform: translateY(0);
  -webkit-transition: -webkit-transform cubic-bezier(0.15, 0.85, 0.35, 1) 250ms, max-height linear 0ms 0ms;
  -moz-transition: -moz-transform cubic-bezier(0.15, 0.85, 0.35, 1) 250ms, max-height linear 0ms 0ms;
  -o-transition: -o-transform cubic-bezier(0.15, 0.85, 0.35, 1) 250ms, max-height linear 0ms 0ms;
  transition: transform cubic-bezier(0.15, 0.85, 0.35, 1) 250ms, max-height linear 0ms 0ms;
}
.b_slideTranslate.b_hide {
  max-height: 0;
  -webkit-transform: translateY(-200px);
  -moz-transform: translateY(-200px);
  -o-transform: translateY(-200px);
  transform: translateY(-200px);
  -webkit-transition: -webkit-transform cubic-bezier(0.15, 0.85, 0.35, 1) 250ms, max-height linear 0ms 250ms;
  -moz-transition: -moz-transform cubic-bezier(0.15, 0.85, 0.35, 1) 250ms, max-height linear 0ms 250ms;
  -o-transition: -o-transform cubic-bezier(0.15, 0.85, 0.35, 1) 250ms, max-height linear 0ms 250ms;
  transition: transform cubic-bezier(0.15, 0.85, 0.35, 1) 250ms, max-height linear 0ms 250ms;
}
.b_fadeAnim {
  -webkit-animation: fadeAnim linear 330ms;
  -moz-animation: fadeAnim linear 330ms;
  -o-animation: fadeAnim linear 330ms;
  animation: fadeAnim linear 330ms;
}
/* slide up a list of items from below the viewport into the canvas. Starting translations will be set in Animation.ts.
   Items will arrive one by one, starting from the top. */

.b_slideListHide > li {
  opacity: 0;
}
.b_slideUp.b_slideListHide {
  opacity: 0;
  -webkit-transform: translateY(200px);
  -moz-transform: translateY(200px);
  -o-transform: translateY(200px);
  transform: translateY(200px);
}
.b_slideUp:not(.b_slideListHide),
.b_slideListUp:not(.b_slideListHide) {
  opacity: 1;
  -webkit-transform: translateY(0);
  -moz-transform: translateY(0);
  -o-transform: translateY(0);
  -ms-transform: translateY(0);
  transform: translateY(0);
  -webkit-transition: -webkit-transform cubic-bezier(0.15, 0.85, 0.35, 1) 400ms, opacity linear 250ms;
  -moz-transition: -moz-transform cubic-bezier(0.15, 0.85, 0.35, 1) 400ms, opacity linear 250ms;
  -o-transition: -o-transform cubic-bezier(0.15, 0.85, 0.35, 1) 400ms, opacity linear 250ms;
  transition: transform cubic-bezier(0.15, 0.85, 0.35, 1) 400ms, opacity linear 250ms;
}
/* Keyframes animation */

@keyframes fadeAnim {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
@-webkit-keyframes fadeAnim {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
@-moz-keyframes fadeAnim {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
@-o-keyframes fadeAnim {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
/* force type to Segoe UI typography for themable pages */

/* register with SegoeFontFaces as a dependency */

.b_theme body,
.b_theme body h3,
.b_theme body h4,
.b_theme body h5,
.b_theme body .b_groupLabel {
  font-size: 15px;
  line-height: 20px;
}
.b_theme body .b_groupLabel,
.b_theme body .b_strong,
.b_theme body strong,
.b_theme body .pushpin,
.b_theme body .cardLabel {
  font-weight: 600;
  /* Semibold variant */

}
.b_theme body h1,
.b_theme body h2,
.b_theme body .b_secondaryFocus,
.b_theme body .b_focusTextExtraSmall,
.b_theme body .b_mText {
  font-size: 20px;
  line-height: 24px;
}
.b_theme body select,
.b_theme body .s_btn.b_highlighted a,
.b_theme body input[type="text"],
.b_theme body .cbtn input {
  font-size: 15px;
}
.b_theme body #fti3,
.b_theme body #ftrLnks,
.b_theme body .b_focusLabel,
.b_theme body .b_footnote,
.b_theme body .b_meta,
.b_theme body .b_corActList,
.b_theme body .pushpin,
.b_theme body .cardLabel,
.b_theme body .sb_count {
  font-size: 13px;
  line-height: 16px;
}
/*Focus text styles*/

.b_theme body .b_focusTextSmall,
.b_theme body .b_focusTextMedium,
.b_theme body .b_focusTextLarge {
  font-weight: 300;
  /* Semilight variant */

}
.b_theme body .b_focusTextSmall {
  font-size: 24px;
  line-height: 28px;
}
.b_theme body .b_focusTextMedium {
  font-size: 34px;
  line-height: 40px;
}
.b_theme body .b_focusTextLarge {
  font-size: 46px;
  line-height: 56px;
}
.b_theme body,
.b_theme body input,
.b_theme body textarea,
.b_theme body button,
.b_theme body select,
.b_theme body option,
.b_theme body strong,
.b_theme body .b_strong,
.b_theme body .b_no h4,
.b_theme body .b_focusTextSmall,
.b_theme body .b_focusTextMedium,
.b_theme body .b_focusTextLarge {
  font-family: Segoe, Arial, sans-serif;
}
.b_theme body:-ms-lang(am, ti),
.b_theme body input:-ms-lang(am, ti),
.b_theme body textarea:-ms-lang(am, ti),
.b_theme body button:-ms-lang(am, ti),
.b_theme body select:-ms-lang(am, ti),
.b_theme body option:-ms-lang(am, ti),
.b_theme body strong:-ms-lang(am, ti),
.b_theme body .b_strong:-ms-lang(am, ti),
.b_theme body .b_no h4:-ms-lang(am, ti),
.b_theme body .b_focusTextSmall:-ms-lang(am, ti),
.b_theme body .b_focusTextMedium:-ms-lang(am, ti),
.b_theme body .b_focusTextLarge:-ms-lang(am, ti) {
  font-family: Ebrima, Segoe, Arial, sans-serif;
}
.b_theme body:-ms-lang(as, bn, gu, hi, kn, kok, ml, mr, ne, or, pa, si, ta, te),
.b_theme body input:-ms-lang(as, bn, gu, hi, kn, kok, ml, mr, ne, or, pa, si, ta, te),
.b_theme body textarea:-ms-lang(as, bn, gu, hi, kn, kok, ml, mr, ne, or, pa, si, ta, te),
.b_theme body button:-ms-lang(as, bn, gu, hi, kn, kok, ml, mr, ne, or, pa, si, ta, te),
.b_theme body select:-ms-lang(as, bn, gu, hi, kn, kok, ml, mr, ne, or, pa, si, ta, te),
.b_theme body option:-ms-lang(as, bn, gu, hi, kn, kok, ml, mr, ne, or, pa, si, ta, te),
.b_theme body strong:-ms-lang(as, bn, gu, hi, kn, kok, ml, mr, ne, or, pa, si, ta, te),
.b_theme body .b_strong:-ms-lang(as, bn, gu, hi, kn, kok, ml, mr, ne, or, pa, si, ta, te),
.b_theme body .b_no h4:-ms-lang(as, bn, gu, hi, kn, kok, ml, mr, ne, or, pa, si, ta, te),
.b_theme body .b_focusTextSmall:-ms-lang(as, bn, gu, hi, kn, kok, ml, mr, ne, or, pa, si, ta, te),
.b_theme body .b_focusTextMedium:-ms-lang(as, bn, gu, hi, kn, kok, ml, mr, ne, or, pa, si, ta, te),
.b_theme body .b_focusTextLarge:-ms-lang(as, bn, gu, hi, kn, kok, ml, mr, ne, or, pa, si, ta, te) {
  font-family: "Nirmala UI", Segoe, Arial, sans-serif;
}
.b_theme body:-ms-lang(chr-CHER-US),
.b_theme body input:-ms-lang(chr-CHER-US),
.b_theme body textarea:-ms-lang(chr-CHER-US),
.b_theme body button:-ms-lang(chr-CHER-US),
.b_theme body select:-ms-lang(chr-CHER-US),
.b_theme body option:-ms-lang(chr-CHER-US),
.b_theme body strong:-ms-lang(chr-CHER-US),
.b_theme body .b_strong:-ms-lang(chr-CHER-US),
.b_theme body .b_no h4:-ms-lang(chr-CHER-US),
.b_theme body .b_focusTextSmall:-ms-lang(chr-CHER-US),
.b_theme body .b_focusTextMedium:-ms-lang(chr-CHER-US),
.b_theme body .b_focusTextLarge:-ms-lang(chr-CHER-US) {
  font-family: Gadugi, Segoe, Arial, sans-serif;
}
.b_theme body:-ms-lang(ja),
.b_theme body input:-ms-lang(ja),
.b_theme body textarea:-ms-lang(ja),
.b_theme body button:-ms-lang(ja),
.b_theme body select:-ms-lang(ja),
.b_theme body option:-ms-lang(ja),
.b_theme body strong:-ms-lang(ja),
.b_theme body .b_strong:-ms-lang(ja),
.b_theme body .b_no h4:-ms-lang(ja),
.b_theme body .b_focusTextSmall:-ms-lang(ja),
.b_theme body .b_focusTextMedium:-ms-lang(ja),
.b_theme body .b_focusTextLarge:-ms-lang(ja) {
  font-family: "Yu Gothic UI", Segoe, Arial, sans-serif;
}
.b_theme body:-ms-lang(ko),
.b_theme body input:-ms-lang(ko),
.b_theme body textarea:-ms-lang(ko),
.b_theme body button:-ms-lang(ko),
.b_theme body select:-ms-lang(ko),
.b_theme body option:-ms-lang(ko),
.b_theme body strong:-ms-lang(ko),
.b_theme body .b_strong:-ms-lang(ko),
.b_theme body .b_no h4:-ms-lang(ko),
.b_theme body .b_focusTextSmall:-ms-lang(ko),
.b_theme body .b_focusTextMedium:-ms-lang(ko),
.b_theme body .b_focusTextLarge:-ms-lang(ko) {
  font-family: "Malgun Gothic", Segoe, Arial, sans-serif;
}
.b_theme body:-ms-lang(th, km, lo),
.b_theme body input:-ms-lang(th, km, lo),
.b_theme body textarea:-ms-lang(th, km, lo),
.b_theme body button:-ms-lang(th, km, lo),
.b_theme body select:-ms-lang(th, km, lo),
.b_theme body option:-ms-lang(th, km, lo),
.b_theme body strong:-ms-lang(th, km, lo),
.b_theme body .b_strong:-ms-lang(th, km, lo),
.b_theme body .b_no h4:-ms-lang(th, km, lo),
.b_theme body .b_focusTextSmall:-ms-lang(th, km, lo),
.b_theme body .b_focusTextMedium:-ms-lang(th, km, lo),
.b_theme body .b_focusTextLarge:-ms-lang(th, km, lo) {
  font-family: "Leelawadee UI", Segoe, Arial, sans-serif;
}
.b_theme body:-ms-lang(zh-CN, zh-Hans, zh-SG),
.b_theme body input:-ms-lang(zh-CN, zh-Hans, zh-SG),
.b_theme body textarea:-ms-lang(zh-CN, zh-Hans, zh-SG),
.b_theme body button:-ms-lang(zh-CN, zh-Hans, zh-SG),
.b_theme body select:-ms-lang(zh-CN, zh-Hans, zh-SG),
.b_theme body option:-ms-lang(zh-CN, zh-Hans, zh-SG),
.b_theme body strong:-ms-lang(zh-CN, zh-Hans, zh-SG),
.b_theme body .b_strong:-ms-lang(zh-CN, zh-Hans, zh-SG),
.b_theme body .b_no h4:-ms-lang(zh-CN, zh-Hans, zh-SG),
.b_theme body .b_focusTextSmall:-ms-lang(zh-CN, zh-Hans, zh-SG),
.b_theme body .b_focusTextMedium:-ms-lang(zh-CN, zh-Hans, zh-SG),
.b_theme body .b_focusTextLarge:-ms-lang(zh-CN, zh-Hans, zh-SG) {
  font-family: "Microsoft YaHei UI", Segoe, Arial, sans-serif;
}
.b_theme body:-ms-lang(zh-HK, zh-TW, zh-Hant, zh-MO),
.b_theme body input:-ms-lang(zh-HK, zh-TW, zh-Hant, zh-MO),
.b_theme body textarea:-ms-lang(zh-HK, zh-TW, zh-Hant, zh-MO),
.b_theme body button:-ms-lang(zh-HK, zh-TW, zh-Hant, zh-MO),
.b_theme body select:-ms-lang(zh-HK, zh-TW, zh-Hant, zh-MO),
.b_theme body option:-ms-lang(zh-HK, zh-TW, zh-Hant, zh-MO),
.b_theme body strong:-ms-lang(zh-HK, zh-TW, zh-Hant, zh-MO),
.b_theme body .b_strong:-ms-lang(zh-HK, zh-TW, zh-Hant, zh-MO),
.b_theme body .b_no h4:-ms-lang(zh-HK, zh-TW, zh-Hant, zh-MO),
.b_theme body .b_focusTextSmall:-ms-lang(zh-HK, zh-TW, zh-Hant, zh-MO),
.b_theme body .b_focusTextMedium:-ms-lang(zh-HK, zh-TW, zh-Hant, zh-MO),
.b_theme body .b_focusTextLarge:-ms-lang(zh-HK, zh-TW, zh-Hant, zh-MO) {
  font-family: "Microsoft JhengHei UI", Segoe, Arial, sans-serif;
}
/* color overrides for thbrand themable pages */

.b_theme body a:not(.b_moreLink):not(.b_accentColor),
.b_theme body a:visited:not(.b_moreLink):not(.b_accentColor),
.b_theme body #b_results > li a:visited:not(.b_moreLink):not(.b_accentColor) {
  color: #0078d7;
}
.b_theme body .sml a:not(.b_accentColor),
.b_theme body .sml a:visited:not(.b_accentColor),
.b_theme body .b_corActList a:not(.b_accentColor),
.b_theme body .b_corActList a:visited:not(.b_accentColor) {
  color/* bingcss-ignore: expansion links should inherit the accent color */: inherit;
}
/* The background is always transparent because there are cases we need contents behind our app to show through */

html[lang].b_theme,
html.b_theme body,
html.b_theme body #b_content,
html.b_theme body #b_pole .b_ans,
html.b_theme body #b_results > li,
html.b_theme body #b_content > .sml {
  background-color: transparent;
}
/* color overrides for Dark themable pages */

html[lang].b_thDark,
.b_thDark body,
.b_thDark body #b_results,
.b_thDark body #b_results .b_defaultText,
.b_thDark body #b_results a.recourseLink,
.b_thDark body .cbl,
.b_thDark body .b_corActList,
.b_thDark body .b_promoteText,
.b_thDark body .b_action {
  color: white;
}
.b_thDark body .b_factrow,
.b_thDark body .b_attribution,
.b_thDark body .b_focusLabel,
.b_thDark body .b_secondaryFocus,
.b_thDark body .b_secondaryText,
.b_thDark body .b_demoteText,
.b_thDark body .b_footnote,
.b_thDark body .b_dropdown,
.b_thDark body .b_footnote .cbl,
.b_thDark body .b_meta,
.b_thDark body .b_entitySubTitle,
.b_thDark body #b_results .b_footnote a,
.b_thDark body #b_results .b_footnote a:visited,
.b_thDark body cite,
.b_thDark body #b_results cite.sb_crmb a,
.b_thDark body #b_results cite a.sb_metalink {
  color/* bingcss-ignore: value not in palette; convert to LESS */: #bbbbbb;
}
.bucket:disabled
{
    border-width: 1px;
    border-color: Aqua;
}

.bucket:disabled:Hover
{
  border-width: 2px;
}

.bucket:disabled:focus
{
  border-width: 1px;
  background-color: AltMediumLow;
}

.bucket:active
{
  border-width: 2px;
}

.bucket
{
  border-color: ChromeHigh;
}

.bucket:active:Hover
{
  border-width: 2px;
  background-color: Aqua;
}

.bucket:active:focus
{
  background-color: Aqua;
  opacity: 0.7;
}

.bucket[contenteditable]:empty::before
{
    content: attr(data-content);
    color:gray;
}

.bucket:empty::before
{
    content: attr(data-content);
    color:gray;
}

.srmt
{
  float: bottom;
  margin-bottom: 224px;
}

.vt
{
  float:right;
}

#tail1 {
    position:absolute;
    bottom:-20px;
    right:20px;
    width:0;height:0;
    border-color:#a0c7ff transparent transparent transparent;
    border-width:6px;
    border-style:solid;
}

#tail2 {
    position:absolute;
    bottom:-18px;
    right:20px;
    width:0;height:0;
    border-color:#f9f9f9 transparent transparent transparent;
    border-width:6px;
    border-style:solid;
}

#remindTitle, #remindDate, #remindTime{
    margin-bottom: 1px;
    font-family: 'Segoe UI Semilight', 'Segoe UI Light', 'Segoe UI';
    font-size: 24pt;
}

#remindTitle, #remindDate, #remindTime
{
    display: inline-block;
    border: solid 1px;
    word-break: break-word;
    line-height: 41px;
    margin-top: 5px;
}

#remindOccurrences{
    width: auto;
    overflow: hidden;
}

#remindTitle, #remindDate, #remindTime{
    font-size: 24pt;
    padding-left: 4px;
    padding-right: 4px;
    padding-bottom: 4px;
}

#cancelButtonLink, #remindButtonLink
{
    border: 0;
    color: white;
    padding: 0px 12px;
    text-align: center;
    text-decoration: none;
    display: inline-block;
    font-size: 15px;    
    width: 96px;
    height: 32px;
    line-height: 32px;
}

#label, #summaryLabel
{
    font-size: 13px;
    font-family: 'Segoe UI Semilight', 'Segoe UI Light', 'Segoe UI';
}

#summaryLabel
{
    padding-bottom: 6px;
}

#summaryDateAndTime
{
    padding-left: 33px;
}/* Do nothing. */

z {
  a: 1;
}
p > .news_dt {
  color: #737373;
}
.sb_doct_txt {
  color: #3366bb;
  font-size: 11px;
  line-height: 22px;
  margin-right: 3px;
}
.mb_doct_txt {
  color: #737373;
}
.b_vList > li.b_annooverride {
  padding-bottom: 0;
}
.sa_uc{clear:both;padding:0 0 10px}.sa_uc:after{clear:both;content:'.';display:block;height:0;visibility:hidden}.sb_meta cite a,.sb_meta cite a:visited{color:#388222}#b_context .b_rs .b_vList > li {
  padding-bottom: 4px;
}
#b_context .b_rs > .b_vList {
  padding-bottom: 6px;
}
/* Special styling for when the emotion is in large mode */

.b_anno.large {
  font-size: 42px;
  line-height: 51px;
  text-align: center;
  font-weight: 300;
}
/*
    Initially hide various elements. Note that this is a pretty big hack to make sure the
    initial paint is correct. The JS ends up slapping a b_hide on the elements, but that doesn't
    generally get executed before the first paint so there may be some jumps in the rendering.
    So the JS will slap both b_hide and peek classes on to handle this state.
    Make sure this matches the SearchPeek JS.
*/

#b_header:not(.peek),
.b_anno ~ h2:not(.peek),
.b_anno ~ .b_focusLabel:not(.peek),
#b_results:not(.peek) > *:not(.b_cat3a),
.b_footer:not(.peek) {
  display: none;
}
html.peek,
body.peek {
  background-color: white;
}
@font-face {
  font-family: "icons";
  src: url(/sa/simg/BingIcons_v2.woff) format('woff');
}
.b_bingIcon:after {
  font-family: "icons";
  content: '\E030';
}
#b_content:not(.peekExpand) #b_results > .b_msg {
  padding: 0 12px 12px;
}
#b_results a.recourseLink {
  color: #404040;
}
#b_content:not(.peekExpand) #b_results > li {
  border-bottom: 0;
}
/*
//  cipl - Common play icon for use with text link
//  cipa - Common play icon link
//  cipg - Disabled common play icon
//  cipt - Disabled common play icon for use with text
//  ciptr - icon on right side
//  ciplr - icon on right side
*/

.cipt,
.cipg,
.cipa,
.cipl,
.ciptr,
.ciplr {
  display: inline-block;
}
.cipa,
.cipl,
.ciplr {
  cursor: pointer;
}
.vab {
  vertical-align: bottom;
}
.vam {
  vertical-align: middle;
}
.vat {
  vertical-align: top;
}
.vabl {
  vertical-align: baseline;
}
.vatt {
  vertical-align: text-top;
}
.vatb {
  vertical-align: text-bottom;
}
.cipt,
.cipl {
  margin-right: 10px;
}
.b_action > .cipt,
.b_action > .cipl {
  float: left;
}
.ciptr,
.ciplr {
  margin-left: 10px;
}
</style><link rel="stylesheet" href="/rms/rms%20answers%20Web%20CoreStyles$CortanaMDLSymbols/nc/88a58ffe/adc9b0f9.css" type="text/css"><style type="text/css">.b_imagePair .inner img,
.b_hList img {
  display: block;
}
.b_imagePair > .inner,
.b_hList .cico {
  padding-bottom: 10px;
}
.b_title .b_imagePair > .inner,
.b_vList > li > .b_imagePair > .inner,
.b_hList .b_imagePair > .inner,
.b_vPanel > div > .b_imagePair > .inner,
.b_gridList .b_imagePair > .inner,
.b_caption .b_imagePair > .inner,
.b_attribution .b_imagePair > .inner,
.b_imagePair > .inner > .b_footnote,
/* nuke .b_footnote's padding so the .inner and .b_footnote don't double-pad */ .b_poleContent .b_imagePair > .inner {
  padding-bottom: 0;
}
.b_imagePair > .inner {
  float: left;
}
.b_imagePair.reverse > .inner {
  float: right;
}
.b_imagePair .b_imagePair:last-child:after {
  clear: none;
}
.b_algo .b_title .b_imagePair,
.b_ans .b_title .b_imagePair {
  display: block;
}
/* Square - Medium Icon 24 x 24 */

.square_mi {
  width: 24px;
  height: 24px;
  font-size: 24px;
  line-height: 24px;
}
/* End Square - Medium Icon*/

.sb_pag {
  padding: 0;
  margin: 0;
  width: 100%;
}
.sb_pag span {
  margin: 0;
  padding: 0;
  float: left;
  width: 14.24%;
}
.sb_pag a {
  float: left;
  cursor: pointer;
  text-decoration: none;
  padding/*bingcss-ignore: we aren't stacking elements vertically, so top padding should be OK'*/: 5px 11px;
  margin: 0 6px 0 0;
  text-align: center;
  font-size: 16px;
}
a.sb_pagP,
a.sb_pagN {
  padding/*bingcss-ignore: same as above, with a slight change due to us using a sprite sheet for content in place of numbers*/: 5px 8px;
  border: none;
  text-decoration: none;
  font-weight: bold;
  white-space: nowrap;
}
a.sb_pagS {
  background: #ededed;
  border: 1px solid #c8c8c8;
  font-weight: bold;
  color: #333333;
}
a.sb_pagP {
  margin-right: 11px;
  padding-left: 0;
}
</style><script type="text/javascript">//<![CDATA[
///<reference path="..\Declarations\Shared.d.ts" />
///<reference path="..\Declarations\CssClass.d.ts" />
var Animation;
(function (Animation) {
    var toggleClass = "b_hide";
    // this list need to be kept in sync so that all animations are cleared in toggleHide
    var animClasses = ["b_slideListUp", "b_slide", "b_fade", "b_fadeUp"];
    var elementLogMap = {};
    var curElementKey = 0;
    // these variables keep track of vendor-prefixed css/events
    var transitionEndEvent = "transitionend";
    var transformCss = "transform";
    var vendorEndEvents = {
        o: "oTransitionEnd",
        moz: "transitionend",
        webkit: "webkitTransitionEnd"
    };
    function IsElementHidden(ele) {
        return Lib.CssClass.contains(ele, "b_hide") || getComputedStyle(ele, null).display === "none";
    }
    function setVendorTransitionPrefix() {
        if ("transition" in _d.documentElement.style) {
            return;
        }
        for (var prefix in vendorEndEvents) {
            var cssPrefix = "-" + prefix + "-";
            if (cssPrefix + "transition" in _d.documentElement.style) {
                transitionEndEvent = vendorEndEvents[prefix];
            }
        }
    }
    function setVendorCssPrefix() {
        if ("transform" in _d.documentElement.style) {
            return;
        }
        for (var prefix in vendorEndEvents) {
            var prefixedCss = "-" + prefix + "-" + "transform";
            if (prefixedCss in _d.documentElement.style) {
                transformCss = prefixedCss;
            }
        }
    }
    function setVendorPrefix() {
        setVendorTransitionPrefix();
        setVendorCssPrefix();
    }
    function updateLogEnd(htmlElement) {
        if (htmlElement["AnimationKey"]) {
            var logData = elementLogMap[htmlElement["AnimationKey"]];
            logData.endTime = Date.now();
            if (_w["Log2"]) {
                Log2.LogEvent("ClientInst", { "T": "AnimationTiming", "startTime": logData.startTime, "endTime": logData.endTime, "AnimationName": logData.animationName }, null, null, null, null, null, null);
            }
        }
    }
    function updateLogStart(htmlElement, animation) {
        curElementKey += 1;
        htmlElement["AnimationKey"] = curElementKey;
        elementLogMap[curElementKey] = { startTime: Date.now(), endTime: -1, animationName: animation };
    }
    function cascadeListOld(list) {
        if (!list || !list.children || list.children.length == 0) {
            return;
        }
        var startingOffset = _w.innerHeight;
        list.style[transformCss] = "translateY(" + startingOffset + "px)";
        toggleAnimClass(list, "b_slideListUp");
        Lib.CssClass.remove(list, "b_slideListHide");
        list.style[transformCss] = "";
        var lastAnimatedItem = list.children[list.children.length - 1];
        if (lastAnimatedItem) {
            sj_be(lastAnimatedItem, transitionEndEvent, function (evt) {
                if (evt.target === lastAnimatedItem && evt.propertyName === transformCss) {
                    updateLogEnd(list);
                    for (var i = 0; i < list.children.length; i++) {
                        var item = list.children[i];
                        item.style[transformCss] = "";
                    }
                }
            });
            updateLogStart(list, "cascadeListOld");
        }
    }
    Animation.cascadeListOld = cascadeListOld;
    function cascadeList(list) {
        if (!list || !list.children || list.children.length == 0) {
            return;
        }
        var startingOffset = 200;
        list.style[transformCss] = "translateY(" + startingOffset + "px)";
        toggleAnimClass(list, "b_slideListUp");
        Lib.CssClass.remove(list, "b_slideListHide");
        /*
        * This works because when calling list.style the browser will recalculate all styles
        * and the previous change will occur, before we override the value with ""
        */
        list.style[transformCss] = "";
    }
    Animation.cascadeList = cascadeList;
    function toggleSlideTranslate(ele) {
        if (ele) {
            toggleAnimation(ele, "b_slideTranslate", false, [transformCss, transformCss]);
        }
    }
    Animation.toggleSlideTranslate = toggleSlideTranslate;
    function toggleSlide(ele) {
        if (ele) {
            toggleAnimation(ele, "b_slide", true, ["height", "height"]);
        }
    }
    Animation.toggleSlide = toggleSlide;
    function toggleFade(ele) {
        if (ele) {
            toggleAnimation(ele, "b_fade", false, ["opacity", "opacity"]);
        }
    }
    Animation.toggleFade = toggleFade;
    function toggleFadeUp(ele) {
        if (ele) {
            toggleAnimation(ele, "b_fadeUp", false, [transformCss, transformCss]);
        }
    }
    Animation.toggleFadeUp = toggleFadeUp;
    function toggleHide(ele) {
        if (ele) {
            for (var i = 0; i < animClasses.length; i++) {
                Lib.CssClass.remove(ele, animClasses[i]);
            }
            toggleAnimClass(ele, toggleClass);
            sj_evt.fire("transitionDone", ele);
            // instant animation.  Log both events one after the other
            updateLogStart(ele, "Hide");
            updateLogEnd(ele);
        }
    }
    Animation.toggleHide = toggleHide;
    function forceUpdateStyle(ele) {
        // Due to browser optimization of style update, multiple style changes may go at the same time instead of sequentially.  
        // To force update of styles before applying the animation class, a layout property is accessed, which forces the browser
        // to update the style and layouts.
        var tmp = ele.offsetTop;
    }
    function toggleAnimClass(ele, anim) {
        forceUpdateStyle(ele);
        Lib.CssClass.toggle(ele, anim);
    }
    // to animate on the height of an element, the height needs to be explicitly set on the element.
    function setHeight(ele) {
        var height = ele.clientHeight;
        if (height == 0 && Lib.CssClass.contains(ele, toggleClass)) {
            Lib.CssClass.remove(ele, toggleClass);
            height = ele.clientHeight;
            Lib.CssClass.add(ele, toggleClass);
        }
        if (height > 0) {
            ele.style.height = height + "px";
        }
    }
    function transitionEndHandler(evt, ele, lastProperty, anim) {
        if (evt.target != ele) {
            return;
        }
        // send an event to signal that the ele has finished all transitions
        var prop = Lib.CssClass.contains(ele, "b_hide") ? lastProperty[1] : lastProperty[0];
        if (evt.propertyName === prop) {
            updateLogEnd(ele);
            Lib.CssClass.remove(ele, anim);
            if (evt.propertyName === "height") {
                // upon height finishes animating, it should be cleared out.
                ele.style.removeProperty('height');
            }
            sj_ue(ele, transitionEndEvent, transitionEndHandler);
            sj_evt.fire("transitionDone", ele);
        }
    }
    function toggleAnimation(ele, anim, animateHeight, lastProperty) {
        if (animateHeight) {
            setHeight(ele);
        }
        toggleAnimClass(ele, anim);
        toggleAnimClass(ele, toggleClass);
        sj_be(ele, transitionEndEvent, function (evt) {
            transitionEndHandler(evt, ele, lastProperty, anim);
        });
        // log start of animation
        updateLogStart(ele, anim);
    }
    setVendorPrefix();
})(Animation || (Animation = {}));
;///<reference path="..\Declarations\Shared.d.ts" />
var BMPage;
(function (BMPage) {
    var PeekExpandInst;
    (function (PeekExpandInst) {
        function InstrumentPeekExpand(args) {
            var isPeekExpandInline = false;
            if (args && args.length > 1 && args[1] === true) {
                isPeekExpandInline = true;
            }
            var instUrl = "/fd/ls/l?IG=" + _G.IG + '&Type=Event.ClientInst&TS=' + Date.now() + '&DATA={"T":"CI.Cortana.ViewPort","SRC":"OpenPane"' + (isPeekExpandInline ? ',"DVP":' + _w.pageYOffset : '') + ',"VP":' + '"' + _w.innerWidth + "," + _w.innerHeight + '"}';
            var instLayout = new Image();
            instLayout.src = instUrl;
        }
        // wire to PeekExpand for both reactive and pro-active
        sj_evt.bind('peekexpand', InstrumentPeekExpand);
    })(PeekExpandInst || (PeekExpandInst = {}));
})(BMPage || (BMPage = {}));
;
//]]></script><script type="text/javascript">//<![CDATA[
///<reference path="..\..\..\..\Shared\Content\Content\Script\Declarations\Shared.d.ts" />
///<reference path="..\..\..\..\Threshold\src\Content\Script\Declarations\SearchAppWrapper.d.ts" />
var CUDialog;
(function (CUDialog) {
    function sendAction(response) {
        var cuAction;
        if (_d.querySelectorAll(".b_cat3a").length > 0) {
            cuAction = response.Cat3AAction;
        }
        else {
            cuAction = response.Cat3BAction;
        }
        SearchAppWrapper.CortanaApp.sendAction(cuAction);
    }
    CUDialog.sendAction = sendAction;
})(CUDialog || (CUDialog = {}));
;/// <reference path="..\..\..\..\Shared\Content\Content\Script\Declarations\Threshold.Utilities.d.ts" />
/// <reference path="..\..\..\..\Threshold\src\Content\Script\Declarations\CortanaSearch.d.ts" />
/// <reference path="..\..\..\..\Threshold\src\content\script\declarations\SearchAppWrapper.d.ts" />
/// <reference path="Declarations\SPADialogLib.d.ts" />
var DialogSPALib;
(function (DialogSPALib) {
    // global variables per SPA session
    var g_ttsCounter = 15 /* Max */;
    var g_currentUIState = 0 /* Idle */;
    var g_isSpeechInput = false;
    var g_currentWebviewState = 0 /* AppHidden */;
    var g_currentSpeakOperation = null;
    var g_currentLuOperation = null;
    var g_currentEventHandlers = {};
    var g_cuRequestHeaders;
    var g_cortanaApp = SearchAppWrapper.CortanaApp;
    var g_spaDialogRuntime = g_cortanaApp.spaDialogRuntime;
    var g_isDialogTerminated = false;
    var g_requestData = null;
    var g_language = null;
    var g_region = null;
    var g_isRequestFromBand = false;
    var g_sessionId;
    var g_asyncResolutionTurnCount = 0;
    var g_asyncResolutionInProgress = false;
    // Turn 0 input parameters to be cached
    var trumanEndpoint;
    var turn0CuInput;
    var turn0CuOutput;
    var turn0ImpressionId;
    // Per turn variables
    var t_currentImpressionId;
    var t_isRequestSentToSNR;
    var t_taskFrameId;
    // constants   
    var LOG_DIALOGSPA = "DialogSPA";
    var changeSticModeFunctionName = "changeSticStateAndInputMode";
    var spaDialogSjEvtName = "AJAX.sj_evt_startspadialog";
    var dialogSpeechEndpoint = "/DialogPolicy?&isSpeech=1&version=2";
    var dialogTextEndpoint = "/DialogPolicy?&isSpeech=0&version=2";
    sj_be(_w, 'load', initializeSPADialog);
    sj_be(_w, 'click', switchFromVoiceInputToText);
    function switchFromVoiceInputToText() {
        if (g_isSpeechInput) {
            cancelCurrentSpeakOperation();
            cancelCurrentLuOperation();
            updateCortanaUIState(0 /* Idle */, 0 /* None */);
            if (g_spaDialogRuntime.changeSticStateAndInputMode) {
                ThresholdUtilities.wrapSynchronousApiCall(g_spaDialogRuntime, changeSticModeFunctionName, "CSI", null, 1 /* Disabled */, 0 /* Standard */);
            }
            g_isSpeechInput = false;
            g_requestData = setRequestData(turn0CuInput);
            setRequestDataHeader();
        }
    }
    function setRequestDataHeader() {
        if (g_requestData && g_cuRequestHeaders) {
            var cuRequestDataHeaderName = "X-CU-RequestData";
            var headerSet = false;
            for (var i = 0; i < g_cuRequestHeaders.length; i++) {
                if (g_cuRequestHeaders[i][0] == cuRequestDataHeaderName) {
                    g_cuRequestHeaders[i][1] = g_requestData;
                    headerSet = true;
                    break;
                }
            }
            if (!headerSet) {
                g_cuRequestHeaders.push([cuRequestDataHeaderName, g_requestData]);
            }
        }
    }
    // Set requestdata header
    function setRequestData(cuInput) {
        try {
            var json = JSON.parse(cuInput);
            var requestData = JSON.parse("{ \"CUServiceId\": \"\", \"ClientVersion\": \"\", \"ConversationId\": \"\", \"IsNewConversationId\": false, \"SpeechLanguage\": \"\", \"ClientTaskFrame\": null, \"QFClientContextTaskFrame\": null }");
            requestData.ConversationId = json.ConversationId;
            requestData.IsNewConversationId = false;
            return encodeURIComponent(JSON.stringify(requestData));
        }
        catch (err) {
            DialogSPALib.logVerboseTrace("SPADialog: setRequestData", 0 /* Info */, "cuInput:" + cuInput, "cuInput: " + cuInput + ",Json exception: " + err.message, true);
            handoffDialogToCortana(2 /* Error */);
        }
    }
    function initializeSPADialog() {
        // do not use registerEventHandler to register startspadialog & dialogterminated 
        // event, since we do not want it to be removed automatically on each turn
        ThresholdUtilities.wrapSynchronousApiCall(g_spaDialogRuntime, "addEventListener", "AEL", null, "startspadialog", startSpaDialogEventHandler);
        ThresholdUtilities.wrapSynchronousApiCall(g_spaDialogRuntime, "addEventListener", "AEL", null, "dialogterminated", dialogTerminatedEventHandler);
    }
    function startSpaDialogEventHandler(eventArgs) {
        initializeISpaDialogContextValues(eventArgs);
        ThresholdUtilities.wrapSynchronousApiCall(g_spaDialogRuntime, "removeEventListener", "AEL", null, "startspadialog", startSpaDialogEventHandler);
        sj_evt.fire(spaDialogSjEvtName);
    }
    function processResolutionActionsInternal(projectedApis, callBackUrl, taskFrameId, sessionId, locale) {
        if (g_spaDialogRuntime.changeSticStateAndInputMode) {
            ThresholdUtilities.wrapSynchronousApiCall(g_spaDialogRuntime, changeSticModeFunctionName, "CSI", null, 1 /* Disabled */, 0 /* Standard */);
        }
        DialogSPALib.logVerboseTrace("SPADialog: processResolutionActionInternal", 0 /* Info */, "g_currentWebviewState: " + g_currentWebviewState + " currenUIState: " + g_currentUIState + " tf id: " + taskFrameId + " impression id: " + t_currentImpressionId, "callbackUrl: " + callBackUrl + ", cuRequestHeaders" + JSON.stringify(g_cuRequestHeaders));
        updateCortanaUIState(3 /* Thinking */, 9 /* Thinking */);
        ClientResolutionRequested.executeResolutionActions(projectedApis, callBackUrl, taskFrameId, sessionId, t_currentImpressionId, locale, g_cuRequestHeaders);
    }
    function processAsyncResolutionInternal(ssml, emotion, estimatedTimeToComplete) {
        DialogSPALib.logVerboseTrace("SPADialog: processAsyncResolutionInternal", 0 /* Info */, "g_currentWebviewState: " + g_currentWebviewState + " currenUIState: " + g_currentUIState + " timeToComplete: " + estimatedTimeToComplete, "emotion: " + emotion + ", ssml: " + ssml);
        var asyncResolutionTtsComplete = "asyncResolutionTtsComplete";
        if (g_spaDialogRuntime.changeSticStateAndInputMode) {
            ThresholdUtilities.wrapSynchronousApiCall(g_spaDialogRuntime, changeSticModeFunctionName, "CSI", null, 1 /* Disabled */, 0 /* Standard */);
        }
        renderSPAUX(emotion);
        if (g_isSpeechInput && !isStringNullOrEmpty(ssml) && (g_asyncResolutionTurnCount == 1)) {
            updateCortanaUIState(2 /* Speaking */, 0 /* None */);
            g_currentSpeakOperation = ThresholdUtilities.wrapApiCall(g_spaDialogRuntime, "speakAsync", "SA", null, ssml, g_ttsCounter++);
            g_currentSpeakOperation.done(function () {
                g_currentSpeakOperation = null;
                if (g_isDialogTerminated) {
                    return;
                }
                sj_evt.fire(asyncResolutionTtsComplete);
            }, function () {
                handoffDialogToCortana(2 /* Error */);
                g_currentSpeakOperation = null;
                sj_evt.fire(asyncResolutionTtsComplete);
            });
        }
        else {
            sj_evt.fire(asyncResolutionTtsComplete);
        }
        function asyncResolutionTtsCompleteAction() {
            sj_evt.unbind(asyncResolutionTtsComplete, asyncResolutionTtsCompleteAction);
            updateCortanaUIState(0 /* Idle */, 0 /* None */);
            if (!g_isDialogTerminated) {
                // set the UI to thinking state since this is just a status page
                updateCortanaUIState(3 /* Thinking */, 9 /* Thinking */);
                var callbackUrl = (g_isSpeechInput) ? dialogSpeechEndpoint : dialogTextEndpoint;
                // call back into TCP after timeout
                sb_st(function () { return ClientResolutionRequested.sendResolutionResultsToTCP({}, callbackUrl, t_taskFrameId, g_language, g_sessionId, g_cuRequestHeaders, ClientResolutionRequested.TurnTypePrimarySingleTask); }, estimatedTimeToComplete);
            }
        }
        sj_evt.bind(asyncResolutionTtsComplete, asyncResolutionTtsCompleteAction, true);
    }
    function processIntermediateTurnInternal(ssml, postssmlAction, emotion, dictationParam) {
        DialogSPALib.logVerboseTrace("SPADialog: processIntermediateTurnInternal", 0 /* Info */, "g_currentUIState: " + g_currentUIState + "; g_isSpeechInput: " + g_isSpeechInput + "; g_isDialogTerminated: " + g_isDialogTerminated + "; g_isRequestFromBand: " + g_isRequestFromBand, "postSsmlAction: " + postssmlAction + ", cuRequestHeaders" + JSON.stringify(g_cuRequestHeaders));
        if (g_isRequestFromBand) {
            // Multi-turn is not supported for band requests. Just error out.
            handoffDialogToCortana(2 /* Error */);
            return;
        }
        if (g_spaDialogRuntime.changeSticStateAndInputMode) {
            ThresholdUtilities.wrapSynchronousApiCall(g_spaDialogRuntime, changeSticModeFunctionName, "CSI", null, 1 /* Disabled */, (g_isSpeechInput) ? 1 /* ListeningOnly */ : 0 /* Standard */);
        }
        if (!g_isSpeechInput) {
            // for text input, just setup state and exit since the UI controls will determine
            // how to proceed
            updateCortanaUIState(0 /* Idle */, 0 /* None */);
            renderSPAUX(emotion);
            return;
        }
        else {
            var microphoneButtonPressedEventHandler = function (eventArgs) {
                processMicrophoneButtonPressed(dictationParam);
            };
            registerEventHandler("microphonebuttonpressed", microphoneButtonPressedEventHandler);
            renderSPAUX(emotion);
            processSsmlAndAction(ssml, postssmlAction, dictationParam);
        }
    }
    function callProjectedApi(projectedApi, projectedApiMethod, shouldHandoffDialogToCortana) {
        if (!isStringNullOrEmpty(projectedApi)) {
            if (projectedApiMethod == "ClientApiWrapper") {
                var apiContext = {};
                try {
                    apiContext = JSON.parse(projectedApi);
                }
                catch (error) {
                    // Error if the projected API is not in json format.
                    DialogSPALib.logVerboseTrace("ClientResolutionRequested: executeResolutionAction", 0 /* Info */, "projectedApi: " + projectedApi, "JSON.parse EXCEPTION: " + error.message, true);
                    DialogSPALib.handoffDialogToCortana(2 /* Error */);
                }
                ClientApiWrapper.executeApi(apiContext, function (projectedAPIOutput, isSuccess) {
                    if (shouldHandoffDialogToCortana && isSuccess) {
                        handoffDialogToCortana(0 /* RetainUI */);
                    }
                    else if (!isSuccess) {
                        handoffDialogToCortana(2 /* Error */);
                    }
                }, t_currentImpressionId);
            }
            else {
                ThresholdUtilities.wrapApiCall(g_cortanaApp, "processNLCommandAsync", "PNLC", null, projectedApi, t_currentImpressionId).done(function () {
                    if (shouldHandoffDialogToCortana) {
                        handoffDialogToCortana(0 /* RetainUI */);
                    }
                }, function () {
                    if (shouldHandoffDialogToCortana) {
                        handoffDialogToCortana(2 /* Error */);
                    }
                });
            }
        }
    }
    function executeFinalActionInternal(ssml, emotion, secondaryTextSmall, secondaryTextMedium, secondaryTextLarge, projectedApi, projectedApiMethod, dismissAppTimeout) {
        DialogSPALib.logVerboseTrace("SPADialog: executeFinalActionInternal", 0 /* Info */, "g_currentWebviewState: " + g_currentWebviewState + " g_currentUIState: " + g_currentUIState + " isRequestFromBand: " + g_isRequestFromBand, " projectedApi: " + projectedApi + " projectedApiMethod: " + projectedApiMethod + "dismissAppTimeout: " + dismissAppTimeout.toString());
        renderSPAUX(emotion);
        var shouldHandoffDialogToCortana = true;
        if (!isStringNullOrEmpty(ssml) && g_isSpeechInput) {
            if (g_isRequestFromBand) {
                if (g_spaDialogRuntime.sendSsmlToSpeechApp) {
                    ThresholdUtilities.wrapSynchronousApiCall(g_spaDialogRuntime, "sendSsmlToSpeechApp", "SSA", null, ssml, secondaryTextSmall, secondaryTextMedium, secondaryTextLarge, true);
                }
            }
            else {
                shouldHandoffDialogToCortana = false;
                updateCortanaUIState(2 /* Speaking */, 0 /* None */);
                g_currentSpeakOperation = ThresholdUtilities.wrapApiCall(g_spaDialogRuntime, "speakAsync", "SA", null, ssml, g_ttsCounter++);
                var startTime = new Date();
                g_currentSpeakOperation.done(function () {
                    g_currentSpeakOperation = null;
                    if (g_isDialogTerminated) {
                        return;
                    }
                    var endTime = new Date();
                    var elapsedTime = endTime.getTime() - startTime.getTime();
                    var remainingDismissTime = dismissAppTimeout;
                    if (dismissAppTimeout > 0) {
                        // positive dismissAppTimeout specifies the total time to dismiss UI including TTS.
                        // if TTS already took more than dismissAppTimeout, dismiss instantly
                        remainingDismissTime = (dismissAppTimeout > elapsedTime) ? (dismissAppTimeout - elapsedTime) : 0;
                    }
                    if (g_spaDialogRuntime.changeSticStateAndInputMode) {
                        ThresholdUtilities.wrapSynchronousApiCall(g_spaDialogRuntime, changeSticModeFunctionName, "CSI", null, 0 /* Enabled */, 0 /* Standard */);
                    }
                    // if dismiss time is negative, do not dismiss.
                    if (remainingDismissTime == 0) {
                        updateCortanaUIState(0 /* Idle */, 0 /* None */);
                        ThresholdUtilities.wrapSynchronousApiCall(g_cortanaApp, "dismissApp", "DA", null);
                    }
                    else if (remainingDismissTime > 0) {
                        updateCortanaUIState(0 /* Idle */, 0 /* None */);
                        sb_st(function () { return ThresholdUtilities.wrapSynchronousApiCall(g_cortanaApp, "dismissApp", "DA", null); }, remainingDismissTime);
                    }
                    else {
                        handoffDialogToCortana(0 /* RetainUI */);
                    }
                }, function () {
                    handoffDialogToCortana(2 /* Error */);
                    g_currentSpeakOperation = null;
                });
            }
        }
        if (!g_isDialogTerminated) {
            if (!isStringNullOrEmpty(projectedApi)) {
                callProjectedApi(projectedApi, projectedApiMethod, shouldHandoffDialogToCortana);
            }
            else {
                if (shouldHandoffDialogToCortana) {
                    handoffDialogToCortana(0 /* RetainUI */);
                }
            }
        }
    }
    function executeFinalActionInternalMobile(ssml, emotion, secondaryTextSmall, secondaryTextMedium, secondaryTextLarge, projectedApi, projectedApiMethod) {
        var finalActionTtsCompleteMobile = "finalActionTtsCompleteMobile";
        DialogSPALib.logVerboseTrace("SPADialog: executeFinalActionInternalMobile", 0 /* Info */, "g_currentWebviewState: " + g_currentWebviewState + " g_currentUIState: " + g_currentUIState + " g_isRequestFromBand: " + g_isRequestFromBand, "projectedApi: " + projectedApi);
        renderSPAUX(emotion);
        if (!isStringNullOrEmpty(ssml) && g_isSpeechInput) {
            if (g_isRequestFromBand) {
                if (g_spaDialogRuntime.sendSsmlToSpeechApp) {
                    ThresholdUtilities.wrapSynchronousApiCall(g_spaDialogRuntime, "sendSsmlToSpeechApp", "SSA", null, ssml, secondaryTextSmall, secondaryTextMedium, secondaryTextLarge, true);
                }
                sj_evt.fire(finalActionTtsCompleteMobile);
            }
            else {
                updateCortanaUIState(2 /* Speaking */, 0 /* None */);
                g_currentSpeakOperation = ThresholdUtilities.wrapApiCall(g_spaDialogRuntime, "speakAsync", "SA", null, ssml, g_ttsCounter++);
                g_currentSpeakOperation.done(function () {
                    g_currentSpeakOperation = null;
                    if (!g_isDialogTerminated) {
                        if (g_spaDialogRuntime.changeSticStateAndInputMode) {
                            ThresholdUtilities.wrapSynchronousApiCall(g_spaDialogRuntime, changeSticModeFunctionName, "CSI", null, 0 /* Enabled */, 0 /* Standard */);
                        }
                        updateCortanaUIState(0 /* Idle */, 0 /* None */);
                    }
                    sj_evt.fire(finalActionTtsCompleteMobile);
                }, function () {
                    handoffDialogToCortana(2 /* Error */);
                    g_currentSpeakOperation = null;
                    sj_evt.fire(finalActionTtsCompleteMobile);
                });
            }
        }
        else {
            sj_evt.fire(finalActionTtsCompleteMobile);
        }
        function ttsCompleteAction() {
            sj_evt.unbind(finalActionTtsCompleteMobile, ttsCompleteAction);
            if (!g_isDialogTerminated) {
                if (!isStringNullOrEmpty(projectedApi)) {
                    callProjectedApi(projectedApi, projectedApiMethod, true);
                }
                else {
                    handoffDialogToCortana(0 /* RetainUI */);
                }
            }
        }
        sj_evt.bind(finalActionTtsCompleteMobile, ttsCompleteAction, true);
    }
    // Sets emotion, udate cortana webview
    function renderSPAUX(emotion) {
        if (!isStringNullOrEmpty(emotion)) {
            ThresholdUtilities.wrapSynchronousApiCall(g_cortanaApp, "setEmotion", "SE", null, emotion, false, false);
        }
        ThresholdUtilities.wrapApiCall(g_cortanaApp, "showWebViewAsync", "SWW", null);
    }
    // Helper method for validating string
    function isStringNullOrEmpty(inputString) {
        if (inputString != null && inputString != "") {
            return false;
        }
        return true;
    }
    function initializeISpaDialogContextValues(eventArgs) {
        turn0CuInput = eventArgs.cuInput;
        turn0CuOutput = eventArgs.cuOutput;
        trumanEndpoint = eventArgs.snrConnectionUrl;
        turn0ImpressionId = eventArgs.impressionId;
        g_isRequestFromBand = isRequestFromBand(turn0CuInput);
        // this should always be defined, but as a safe practice, assume a default
        g_language = ThresholdUtilities.getUrlParameter(_w.location.href, "setlang");
        if (!g_language) {
            g_language = "en-US";
        }
        // this should always be defined, but as a safe practice, assume a default
        g_region = ThresholdUtilities.getUrlParameter(_w.location.href, "cc");
        if (!g_region) {
            g_region = "US";
        }
        // set the state to thinking the first time dialog is transitioned to SPA
        g_currentUIState = 3 /* Thinking */;
    }
    function isRequestFromBand(cuInput) {
        var requestFromBand = false;
        try {
            var json = JSON.parse(cuInput);
            if (json && json.LocalProperties && (json.LocalProperties.InvocationSourceType != undefined) && (json.LocalProperties.InvocationSourceType == "SpeechApp")) {
                requestFromBand = true;
            }
        }
        catch (err) {
            DialogSPALib.logVerboseTrace("SPADialog: isRequestFromBand", 0 /* Info */, "cuInput:" + cuInput, "Json exception: " + err.message, true);
            handoffDialogToCortana(2 /* Error */);
        }
        return requestFromBand;
    }
    function updateCortanaUIState(uiState, earCon) {
        if (g_currentUIState != uiState) {
            ThresholdUtilities.wrapSynchronousApiCall(g_spaDialogRuntime, "updateGui", "UG", null, uiState);
            g_currentUIState = uiState;
            if (g_isSpeechInput && earCon != 0 /* None */) {
                ThresholdUtilities.wrapApiCall(g_spaDialogRuntime, "playEarconAsync", "PE", null, earCon);
            }
        }
    }
    // Helper method for validating if InputQueryType is speech
    function isSpeechQuery(inputQueryType) {
        if (inputQueryType != undefined && inputQueryType == "SpeechQuery") {
            return true;
        }
        return false;
    }
    // processes current turn ssml and action
    function processSsmlAndAction(ssml, postssmlAction, dictationParam) {
        if (!isStringNullOrEmpty(postssmlAction) && postssmlAction == "waitforuserinput" && g_isSpeechInput) {
            // prompt user for input and start listening
            updateCortanaUIState(2 /* Speaking */, 0 /* None */);
            g_currentSpeakOperation = ThresholdUtilities.wrapApiCall(g_spaDialogRuntime, "speakAsync", "SA", null, ssml, g_ttsCounter++);
            g_currentSpeakOperation.done(function () {
                g_currentSpeakOperation = null;
                if (!g_isDialogTerminated) {
                    updateCortanaUIState(0 /* Idle */, 0 /* None */);
                    processVoiceInput(dictationParam);
                }
            }, function () {
                g_currentSpeakOperation = null;
                handoffDialogToCortana(2 /* Error */);
            });
        }
    }
    function processMicrophoneButtonPressed(dictationParam) {
        if (!g_isSpeechInput) {
            // nothing to do if not speech input
            return;
        }
        if (g_currentSpeakOperation != null && g_currentUIState == 2 /* Speaking */) {
            // if there is a speak operation in progress, cancel it first
            g_currentSpeakOperation.cancel();
            g_currentSpeakOperation = null;
        }
        switch (g_currentUIState) {
            case 1 /* Listening */:
            case 3 /* Thinking */:
                updateCortanaUIState(0 /* Idle */, 7 /* Cancel */);
                break;
            default:
                // create a new impression ID for this turn and process microphone button pressed
                t_currentImpressionId = createCUImpressionId();
                processVoiceInput(dictationParam);
                break;
        }
    }
    function dialogTerminatedEventHandler() {
        g_isDialogTerminated = true;
        cancelCurrentSpeakOperation();
        cancelCurrentLuOperation();
    }
    function cancelCurrentSpeakOperation() {
        if (g_currentSpeakOperation != null) {
            g_currentSpeakOperation.cancel();
            g_currentSpeakOperation = null;
        }
    }
    function cancelCurrentLuOperation() {
        if (g_currentLuOperation != null) {
            g_currentLuOperation.cancel();
            g_currentLuOperation = null;
        }
    }
    // processes all speech events
    function processVoiceInput(dictationParameter) {
        if (!turn0CuInput) {
            handoffDialogToCortana(2 /* Error */);
            return;
        }
        t_isRequestSentToSNR = false;
        var modifiedCuInput = modifyCuInput(turn0CuInput, t_currentImpressionId, dictationParameter);
        if (g_spaDialogRuntime.changeSticStateAndInputMode) {
            // Put the STIC in listening only mode
            ThresholdUtilities.wrapSynchronousApiCall(g_spaDialogRuntime, changeSticModeFunctionName, "CSI", null, 0 /* Enabled */, 1 /* ListeningOnly */);
        }
        // Don't need to play earcon for listening since RAF will play it
        updateCortanaUIState(1 /* Listening */, 0 /* None */);
        g_currentLuOperation = ThresholdUtilities.wrapApiCall(g_spaDialogRuntime, "startLanguageUnderstandingFromVoiceAsync", "SLU", null, modifiedCuInput);
        g_currentLuOperation.then(function onComplete(finalResult) {
            g_currentLuOperation = null;
            if (g_isDialogTerminated) {
                return;
            }
            if (finalResult.notificationType == 3 /* FinalResult */) {
                if (finalResult.finalResultNotification) {
                    var finalSr = finalResult.finalResultNotification;
                    var recoStatus = getRecoResultAndUpdateTrex(finalSr.cuOutput, true);
                    // if the operation is successful, query truman endpoint and go to thinking state
                    // else go to idle state so the user can interact with the microphone
                    if (finalSr.operationHResult == 0 && recoStatus == "200") {
                        updateCortanaUIState(3 /* Thinking */, 9 /* Thinking */);
                        if (!t_isRequestSentToSNR) {
                            // this is hard coded for now we will be updating IDL and start using spa dialog context
                            ClientResolutionRequested.callEndPointGet(getTrumanProxyUrl(), t_currentImpressionId, g_cuRequestHeaders, function (innerHtml) { return ClientResolutionRequested.render(innerHtml); });
                            t_isRequestSentToSNR = true;
                        }
                    }
                    else {
                        updateCortanaUIState(0 /* Idle */, 0 /* None */);
                    }
                }
                else {
                    DialogSPALib.logVerboseTrace("SPADialog: processVoiceInput", 0 /* Info */, "Speech finalResultNotification is null;", "", true);
                }
            }
            else {
                DialogSPALib.logVerboseTrace("SPADialog: processVoiceInput", 0 /* Info */, "onComplete", "NlProgressNotificationType.FinalResult Event not received", true);
            }
        }, function onError(error) {
            DialogSPALib.logVerboseTrace("SPADialog: processVoiceInput", 0 /* Info */, "startLanguageUnderstandingFromVoiceAsync" + "Error: " + error, "", true);
            handoffDialogToCortana(2 /* Error */);
            g_currentLuOperation = null;
        }, function onProgress(progress) {
            switch (progress.notificationType) {
                case 0 /* AudioStarted */:
                    DialogSPALib.logVerboseTrace("SPADialog: processVoiceInput: NlProgressNotificationType", 0 /* Info */, "AudioStarted", "");
                    break;
                case 1 /* CookiesAvailable */:
                    DialogSPALib.logVerboseTrace("SPADialog: processVoiceInput: NlProgressNotificationType", 0 /* Info */, "CookiesAvailable", "");
                    var iterator = progress.cookiesNotification.cookies.first();
                    if (iterator) {
                        var cookieValue;
                        var cookieName = "CUCookie";
                        do {
                            var item = iterator.current;
                            if (item.key.toLowerCase() == cookieName.toLowerCase()) {
                                cookieValue = item.value;
                                break;
                            }
                        } while (iterator.moveNext());
                        DialogSPALib.logVerboseTrace("SPADialog: processVoiceInput: NlProgressNotificationType", 0 /* Info */, "CUCookie set value:" + cookieValue + " sj_cook.get() result: " + sj_cook.get(cookieName), "");
                    }
                    break;
                case 2 /* IntermediateResult */:
                    if (progress.intermediateResultNotification) {
                        if (!t_isRequestSentToSNR) {
                            // this is hard coded for now we will be updating IDL and start using spa dialog context
                            ClientResolutionRequested.callEndPointGet(getTrumanProxyUrl(), t_currentImpressionId, g_cuRequestHeaders, function (innerHtml) { return ClientResolutionRequested.render(innerHtml); });
                            t_isRequestSentToSNR = true;
                        }
                        var intermediate = progress.intermediateResultNotification;
                        getRecoResultAndUpdateTrex(intermediate.cuOutput);
                    }
                    else {
                        DialogSPALib.logVerboseTrace("SPADialog: processVoiceInput", 0 /* Info */, "Speech intermediateResultNotification is null", "", true);
                    }
                    break;
                default:
                    break;
            }
        });
    }
    // get speech recognition result and update trex
    function getRecoResultAndUpdateTrex(cuOutput, isFinal) {
        if (isFinal === void 0) { isFinal = false; }
        var recoStatus = "0";
        if (cuOutput) {
            var cuOutputJson = JSON.parse(cuOutput);
            recoStatus = cuOutputJson.SrObject.RecognitionStatus;
            var phrase = cuOutputJson.SrObject.RecognizedPhrases[0].DisplayText;
            if (phrase != undefined) {
                ThresholdUtilities.wrapSynchronousApiCall(g_spaDialogRuntime, "updateTrex", "UT", null, phrase, isFinal);
            }
        }
        else {
            DialogSPALib.logVerboseTrace("SPADialog: getRecoResultAndUpdateTrex", 0 /* Info */, "cuOutput", "Speech cuOutput output is null isFinal: " + isFinal, true);
        }
        return recoStatus;
    }
    // Set current impression id & dictation param
    function modifyCuInput(cuInput, impressionId, dictationParameter) {
        try {
            var json = JSON.parse(cuInput);
            json.ImpressionId = impressionId;
            if (!json.DictationParameters) {
                var dictationobj = JSON.parse(dictationParameter);
                json.DictationParameters = dictationobj;
            }
            else {
                json.DictationParameters.CompleteTimeout = 1000;
                json.DictationParameters.IncompleteTimeout = 1000;
                json.DictationParameters.InitialSilenceTimeout = 3000;
            }
            if (json.LocalProperties && (json.LocalProperties.InvocationSourceType != undefined)) {
                json.LocalProperties.InvocationSourceType = "SoftwareButton";
            }
            return JSON.stringify(json);
        }
        catch (err) {
            DialogSPALib.logVerboseTrace("SPADialog: modifyCuInput", 0 /* Info */, "cuInput:" + cuInput, "dictationParameter: " + dictationParameter + ", Json exception: " + err.message, true);
            handoffDialogToCortana(2 /* Error */);
        }
    }
    function registerEventHandler(eventName, handler) {
        ThresholdUtilities.wrapSynchronousApiCall(g_spaDialogRuntime, "addEventListener", "AEL", null, eventName, handler);
        g_currentEventHandlers[eventName] = handler;
    }
    function unregisterAllEventHandlers() {
        for (var eventName in g_currentEventHandlers) {
            ThresholdUtilities.wrapSynchronousApiCall(g_spaDialogRuntime, "removeEventListener", "REL", null, eventName, g_currentEventHandlers[eventName]);
        }
        g_currentEventHandlers = {};
    }
    function initializeTurn(inputQueryType, cuRequestHeaders, sessionId, taskFrameId, isAsyncResolutionTurn) {
        if (cuRequestHeaders === void 0) { cuRequestHeaders = null; }
        if (sessionId === void 0) { sessionId = null; }
        if (taskFrameId === void 0) { taskFrameId = null; }
        if (isAsyncResolutionTurn === void 0) { isAsyncResolutionTurn = false; }
        // unregister all event handlers from previous turn
        unregisterAllEventHandlers();
        g_isSpeechInput = isSpeechQuery(inputQueryType);
        g_currentWebviewState = g_cortanaApp.currentState;
        g_cuRequestHeaders = cuRequestHeaders;
        if (isAsyncResolutionTurn) {
            if (g_asyncResolutionInProgress) {
                // async turn already in progress; increment the async resolution count
                g_asyncResolutionTurnCount++;
            }
            else {
                g_asyncResolutionInProgress = true;
                g_asyncResolutionTurnCount = 0;
            }
        }
        else {
            g_asyncResolutionInProgress = false;
            g_asyncResolutionTurnCount = 0;
        }
        if (!g_isSpeechInput) {
            setRequestDataHeader();
        }
        g_sessionId = sessionId;
        t_taskFrameId = taskFrameId;
        t_currentImpressionId = createCUImpressionId();
    }
    function isNumberWithinRange(str, minValue, maxValue) {
        if (!/^\d+$/.test(str)) {
            return false;
        }
        var num = parseInt(str, 10);
        return (!isNaN(num) && (num >= minValue) && (num <= maxValue));
    }
    function createCUImpressionId() {
        return g_cortanaApp.createGuid().replace("{", "").replace("}", "").toLowerCase();
    }
    function getTrumanProxyUrl() {
        return "/speech_render?speech=1&input=2&form=WNSBOX&cc=" + g_region + "&setlang=" + g_language;
    }
    function updateCallBackUrl(callBackUrl) {
        if (!g_isSpeechInput && callBackUrl.indexOf("isSpeech=1") != -1) {
            return callBackUrl.replace("isSpeech=1", "isSpeech=0");
        }
        return callBackUrl;
    }
    // process client resolution action and send data back to DialogPolicy
    function processResolutionActions(projectedApis, callBackUrl, taskFrameId, sessionId, locale, inputQueryType, cuRequestHeaders) {
        function evtAction() {
            try {
                sj_evt.unbind(spaDialogSjEvtName, evtAction);
                initializeTurn(inputQueryType, cuRequestHeaders, sessionId, taskFrameId);
                callBackUrl = updateCallBackUrl(callBackUrl);
                processResolutionActionsInternal(projectedApis, callBackUrl, taskFrameId, sessionId, locale);
            }
            catch (error) {
                DialogSPALib.logVerboseTrace("SPADialog: processResolutionActions", 0 /* Info */, "Session ID: " + sessionId, "Exception: " + error.message + ", inputQueryType: " + inputQueryType, true);
                handoffDialogToCortana(2 /* Error */);
            }
        }
        sj_evt.bind(spaDialogSjEvtName, evtAction, true);
    }
    DialogSPALib.processResolutionActions = processResolutionActions;
    // execute final task action
    function executeFinalAction(ssml, emotion, secondaryTextSmall, secondaryTextMedium, secondaryTextLarge, projectedApi, projectedApiMethod, dismissAppTimeout, inputQueryType) {
        function evtAction() {
            try {
                sj_evt.unbind(spaDialogSjEvtName, evtAction);
                initializeTurn(inputQueryType);
                if (g_cortanaApp.isMobile) {
                    // On mobile we need to wait for TTS before executing projected API.
                    executeFinalActionInternalMobile(ssml, emotion, secondaryTextSmall, secondaryTextMedium, secondaryTextLarge, projectedApi, projectedApiMethod);
                }
                else {
                    executeFinalActionInternal(ssml, emotion, secondaryTextSmall, secondaryTextMedium, secondaryTextLarge, projectedApi, projectedApiMethod, dismissAppTimeout);
                }
            }
            catch (error) {
                DialogSPALib.logVerboseTrace("SPADialog: executeFinalAction", 0 /* Info */, "projectedAPI: " + projectedApi, "Exception: " + error.message + ", inputQueryType: " + inputQueryType, true);
                handoffDialogToCortana(2 /* Error */);
            }
        }
        sj_evt.bind(spaDialogSjEvtName, evtAction, true);
    }
    DialogSPALib.executeFinalAction = executeFinalAction;
    // initializes dialog processing and processes intermediate turns
    function processIntermediateTurn(ssml, postssmlAction, emotion, dictationParam, inputQueryType, cuRequestHeaders, sessionId) {
        function evtAction() {
            try {
                sj_evt.unbind(spaDialogSjEvtName, evtAction);
                initializeTurn(inputQueryType, cuRequestHeaders, sessionId);
                processIntermediateTurnInternal(ssml, postssmlAction, emotion, dictationParam);
            }
            catch (error) {
                DialogSPALib.logVerboseTrace("SPADialog: processIntermediateTurn", 0 /* Info */, "", "Exception: " + error.message + ", inputQueryType: " + inputQueryType + ", postSsmlAction: " + postssmlAction, true);
                handoffDialogToCortana(2 /* Error */);
            }
        }
        sj_evt.bind(spaDialogSjEvtName, evtAction, true);
    }
    DialogSPALib.processIntermediateTurn = processIntermediateTurn;
    function processAsyncResolution(ssml, postssmlAction, emotion, cuRequestHeaders, sessionId, estimatedTimeToComplete, inputQueryType) {
        function evtAction() {
            try {
                sj_evt.unbind(spaDialogSjEvtName, evtAction);
                initializeTurn(inputQueryType, cuRequestHeaders, sessionId, null, true);
                if (g_asyncResolutionTurnCount > 10) {
                    // exceeded max number of retries
                    handoffDialogToCortana(2 /* Error */);
                }
                else {
                    processAsyncResolutionInternal(ssml, emotion, estimatedTimeToComplete);
                }
            }
            catch (error) {
                DialogSPALib.logVerboseTrace("SPADialog: processAsyncResolution", 0 /* Info */, "estimatedTimeToComplete: " + estimatedTimeToComplete, "Exception: " + error.message + ", inputQueryType: " + inputQueryType + ", postSsmlAction: " + postssmlAction, true);
                handoffDialogToCortana(2 /* Error */);
            }
        }
        sj_evt.bind(spaDialogSjEvtName, evtAction, true);
    }
    DialogSPALib.processAsyncResolution = processAsyncResolution;
    // This function passes back confirmation accept as a string 'yes' until there is support
    // in TCP to pass back structured data
    function processConfirmationAccept() {
        switchFromVoiceInputToText();
        updateCortanaUIState(3 /* Thinking */, 9 /* Thinking */);
        var multimodalSlots = {};
        multimodalSlots["intent:confirm"] = encodeURIComponent("true".replace(/\"/g, "\\\""));
        sendMultimodalAction(multimodalSlots);
    }
    DialogSPALib.processConfirmationAccept = processConfirmationAccept;
    // This function passes back confirmation reject as a string 'no' until there is support
    // in TCP to pass back structured data
    function processConfirmationReject() {
        switchFromVoiceInputToText();
        updateCortanaUIState(3 /* Thinking */, 9 /* Thinking */);
        var multimodalSlots = {};
        multimodalSlots["intent:reject"] = encodeURIComponent("true".replace(/\"/g, "\\\""));
        sendMultimodalAction(multimodalSlots);
    }
    DialogSPALib.processConfirmationReject = processConfirmationReject;
    // This function passes back selection index data using "ux:position_ref" slot
    function processSelectionData(selectedIndex) {
        if (selectedIndex) {
            switchFromVoiceInputToText();
            updateCortanaUIState(3 /* Thinking */, 9 /* Thinking */);
            var multimodalSlots = {};
            multimodalSlots["ux:position_ref"] = encodeURIComponent(selectedIndex.replace(/\"/g, "\\\""));
            sendMultimodalAction(multimodalSlots);
        }
        else {
            DialogSPALib.logVerboseTrace("SPADialog: processSelectionData", 0 /* Info */, "SlotName: " + "ux:position_ref", "SlotValue found to be null or whitespace", true);
        }
    }
    DialogSPALib.processSelectionData = processSelectionData;
    // This function passes back all multimodal inputs that are to be passed to TCP
    function processAjaxCalls(multimodalSlots) {
        sendMultimodalAction(multimodalSlots);
    }
    DialogSPALib.processAjaxCalls = processAjaxCalls;
    // this function sends client structured data back to TCP
    // multimodalSlots are IStringMap of slot and value specified by TCP form
    function sendMultimodalAction(multimodalSlots) {
        ClientResolutionRequested.sendResolutionResultsToTCP(multimodalSlots, dialogTextEndpoint, t_taskFrameId, g_language, g_sessionId, g_cuRequestHeaders, ClientResolutionRequested.TurnTypePrimary);
    }
    // This function passes back time duration as a string until there is support from TCP to send
    // structured time data back
    function processTimePickerData(hoursId, minutesId, secondsId) {
        if (!isNumberWithinRange(hoursId.value, 0, 23) || !isNumberWithinRange(minutesId.value, 0, 59) || !isNumberWithinRange(secondsId.value, 0, 59)) {
            // invalid input
            hoursId.value = hoursId.defaultValue;
            minutesId.value = minutesId.defaultValue;
            secondsId.value = secondsId.defaultValue;
            return;
        }
        if ((hoursId.value == hoursId.defaultValue) && (minutesId.value == minutesId.defaultValue) && (secondsId.value == secondsId.defaultValue)) {
            // all 0s input - invalid. Do nothing
            return;
        }
        if (g_isSpeechInput && g_currentLuOperation != null) {
            // cancel the current LU operation
            g_currentLuOperation.cancel();
            g_currentLuOperation = null;
        }
        updateCortanaUIState(3 /* Thinking */, 9 /* Thinking */);
        var json = JSON.parse("{}");
        json.Hours = hoursId.value;
        json.Minutes = minutesId.value;
        json.Seconds = secondsId.value;
        var multimodalSlots = {};
        multimodalSlots["duration_ux"] = encodeURIComponent(JSON.stringify(json).replace(/\"/g, "\\\""));
        sendMultimodalAction(multimodalSlots);
    }
    DialogSPALib.processTimePickerData = processTimePickerData;
    function processHandoff() {
        handoffDialogToCortana(1 /* RelinquishUI */);
    }
    DialogSPALib.processHandoff = processHandoff;
    // remove SPA dialog to RAF
    function handoffDialogToCortana(dialogCompleteState) {
        if (dialogCompleteState == 2 /* Error */) {
            updateCortanaUIState(4 /* Error */, 8 /* Error */);
        }
        else {
            updateCortanaUIState(0 /* Idle */, 0 /* None */);
        }
        if (g_spaDialogRuntime.changeSticStateAndInputMode) {
            ThresholdUtilities.wrapSynchronousApiCall(g_spaDialogRuntime, changeSticModeFunctionName, "CSI", null, 0 /* Enabled */, 0 /* Standard */);
        }
        if (g_currentSpeakOperation != null) {
            g_currentSpeakOperation.cancel();
            g_currentSpeakOperation = null;
        }
        if (g_currentLuOperation != null) {
            g_currentLuOperation.cancel();
            g_currentLuOperation = null;
        }
        ThresholdUtilities.wrapSynchronousApiCall(g_spaDialogRuntime, "updateTrex", "UT", null, "", true);
        ThresholdUtilities.wrapSynchronousApiCall(g_spaDialogRuntime, "dialogComplete", "DC", null, "SPA Dialog completed", dialogCompleteState);
        // unregister all event handlers
        unregisterAllEventHandlers();
    }
    DialogSPALib.handoffDialogToCortana = handoffDialogToCortana;
    function processLaunchUri(launchUri, dismissApp) {
        if (!isStringNullOrEmpty(launchUri)) {
            var projectedApi = "{\"Uri\":\"action://LaunchTaskCompletionUri\",\"LaunchUri\":\"" + launchUri + "\",\"DismissOnComplete\":" + (dismissApp ? "true" : "false") + "}";
            SearchAppWrapper.CortanaApp.processNLCommandAsync(projectedApi, t_currentImpressionId).done(function () {
                handoffDialogToCortana(0 /* RetainUI */);
            }, function () {
                DialogSPALib.logVerboseTrace("SPADialog: processLaunchUri", 0 /* Info */, "LaunchUri: " + launchUri, "Projected API: " + projectedApi, true);
                handoffDialogToCortana(2 /* Error */);
            });
        }
    }
    DialogSPALib.processLaunchUri = processLaunchUri;
    function isSpeakOperationInProgress() {
        return g_currentSpeakOperation != null;
    }
    DialogSPALib.isSpeakOperationInProgress = isSpeakOperationInProgress;
    function logVerboseTrace(eventName, opCode, payloadName, payloadData, isError) {
        if (isError === void 0) { isError = false; }
        if (SPAClientLoggingConfig.IsEnabled) {
            g_cortanaApp.logVerboseTrace(eventName, opCode, payloadName, payloadData, t_currentImpressionId);
        }
        if (isError) {
            SharedLogHelper.LogError(LOG_DIALOGSPA, "eventName: " + eventName + ", payloadName: " + payloadName + ", payloadData: " + payloadData + ", impressionId: " + t_currentImpressionId);
        }
    }
    DialogSPALib.logVerboseTrace = logVerboseTrace;
})(DialogSPALib || (DialogSPALib = {}));
;0;
;///<reference path="..\..\..\..\Shared\Content\Content\Script\Declarations\Shared.d.ts" />
///<reference path="..\..\..\..\Threshold\src\Content\Script\Declarations\SearchAppWrapper.d.ts" />
var ClientResolutionRequested;
(function (ClientResolutionRequested) {
    ClientResolutionRequested.TurnTypePrimary = "Primary";
    ClientResolutionRequested.TurnTypeResolution = "Resolution";
    ClientResolutionRequested.TurnTypePrimarySingleTask = "PrimarySingleTask";
    function executeResolutionActions(projectedApis, callBackUrl, taskFrameId, sessionId, impressionId, locale, cuRequestHeaders) {
        if (projectedApis.length == 0) {
            DialogSPALib.logVerboseTrace("ClientResolutionRequested: no projected API found.", 0 /* Info */, "projectedApi:" + projectedApiContext, "no projected API found.", true);
            DialogSPALib.handoffDialogToCortana(2 /* Error */);
            return;
        }
        var index = 0;
        var resolverName = projectedApis[index][0];
        var projectedApiContext = projectedApis[index][1];
        var results = {};
        var callback = function (response, isSuccess) {
            // if it's success, return response. If failed, return error object in response.
            if (isSuccess) {
                // Original format.
                // {"Uri":"action://SearchLocalMusic","AlbumArtist":"kelly clarkson","MatchedMusicUri":"mswindowsmusic://play?mediaType=artistartistName=Kelly%20Clarkson","Result":0}";
                var formattedResponse = encodeURIComponent(response.replace(/\"/g, "\\\""));
                results[resolverName] = formattedResponse;
                index++;
                if (index < projectedApis.length) {
                    resolverName = projectedApis[index][0];
                    projectedApiContext = projectedApis[index][1];
                    // If there is more API, call it here. As some APIs are async, and some are synchronzed.
                    // So use callback can it simpler. APIs should callback to return value, it supports both async/sync well.
                    executeResolutionAction(resolverName, projectedApiContext, callback, impressionId);
                }
                else {
                    sendResolutionResultsToTCP(results, callBackUrl, taskFrameId, locale, sessionId, cuRequestHeaders, ClientResolutionRequested.TurnTypeResolution);
                }
            }
            else {
                // If any projected API fails, the following APIs won't be called. It post error information to server and returns error message to user.
                DialogSPALib.logVerboseTrace("ClientResolutionRequested: " + resolverName, 0 /* Info */, "projectedApi:" + projectedApiContext, "processNLCommandAsync() failed callbackUrl: " + callBackUrl + ", error: " + response, true);
                DialogSPALib.handoffDialogToCortana(2 /* Error */);
            }
        };
        // init first call
        executeResolutionAction(resolverName, projectedApiContext, callback, impressionId);
    }
    ClientResolutionRequested.executeResolutionActions = executeResolutionActions;
    function executeResolutionAction(resolverName, projectedApiContext, callback, impressionId) {
        // To prevent break existing features, use else block to deal with existing code.
        // If there is ClientApiWrapper in resolver name, it goes to API wrappers.
        // For example, UniqueResolverName:ClientApiWrapper
        var parsedResolverName = resolverName.split(":");
        if (parsedResolverName.length == 2 && parsedResolverName[1] == "ClientApiWrapper") {
            // As limitation of current API, the ProjectedApi parameter put both projected api and passed in data.
            // For example, {"ProjectedApi"="MockProjectedAPINamespace.MockProjectedAPI", "inputParameter1"="mockvalue"}
            var apiContext = {};
            try {
                apiContext = JSON.parse(projectedApiContext);
            }
            catch (error) {
                // prevent the projectedApi is not a json object for some legacy reason.
                DialogSPALib.logVerboseTrace("ClientResolutionRequested: executeResolutionAction", 0 /* Info */, "projectedApi: " + projectedApiContext, "JSON.parse EXCEPTION: " + error.message + ", resolverName: " + resolverName, true);
                DialogSPALib.handoffDialogToCortana(2 /* Error */);
            }
            ClientApiWrapper.executeApi(apiContext, function (projectedAPIOutput, isSuccess) {
                callback(projectedAPIOutput, isSuccess);
            }, impressionId);
        }
        else {
            SearchAppWrapper.CortanaApp.processNLCommandAsync(projectedApiContext, impressionId).done(function (clientResponse) {
                callback(clientResponse, true);
            }, function (error) {
                callback(error, false);
            });
        }
    }
    function sendResolutionResultsToTCP(clientResponse, callBackUrl, taskFrameId, locale, sessionId, cuRequestHeaders, turnType) {
        try {
            ajaxRequestWrapper(callBackUrl, function (url, onComplete) {
                callEndPoint(url, taskFrameId, locale, sessionId, false, clientResponse, cuRequestHeaders, turnType, onComplete);
            }, function (innerHtml) { return render(innerHtml); }, true);
        }
        catch (err) {
            DialogSPALib.logVerboseTrace("ClientResolutionRequested: sendResolutionResultsToTCP", 0 /* Info */, "clientResponse:" + clientResponse, "EXCEPTION: " + err.message + ", callbackUrl: " + callBackUrl, true);
            DialogSPALib.handoffDialogToCortana(2 /* Error */);
        }
    }
    ClientResolutionRequested.sendResolutionResultsToTCP = sendResolutionResultsToTCP;
    function callEndPointGet(url, impressionId, cuRequestHeaders, onSuccess) {
        if (!onSuccess) {
            return;
        }
        ajaxRequestWrapper(url, function (reqUrl, callback) { return CallEndPointGetInternal(reqUrl, impressionId, cuRequestHeaders, callback); }, onSuccess, true);
    }
    ClientResolutionRequested.callEndPointGet = callEndPointGet;
    function validateResponse(response) {
        if (!response || response.indexOf("LaunchSPA") == -1) {
            DialogSPALib.logVerboseTrace("ClientResolutionRequested: LaunchSPA not found in response", 0 /* Info */, "", "ClientResolutionRequested validateResponse() failed", true);
            DialogSPALib.handoffDialogToCortana(2 /* Error */);
            return false;
        }
        return true;
    }
    function CallEndPointGetInternal(url, impressionId, cuRequestHeaders, onSuccess) {
        DialogSPALib.logVerboseTrace("ClientResolutionRequested: CallEndPointGet", 0 /* Info */, "url:" + url, "cuRequestHeaders" + JSON.stringify(cuRequestHeaders));
        var xmlhttp = sj_gx();
        if (_w["CopyTestParameters"] !== undefined) {
            url = _w["CopyTestParameters"](_w.location.href, url);
            if (_w["CopyAndUpdateRequestDataParameter"] !== undefined) {
                url = _w["CopyAndUpdateRequestDataParameter"](url, _w.location.href);
            }
        }
        xmlhttp.open("GET", url, true);
        xmlhttp.timeout = 10000;
        if (cuRequestHeaders) {
            for (var i = 0; i < cuRequestHeaders.length; i++) {
                xmlhttp.setRequestHeader(cuRequestHeaders[i][0], cuRequestHeaders[i][1]);
            }
        }
        var formattedImpressionId = impressionId.replace(/-/g, '');
        xmlhttp.setRequestHeader("X-Search-IG", formattedImpressionId);
        xmlhttp.onreadystatechange = function () {
            if (xmlhttp.readyState == 4) {
                if (xmlhttp.status == 200) {
                    if (validateResponse(xmlhttp.responseText)) {
                        onSuccess(xmlhttp.responseText);
                    }
                }
                else {
                    DialogSPALib.logVerboseTrace("ClientResolutionRequested: CallEndPointGet - HTTP error", 0 /* Info */, "url:" + url + "; http error code: " + xmlhttp.status, "ClientResolutionRequested callEndPointGet() failed", true);
                    DialogSPALib.handoffDialogToCortana(2 /* Error */);
                }
            }
        };
        xmlhttp.onerror = function () {
            DialogSPALib.logVerboseTrace("ClientResolutionRequested: CallEndPointGet", 0 /* Info */, "url:" + url, "ClientResolutionRequested callEndPointGet() failed", true);
            DialogSPALib.handoffDialogToCortana(2 /* Error */);
        };
        xmlhttp.ontimeout = function () {
            DialogSPALib.logVerboseTrace("ClientResolutionRequested: CallEndPointGet", 0 /* Info */, "url:" + url, "ClientResolutionRequested callEndPoint() timed out;", true);
            DialogSPALib.handoffDialogToCortana(2 /* Error */);
        };
        xmlhttp.send();
    }
    function ajaxRequestWrapper(url, makeRequestFunc, onSuccess, shouldAddJsonParameter) {
        if (!onSuccess) {
            return;
        }
        var ajaxProvider = require("ajax.cortanaprovider");
        if (ajaxProvider) {
            ajaxProvider.navigate(url, function (renderUrl, callback, addJsonParamaeters) {
                var requestUrl = shouldAddJsonParameter ? addJsonParamaeters(url) : url;
                var onComplete = function (response) {
                    onSuccess(shouldAddJsonParameter ? "" : response);
                    callback(shouldAddJsonParameter ? response : "", shouldAddJsonParameter);
                };
                makeRequestFunc(requestUrl, onComplete);
            });
        }
        else {
            makeRequestFunc(url, onSuccess);
        }
    }
    function callEndPoint(url, taskFrameId, locale, sessionId, isSpeech, response, cuRequestHeaders, turnType, onSuccess) {
        var xmlhttp = sj_gx();
        if (_w["CopyTestParameters"] !== undefined) {
            url = _w["CopyTestParameters"](_w.location.href, url);
            if (_w["CopyAndUpdateRequestDataParameter"] !== undefined) {
                url = _w["CopyAndUpdateRequestDataParameter"](url, _w.location.href);
            }
        }
        xmlhttp.open("POST", url, true);
        var params = 'clientData=' + JSON.stringify(response);
        params += '&locale=' + locale;
        params += '&sessionId=' + sessionId;
        params += '&taskFrameId=' + taskFrameId;
        params += '&turnType=' + turnType;
        if (cuRequestHeaders) {
            for (var i = 0; i < cuRequestHeaders.length; i++) {
                xmlhttp.setRequestHeader(cuRequestHeaders[i][0], cuRequestHeaders[i][1]);
            }
        }
        xmlhttp.setRequestHeader("X-SPA-SessionId", sessionId);
        xmlhttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
        xmlhttp.timeout = 10000;
        xmlhttp.onreadystatechange = function () {
            if (xmlhttp.readyState == 4) {
                if (xmlhttp.status == 200) {
                    if (validateResponse(xmlhttp.responseText)) {
                        onSuccess(xmlhttp.responseText);
                    }
                }
                else {
                    // request completed with failure error code
                    DialogSPALib.logVerboseTrace("ClientResolutionRequested: callEndPoint - HTTP error", 0 /* Info */, "url:" + url + "; http error code: " + xmlhttp.status, "ClientResolutionRequested callEndPoint() failed isSpeech: " + isSpeech, true);
                    DialogSPALib.handoffDialogToCortana(2 /* Error */);
                }
            }
        };
        xmlhttp.onerror = function () {
            DialogSPALib.logVerboseTrace("ClientResolutionRequested: callEndPoint", 0 /* Info */, "url:" + url, "ClientResolutionRequested callEndPoint() failed isSpeech: " + isSpeech, true);
            DialogSPALib.handoffDialogToCortana(2 /* Error */);
        };
        xmlhttp.ontimeout = function () {
            DialogSPALib.logVerboseTrace("ClientResolutionRequested: callEndPoint", 0 /* Info */, "url:" + url, "ClientResolutionRequested callEndPoint() timed out; isSpeech: " + isSpeech, true);
            DialogSPALib.handoffDialogToCortana(2 /* Error */);
        };
        xmlhttp.send(params);
    }
    function render(innerHtml) {
        if (!innerHtml) {
            return;
        }
        var container = _ge('b_container');
        if (innerHtml == null || innerHtml == "") {
            SharedLogHelper.LogError("LOG_DIALOGSPA", "ClientResolutionRequested: innerHTML is empty");
            DialogSPALib.handoffDialogToCortana(2 /* Error */);
        }
        if (container) {
            container.innerHTML = innerHtml;
        }
        else {
            DialogSPALib.logVerboseTrace("ClientResolutionRequested: render", 0 /* Info */, "render()", "innerHTML b_container not found", true);
            DialogSPALib.handoffDialogToCortana(2 /* Error */);
        }
        insertScriptsIntoDom(container);
    }
    ClientResolutionRequested.render = render;
    // removes existing scripts and insert new ones
    function insertScriptsIntoDom(source) {
        var scripts = source.getElementsByTagName("script");
        for (var i = 0; i < scripts.length; i++) {
            var s = document.createElement("script");
            var sc = scripts[i];
            s.text = sc.text;
            document.body.appendChild(s);
        }
    }
})(ClientResolutionRequested || (ClientResolutionRequested = {}));
;/// <reference path="..\..\..\..\Threshold\src\Content\Script\Declarations\CortanaSearch.d.ts" />
/// <reference path="..\..\..\..\Threshold\src\content\script\declarations\SearchAppWrapper.d.ts" />
// constants   
var LOG_DIALOGSPA = "DialogSPA";
var ClientApiWrapper;
(function (ClientApiWrapper) {
    var impressionId;
    // all wrapped projected API should be listed here.
    var wrappedProjectedAPIs = [
        ["SearchAppWrapper.CortanaApp.searchResultsView.deviceSearch.findAppsAsync", findAppsAsync],
        ["SearchAppWrapper.CortanaApp.searchResultsView.executeSearchAsync", executeSearchAsync],
        ["SearchAppWrapper.CortanaApp.launcher.launchUriAsync", launchUriAsync]
    ];
    // The passed in API name should be exectly match with the actual API.
    // For example, SearchAppWrapper.CortanaApp.searchResultsView.deviceSearch.findAppsAsync
    //
    // The passed in/out data have to be a string. The actual contract is decided by each wrapper.
    // 
    function executeApi(apiContext, callback, impressionIdParameter) {
        var functionObject;
        var projectedApi = apiContext.ProjectedApi;
        impressionId = impressionIdParameter;
        if (projectedApi == undefined) {
            DialogSPALib.logVerboseTrace("ClientApiWrapper: executeApi", 0 /* Info */, "projectedApi", "Couldn't found ProjectedApi parameter", true);
        }
        else {
            // check if API implemented or not
            var isApiFound = false;
            for (var i = 0; i < wrappedProjectedAPIs.length; i++) {
                if (projectedApi == wrappedProjectedAPIs[i][0]) {
                    functionObject = wrappedProjectedAPIs[i][1];
                    isApiFound = true;
                    break;
                }
            }
            if (isApiFound) {
                try {
                    functionObject(apiContext, callback);
                }
                catch (e) {
                    // If any projected API fails, the following APIs won't be called. It post error information to server and returns error message to user.
                    DialogSPALib.logVerboseTrace("ClientApiWrapper: executeApi", 0 /* Info */, "hit error:" + projectedApi, "Error on call API: " + e, true);
                    DialogSPALib.handoffDialogToCortana(2 /* Error */);
                }
            }
            else {
                DialogSPALib.logVerboseTrace("ClientApiWrapper: executeApi", 0 /* Info */, "projectedApi", "The projected API \"" + projectedApi + "\" is not wrapped or case is incorrect.\r\n Implement the wrapper in ClientAPIWrapper.ts\r\n", true);
            }
        }
    }
    ClientApiWrapper.executeApi = executeApi;
    function findAppsAsync(apiContext, callback) {
        // input example:
        // {
        //   "ProjectedApi":"SearchAppWrapper.CortanaApp.searchResultsView.deviceSearch.findAppsAsync",
        //   "AppIds":["1F8B0F94.122165AE053F_j2p0p5q0044a6!App"]
        // }
        //
        // output example (included required fields only)
        // {
        //   "Result":
        //   {
        //     "1F8B0F94.122165AE053F_j2p0p5q0044a6!app":{"exists":true,"displayName":"Photos","packageFamilyName":"122165AE053F_j2p0p5q0044a6"},
        //     "microsoft.bingmaps_8wekyb3d8bbwe!appexmaps":{"exists":false}
        //   }
        // }
        SearchAppWrapper.CortanaApp.searchResultsView.deviceSearch.findAppsAsync(apiContext.AppIds, impressionId).done(function (itemMap) {
            var existenceMap = {};
            apiContext.AppIds.forEach(function (value, index, array) {
                // null is not found, and {} is found.
                if (itemMap[value] != null) {
                    existenceMap[value] = {
                        "exists": true,
                        "displayName": itemMap[value].displayName,
                        "packageFamilyName": itemMap[value].packageFamilyName
                    };
                }
                else {
                    existenceMap[value] = { "exists": false };
                }
            });
            var output = {};
            output.Result = existenceMap;
            callback(JSON.stringify(output), true);
        }, function (error) {
            callback(error, false);
        });
    }
    function executeSearchAsync(apiContext, callback) {
        var unresolvedAppNames = [];
        var resolvedAppNames = [];
        var expandedAppNames = [];
        var currentAppnameIndex = 0;
        var resolveAppName = function (appName) {
            SearchAppWrapper.CortanaApp.searchResultsView.executeSearchAsync(appName).then(function (folders) {
                if (folders && folders.apps) {
                    folders.apps.getItemsAsync(0, 10).then(function (appMap) {
                        if (appMap && appMap.resultSet.length > 0) {
                            resolvedAppNames.push(appName);
                            for (var i in appMap.resultSet) {
                                if (appMap.resultSet[i]) {
                                    expandedAppNames.push(appMap.resultSet[i].displayName);
                                }
                            }
                        }
                        else {
                            unresolvedAppNames.push(appName);
                        }
                        // If all requested app names are processed, call callback function
                        if (currentAppnameIndex === apiContext.UnresolvedAppNames.length - 1) {
                            var res = { Uri: apiContext.Uri, UnresolvedAppNames: unresolvedAppNames, ResolvedAppNames: expandedAppNames, ResolvedApps: resolvedAppNames };
                            callback(JSON.stringify(res), true);
                        }
                        else {
                            currentAppnameIndex++;
                            resolveAppName(apiContext.UnresolvedAppNames[currentAppnameIndex]);
                        }
                    }, function (error) {
                        callback(error, false);
                    });
                }
            }, function (error) {
                callback(error, false);
            });
        };
        resolveAppName(apiContext.UnresolvedAppNames[currentAppnameIndex]);
    }
    function launchUriAsync(apiContext, callback) {
        // input example:
        // {
        //   "ProjectedApi":"SearchAppWrapper.CortanaApp.launcher.launchUriAsync",
        //   "Uri":["ms-cortana://PromptCapabilities?"]
        // }
        var uri = apiContext.Uri;
        SearchAppWrapper.CortanaApp.launcher.launchUriAsync(uri).done(function (itemMap) {
            callback("", true);
        }, function (error) {
            callback(error, false);
        });
    }
})(ClientApiWrapper || (ClientApiWrapper = {}));
;var cuRequestHeaders = [[ "X-BM-Theme", "000000;1ba0e1"], ];DialogSPALib.processIntermediateTurn( "\u003cspeak version=\"1.0\" xmlns=\"http://www.w3.org/2001/10/synthesis\" xmlns:mstts=\"http://www.w3.org/2001/mstts\" xml:lang=\"en-US\"\u003e\u003cmark name=\"TtsService\"/\u003e\u003cmstts:audiosegment data=\"DeV21AAAAABIVAAAVAsAAKcrdPeo7knl4CNwQ6crdPepnKei3r8/pyt096mUM6ea5a2Ppyt094Q2lAWcKt23pyt096mcp6Levz+nLCA4G/nbBvx/fglT5u4vJjG3PCAx0nBN5YBZYyvTnOxgs/uQOSmnoa3F5li6vfPulgob7oSPhLgKh3wyEXZ9rc//mCnbIpiNNbFSPoSLioyrpKtfus1N69+F8HrEruk8/L+MHQgFTgFxkRyfjzaAdgb7WBf6XHuxw6mK0ihNk3pXUXFPmYM1Hu4UfSE6t6TbwnYh+zWw9Ww5cnN9+NCoeOuPcNGB95ieIDGzdvyxMzrWc9mRmLLHo8t3Gw3B8MZA3rGG2M21zWF7hzSANdPJ3NPCBap/dkNLnrBif5rCVYjEsPwMPmRdtKGXHOf+UnSgrN01E5gtxe1Ts8tVMk3dHL9NOsiReCMHN98+YCUrhH+b0ZFrMzAchzm6ttWC1tkRHJ2l7IXHZdEptkHdClmFbKlK2Yp8vQh1VAqd2XQMv5s8ebzKeHRpwE4NamsRBU4HXqlCebCzBqyNNbygIcZ2E8oPC1g0v5PV30ZHpSzLnDmpT8/LzKd6wvOJZmkaIBODZTbl2I329pEU6WsC9v8flv+JE3AO8QZLwPc3JJvE2SamaBtQR5/Ym5rqLag3ntBkllGDVOFgVlgGUtHnGNHnvlTnrwUbnZo4HCDqxG0CZhdw2n38DsjHctdEB1HJ4bMtpbgH/65HjzONUCGLA0xKr8ZNM1agBVkV+iNOoiitwn6Nf4bDY5IGhx7g6282HTRxXy0Vv/gb71Rol0fSKDtT0w4FnKvl9Bw0kuOyyVR/d+HqEXLoqXiTzH+Xo7aU5TpYrmYnKFGR3CgenUtEXkh2swSUt7vxFnnke3XM108K7vT3/qmW97EvlUjSg5w2Hn8EHqA8ZZhFXYpqx7viSqk7ICDf/uksSgKodIk/KYD+z0ABq9VFCxY0n3+cyeIVgiAYm65aUG5oZy/L9RlnLfa6bFg4A/f1yEHcwqs1Qpfh/Lna/MYi2dDKQczY0JD8DEUIJYy4nmifg3Lt/2q70kNLcFgos0plo50gBXBojLVfxpFHdwRaf7v3H7fS0VMaye1MYOxg6dFo4Zu5rPBwI/kQ68IZNA+iAhWKBndF3gZV/7fv9lSQKHApYIN2PgfxHlk4OjwWIL7z6HjufJfBJlAFw/RUsDXBZUFVcde5r1Cdvsuh/somkna5tQKTo6wKTJHQNC9jJO0vGA6owBTlTy5VP+rjt4Yg/52yDK6e9a+3CQXGk2Hml1W9OHFwXL+wYFpEPWBoH8fIQYzX7dfv8yOFQyE6vEe9l+jgmM/IUSz5e9k3nGXLRi406ztKgbcEltCpYjFJgiadlx7KqQ+c7Zyi2rAsEA+vZWhLkDPLmjWaZSAFPZDr92z4/HH5pUykVpgT0h13EigsrA0nyA7U/dVzy/t4AK9OwP+XRZRwIOVwvUcNpvV91daVP5eXyI4ewTY5dJSIDSVejur2rjP2ahI6FjinGqSTclJmaFqjF1m/mPvmalGIkB+q7ETCL0F59sc++PhiZ7MFS4SNOjcMmoy2Od+UQXcjq4GLGh9Ql1r/lU0ZkLhYgnkiTBbcsT4/UQOaFNM830jE1Rtay0xn0DOdCmX7/5Qat1loSkVNOZV/Gxb93dIEGL5RtF7dfbtCNxYKMkc1Nn+nSgY8gjkuRg+RJKR0louKwQHNzE8bfzCyK/H0O+xWEsKnt2A0f3kDdApQHj44/lKXDZSTggYPru9hJQOEAZBSRluTnm7p2Hu9FApFqFl++ra6Oj8LnrANLkpRWGeCa+s388kuaJhav5btbRgCtxYeFSNsd3R6MVl8t/7Gmw9dmn700SKdRLJjb4RJ67C+5ucbohCPoAK9x5mSwVPKo2/1vnREfZHIS6aJ2xpTdlfb0tvkMTIb2FYWGUD15QExOn/PRQ5rBq+UlPk6e3I9R87ghzNNXCJ7DwJyfgWoc7TIGreMP9nXnN2I+XAURYJB3CFAXllGFNuV8Kp95AVbUf2Ksy6jeoJnaqIaoxNNpRsIpbO8CUQ8ztQqiLNhVVl+nq/eIshHWMC24ikpn5Z8hk6R1J1FdlsIskB27jEWIXhFXSLr7EDgQckdGYzOotztxdc5nGy+P85VkekQ8n+Nh8b6Pxy9ebzmb9hPI0oV8Zta/occkY7Lj/W9oytMaDagjUGxKtSbQlXMy2c/jc0sdvfHWb79i84pbBkajS/uxJqRpzCe93UgFryYT+SwUe03pjwNbu85fUNGt48K24clmnqKcs/5nP8BcbjO1ZyaXMIvSB1bNkq+Yv9FpD4XNmfYtFxJuoj/mMUVdk0LZCrI8uMhklFfJBmak4hPz5PQHNgADRa1XsCP9Ncyr1bujmAta0k1UVUWLJiapafll/+Zom0CMSvJZuVWMiQVrE5A4XG4MRxSAFDn0OouLXGLPyHll4EUJ3+ZlaYJojUOZbKSloGBflsAJewgiT9TfoSLE0jVEqSNeQK3m62hwy+a/8Z84TtJQ9A6frrL6CiSw6BoKxVvujHzNwzf7YBZG2HBhgFQLE4Z7Gy21QKsh51eyEJn0auY5Uarq2UaOaHpbNjSjQ2Wof+gUcMUpBdUrDiBwEbcHV5h0OtvQ+lu+eYvm++d+Y8/30aEmI7nN50pIqI91lpoHE9EViN07TzRmKFoL244bWGFHBnepB3DrVoQMTWdtOqnpOV1MrtPDq2aMm5qvF2MMTXJo34SCRYbP73nGrZ8bmXGcehf1oE4TW//m2s77UY2vF1bkF4+ffvaXpxR93EKPWXxah1We1sE4zRRmnKlgJroFK+OGvSXl9cL/+hTeDiIUxcAGlHVcaXGuLtqC2vgzgD3zIRs9ayZDA8POPMBZ/H4XJyqjQpBnlS8PBhFNijBb/BHyWoB/EpLzI/R6zjMPya8LHipMwEJobVd7emOjTOPiZUgtfcx/90yOKZgIui41Phot6umrUm0vGV8PI9ElvjKZcHDYLpcf/EA/4nztr6h9ooTuhBfrymatk0M31VQpQV/CNfg8IIJHnsPQRimnCQTGiGkfWvWh6MGgo1BUNYr4Pnx+khz5X2d177wrg78Q/gU7sQEWypMYTO6bsFfbgUpVzu5y0PoAT3XkdR7rr+bKkJVbXJjnENh9hlexy9jbmWwabl/GRefKnNQkakk+3GXQ6FLu9GXHIvMhl2YYD+W79ioyeYrkvSfXSROTprFoSOajoStpLBLlA4c27HTsSmxXZcTHD9u/OI/lUnj6z1mDemAQlbb9Y+6LmSJBz1i/IYCqpdCxyOk8it8HDiUqNGpf5SGCoTcPlwq/qyfdYQJ621WIMNw8p5eZDsgkNNbYu2JRy+SY0Sh+ohnvIBwb4OBYsV25J6eHOTA127ea4IM1gfx7l+PIEFmoMMTVPyAq5qOtuHMB311A34Zdw3jEoIiTf8/xzA+df+U2n4Z0kYtc3O3YJFDuLX7Xo9D89CxjToLvHs5GxlCAgi0zcIaO1hU4123VHVxtu/ouWPaoB4ETxShtaB0E1eQmsxzN4kOG72I9Uz/izP4aXmRrgpOQrJgpo5z8HlBYc9UUqugboNliN24B1OkIXFrHbNjfhKQcE2oOBhAYKIsdjakFT443Pzkt99zXdTvFq5Js/vofq6vQd5eCKPpdhTI5mufePqxzMlG0di/srcUwUjJwbbWQtQe1qf0K2H4RrYantgiJRQhdOc/BnNu3hWlErq/cex/snEbV2I6xG79dddOgEj+7PyTds0cjH543hob7nfKcWj7A6Qzf7BEIIiCS6YLb3WxxARGj9GUG7M+pJYCFz1ii+7UpRn3M+E6B7pS43+t+KbvM04ADfQmw0evck3y1Gx622YD\"\u003eWhat was your reminder?\u003c/mstts:audiosegment\u003e\u003c/speak\u003e", "waitforuserinput","Sensitive", "{ \"TypeId\" : \"eef2491d-6e30-44b1-962b-7a07c36d654f\", \"Topic\" : \"Short Form\", \"PrecedingContext\" : \"\",\t\"FollowingContext\" : \"\",\"Mode\" : \"OneResponse\",\t\"ApplicationName\" : \"SPA Dialog\", \"ApplicationId\" : \"e58db793-6728-4534-bbc2-726d5a449be8\",\t\"CompleteTimeout\" : 1000,\t\"IncompleteTimeout\" : 1000, \"InitialSilenceTimeout\" : 3000}", "SpeechQuery", cuRequestHeaders, "52173f4c-795f-69c5-10c0-8083187df6ad"); if (SearchAppWrapper.CortanaApp.isAmbientMode) { sb_de.classList.add("CortanaSPA_ambient"); };
//]]></script><div id="b_content"><div id="b_pole"><div class="b_poleContent"><div class="b_ans b_cat3a"><div data-emot="Sensitive" data-emot-size="" data-emot-overridespeaking=""></div><div data-ssml="<speak version=&quot;1.0&quot; xmlns=&quot;http://www.w3.org/2001/10/synthesis&quot; xmlns:mstts=&quot;http://www.w3.org/2001/mstts&quot; xml:lang=&quot;en-US&quot;><mark name=&quot;TtsService&quot;/><mstts:audiosegment data=&quot;DeV21AAAAABIVAAAVAsAAKcrdPeo7knl4CNwQ6crdPepnKei3r8/pyt096mUM6ea5a2Ppyt094Q2lAWcKt23pyt096mcp6Levz+nLCA4G/nbBvx/fglT5u4vJjG3PCAx0nBN5YBZYyvTnOxgs/uQOSmnoa3F5li6vfPulgob7oSPhLgKh3wyEXZ9rc//mCnbIpiNNbFSPoSLioyrpKtfus1N69+F8HrEruk8/L+MHQgFTgFxkRyfjzaAdgb7WBf6XHuxw6mK0ihNk3pXUXFPmYM1Hu4UfSE6t6TbwnYh+zWw9Ww5cnN9+NCoeOuPcNGB95ieIDGzdvyxMzrWc9mRmLLHo8t3Gw3B8MZA3rGG2M21zWF7hzSANdPJ3NPCBap/dkNLnrBif5rCVYjEsPwMPmRdtKGXHOf+UnSgrN01E5gtxe1Ts8tVMk3dHL9NOsiReCMHN98+YCUrhH+b0ZFrMzAchzm6ttWC1tkRHJ2l7IXHZdEptkHdClmFbKlK2Yp8vQh1VAqd2XQMv5s8ebzKeHRpwE4NamsRBU4HXqlCebCzBqyNNbygIcZ2E8oPC1g0v5PV30ZHpSzLnDmpT8/LzKd6wvOJZmkaIBODZTbl2I329pEU6WsC9v8flv+JE3AO8QZLwPc3JJvE2SamaBtQR5/Ym5rqLag3ntBkllGDVOFgVlgGUtHnGNHnvlTnrwUbnZo4HCDqxG0CZhdw2n38DsjHctdEB1HJ4bMtpbgH/65HjzONUCGLA0xKr8ZNM1agBVkV+iNOoiitwn6Nf4bDY5IGhx7g6282HTRxXy0Vv/gb71Rol0fSKDtT0w4FnKvl9Bw0kuOyyVR/d+HqEXLoqXiTzH+Xo7aU5TpYrmYnKFGR3CgenUtEXkh2swSUt7vxFnnke3XM108K7vT3/qmW97EvlUjSg5w2Hn8EHqA8ZZhFXYpqx7viSqk7ICDf/uksSgKodIk/KYD+z0ABq9VFCxY0n3+cyeIVgiAYm65aUG5oZy/L9RlnLfa6bFg4A/f1yEHcwqs1Qpfh/Lna/MYi2dDKQczY0JD8DEUIJYy4nmifg3Lt/2q70kNLcFgos0plo50gBXBojLVfxpFHdwRaf7v3H7fS0VMaye1MYOxg6dFo4Zu5rPBwI/kQ68IZNA+iAhWKBndF3gZV/7fv9lSQKHApYIN2PgfxHlk4OjwWIL7z6HjufJfBJlAFw/RUsDXBZUFVcde5r1Cdvsuh/somkna5tQKTo6wKTJHQNC9jJO0vGA6owBTlTy5VP+rjt4Yg/52yDK6e9a+3CQXGk2Hml1W9OHFwXL+wYFpEPWBoH8fIQYzX7dfv8yOFQyE6vEe9l+jgmM/IUSz5e9k3nGXLRi406ztKgbcEltCpYjFJgiadlx7KqQ+c7Zyi2rAsEA+vZWhLkDPLmjWaZSAFPZDr92z4/HH5pUykVpgT0h13EigsrA0nyA7U/dVzy/t4AK9OwP+XRZRwIOVwvUcNpvV91daVP5eXyI4ewTY5dJSIDSVejur2rjP2ahI6FjinGqSTclJmaFqjF1m/mPvmalGIkB+q7ETCL0F59sc++PhiZ7MFS4SNOjcMmoy2Od+UQXcjq4GLGh9Ql1r/lU0ZkLhYgnkiTBbcsT4/UQOaFNM830jE1Rtay0xn0DOdCmX7/5Qat1loSkVNOZV/Gxb93dIEGL5RtF7dfbtCNxYKMkc1Nn+nSgY8gjkuRg+RJKR0louKwQHNzE8bfzCyK/H0O+xWEsKnt2A0f3kDdApQHj44/lKXDZSTggYPru9hJQOEAZBSRluTnm7p2Hu9FApFqFl++ra6Oj8LnrANLkpRWGeCa+s388kuaJhav5btbRgCtxYeFSNsd3R6MVl8t/7Gmw9dmn700SKdRLJjb4RJ67C+5ucbohCPoAK9x5mSwVPKo2/1vnREfZHIS6aJ2xpTdlfb0tvkMTIb2FYWGUD15QExOn/PRQ5rBq+UlPk6e3I9R87ghzNNXCJ7DwJyfgWoc7TIGreMP9nXnN2I+XAURYJB3CFAXllGFNuV8Kp95AVbUf2Ksy6jeoJnaqIaoxNNpRsIpbO8CUQ8ztQqiLNhVVl+nq/eIshHWMC24ikpn5Z8hk6R1J1FdlsIskB27jEWIXhFXSLr7EDgQckdGYzOotztxdc5nGy+P85VkekQ8n+Nh8b6Pxy9ebzmb9hPI0oV8Zta/occkY7Lj/W9oytMaDagjUGxKtSbQlXMy2c/jc0sdvfHWb79i84pbBkajS/uxJqRpzCe93UgFryYT+SwUe03pjwNbu85fUNGt48K24clmnqKcs/5nP8BcbjO1ZyaXMIvSB1bNkq+Yv9FpD4XNmfYtFxJuoj/mMUVdk0LZCrI8uMhklFfJBmak4hPz5PQHNgADRa1XsCP9Ncyr1bujmAta0k1UVUWLJiapafll/+Zom0CMSvJZuVWMiQVrE5A4XG4MRxSAFDn0OouLXGLPyHll4EUJ3+ZlaYJojUOZbKSloGBflsAJewgiT9TfoSLE0jVEqSNeQK3m62hwy+a/8Z84TtJQ9A6frrL6CiSw6BoKxVvujHzNwzf7YBZG2HBhgFQLE4Z7Gy21QKsh51eyEJn0auY5Uarq2UaOaHpbNjSjQ2Wof+gUcMUpBdUrDiBwEbcHV5h0OtvQ+lu+eYvm++d+Y8/30aEmI7nN50pIqI91lpoHE9EViN07TzRmKFoL244bWGFHBnepB3DrVoQMTWdtOqnpOV1MrtPDq2aMm5qvF2MMTXJo34SCRYbP73nGrZ8bmXGcehf1oE4TW//m2s77UY2vF1bkF4+ffvaXpxR93EKPWXxah1We1sE4zRRmnKlgJroFK+OGvSXl9cL/+hTeDiIUxcAGlHVcaXGuLtqC2vgzgD3zIRs9ayZDA8POPMBZ/H4XJyqjQpBnlS8PBhFNijBb/BHyWoB/EpLzI/R6zjMPya8LHipMwEJobVd7emOjTOPiZUgtfcx/90yOKZgIui41Phot6umrUm0vGV8PI9ElvjKZcHDYLpcf/EA/4nztr6h9ooTuhBfrymatk0M31VQpQV/CNfg8IIJHnsPQRimnCQTGiGkfWvWh6MGgo1BUNYr4Pnx+khz5X2d177wrg78Q/gU7sQEWypMYTO6bsFfbgUpVzu5y0PoAT3XkdR7rr+bKkJVbXJjnENh9hlexy9jbmWwabl/GRefKnNQkakk+3GXQ6FLu9GXHIvMhl2YYD+W79ioyeYrkvSfXSROTprFoSOajoStpLBLlA4c27HTsSmxXZcTHD9u/OI/lUnj6z1mDemAQlbb9Y+6LmSJBz1i/IYCqpdCxyOk8it8HDiUqNGpf5SGCoTcPlwq/qyfdYQJ621WIMNw8p5eZDsgkNNbYu2JRy+SY0Sh+ohnvIBwb4OBYsV25J6eHOTA127ea4IM1gfx7l+PIEFmoMMTVPyAq5qOtuHMB311A34Zdw3jEoIiTf8/xzA+df+U2n4Z0kYtc3O3YJFDuLX7Xo9D89CxjToLvHs5GxlCAgi0zcIaO1hU4123VHVxtu/ouWPaoB4ETxShtaB0E1eQmsxzN4kOG72I9Uz/izP4aXmRrgpOQrJgpo5z8HlBYc9UUqugboNliN24B1OkIXFrHbNjfhKQcE2oOBhAYKIsdjakFT443Pzkt99zXdTvFq5Js/vofq6vQd5eCKPpdhTI5mufePqxzMlG0di/srcUwUjJwbbWQtQe1qf0K2H4RrYantgiJRQhdOc/BnNu3hWlErq/cex/snEbV2I6xG79dddOgEj+7PyTds0cjH543hob7nfKcWj7A6Qzf7BEIIiCS6YLb3WxxARGj9GUG7M+pJYCFz1ii+7UpRn3M+E6B7pS43+t+KbvM04ADfQmw0evck3y1Gx622YD&quot;>What was your reminder?</mstts:audiosegment></speak>" data-postssmlaction="waitforuserinput" data-secondarytext-small="" data-secondarytext-medium="" data-secondarytext-large=""></div><h2 class="b_anno">What was your reminder?</h2><div id="b_thp" class="b_thDark"></div><div id="b_pg_dlyd"></div><div class="b_vPanel b_narrow"><p id="label">Reminder</p><div><span contenteditable="true" id="remindTitle" class="bucket" data-content="Remember to..."></span></div><div><span id="remindDate" class="bucket" data-content="Date"></span></div><div><span id="remindTime" class="bucket" data-content="Time"></span></div></div><div class="standardtext standardcolor experiencedetailsdescription"><p><a id="legacyRecourse" onclick="ReminderClickAction.closeCortana();" _ctf="rdr_T" href="#" h="ID=SERP,5336.1,Reminder">Search "Remind me to "</a></p></div><div class="b_hide" id="CUDialogResponse">{"Uri":"action://CuOutput","SystemAction":{"Uri":"action://Conversation/LaunchSPA","Version":"1.0"},"ConversationId":"52173f4c-795f-69c5-10c0-8083187df6ad","TraceId":"8F51D2F040854E27BAEA1780BD005BDC","ImpressionId":"4aed71533adb72fa437ea2a3e14abcac","LgObject":null}</div></div></div></div><ol id="b_results" role="main" aria-label="Search Results" class="peek"><li class="b_algo b_hide" data-bm="5"><h2><a _h="vMFvrHYLmJG_2bp5HukNbAc_i9ABFik2-JsQjMR9j9E" _v="1" _ctf="rdr_T" href="http://www.laptopmag.com/articles/set-reminder-cortana-windows-10" h="ID=SERP,5111.1">How to <strong>Set a Reminder with Cortana in Windows</strong> 10</a></h2><div class="b_caption"><div class="b_attribution" u="0|5033|4638549123072919|kE2CHxtZc-E9Xk2JI9NzR71le9U2W-q_"><cite><strong>www.laptopmag.com</strong>/articles/<strong>set</strong>-<strong>reminder</strong>-cortana-windows-10</cite><span class="c_tlbxTrg"><span class="c_tlbxH" h="BASE:CACHEDPAGEDEFAULT" k="SERP,5112.1"></span></span></div><p><span class="mb_doct_txt">Mobile-friendly</span>&nbsp;· <span class="news_dt">Jul 17, 2015</span>&nbsp;· Windows 10 and Cortana make it easy to <strong>set a reminder</strong> to aid yourself in remembering the important tasks in your day.</p></div></li><li class="b_algo b_hide" data-bm="6"><h2><a _h="CboBE3zWc1tDevYQuAihn6DLcFBvGDqdNQ_jeP9aQoI" _v="1" _ctf="rdr_T" href="https://support.office.com/en-us/article/set-or-remove-reminders-7a992377-ca93-4ddd-a711-851ef3597925" h="ID=SERP,5126.1"><strong>Set or remove reminders</strong> - Outlook - support.office.com</a></h2><div class="b_caption"><div class="b_attribution" u="1|5034|4561643438342439|NS1lhiMyHVgaZRixMB-XfTV03honLfLI"><cite>https://support.office.com/en-us/article/<strong>set-or-remove-reminders</strong>-7...</cite><span class="c_tlbxTrg"><span class="c_tlbxH" h="BASE:CACHEDPAGEDEFAULT" k="SERP,5127.1"></span></span></div><p><span class="mb_doct_txt">Mobile-friendly</span>&nbsp;· In Microsoft Outlook, you can <strong>set or remove reminders</strong> for different items, such as email messages, appointments, and contacts. Calendar …</p></div></li><li class="b_algo b_hide" data-bm="7"><h2><a _h="5FY_T_v_jQVh8R6iqraQ5pDL6SEWTZhP7QhyNeIZWpI" _v="1" _ctf="rdr_T" href="http://m.windowscentral.com/how-set-reminder-cortana-windows-10" h="ID=SERP,5147.1">How to <strong>set a reminder with Cortana in Windows</strong> 10</a></h2><div class="b_caption"><div class="b_attribution" u="2|5035|4665658948780104|yzEX6bg5lURJsgYHvUEyiAl6PPXjxsbv"><cite>m.windowscentral.com/how-<strong>set</strong>-<strong>reminder</strong>-cortana-windows-10</cite><span class="c_tlbxTrg"><span class="c_tlbxH" h="BASE:CACHEDPAGEDEFAULT" k="SERP,5148.1"></span></span></div><p><span class="mb_doct_txt">Mobile-friendly</span>&nbsp;· <span class="news_dt">Video embedded</span>&nbsp;· One of our favorite features with Cortana in Windows 10 is <strong>setting reminders</strong>. You can ask the personal assistant to <strong>set reminders</strong> …</p></div></li><li class="b_algo b_hide" data-bm="8"><h2><a _h="VpTzb5pRLPlR6ALKzwpqTykVI0tVfyJNZQsQTuOF9Zw" _v="1" _ctf="rdr_T" href="http://www.cnet.com/how-to/set-a-reminder-with-google-now/" h="ID=SERP,5166.1"><strong>Set a reminder with Google Now</strong> - <strong>CNET</strong></a></h2><div class="b_caption"><div class="b_attribution" u="3|5036|4630955633216956|sikSBqiUdnw56lMU6E06HgdEsDq2slb_"><cite class="sb_crmb"><span><strong>www.cnet.com</strong>&nbsp;› </span><span><a _h="cKQKC-gplQUub88VZPDmwHJIP1Podd-YYkbCEqYaG10" _v="1" _ctf="rdr_T" href="http://www.cnet.com/topics/mobile/" h="ID=SERP,5162.1">Mobile</a>&nbsp;› </span><span><a _h="rQOsUs6EdqkKzKW2kQpcBgAA0F-HD4hgzNughkL33uw" _v="1" _ctf="rdr_T" href="http://www.cnet.com/topics/phones/" h="ID=SERP,5163.1">Phones</a></span></cite><span class="c_tlbxTrg"><span class="c_tlbxH" h="BASE:CACHEDPAGEDEFAULT" k="SERP,5167.1"></span></span></div><p><span class="mb_doct_txt">Mobile-friendly</span>&nbsp;· <span class="news_dt">May 17, 2013</span>&nbsp;· <strong>Set a reminder with Google Now</strong>. Here's how to create a location- or time-based <strong>reminder</strong> using Google Now on your Android device.</p></div></li><li class="b_algo b_hide" data-bm="9"><h2><a _h="Kn8lRnJoEojBtGUbl9PnVxccLB3gQqIxnKYUMGbsE9w" _v="1" _ctf="rdr_T" href="https://support.office.com/en-us/article/set-or-remove-reminders-f6e5ff7c-6971-4f58-a073-eda2b91884e9" h="ID=SERP,5181.1"><strong>Set or remove reminders</strong> - Outlook - support.office.com</a></h2><div class="b_caption"><div class="b_attribution" u="4|5037|4589612264653812|4bN0u9n07KUnHVVS2NCocsvAefKj1XFA"><cite>https://support.office.com/en-us/article/<strong>set-or-remove-reminders</strong>-f...</cite><span class="c_tlbxTrg"><span class="c_tlbxH" h="BASE:CACHEDPAGEDEFAULT" k="SERP,5182.1"></span></span></div><p><span class="mb_doct_txt">Mobile-friendly</span>&nbsp;· <strong>Reminders</strong> alert you visually and with sound to Outlook 2007 messages, appointments, meetings, and tasks.</p></div></li><li class="b_algo b_hide" data-bm="10"><h2><a _h="EccV_4mbBJYm7UkPAmkUzL45tXuB7IFnZc8VyYPUPp0" _v="1" _ctf="rdr_T" href="https://tvland.calreply.net/" h="ID=SERP,5194.1"><strong>TV Land</strong></a></h2><div class="b_caption"><div class="b_attribution" u="5|5038|4609905992271365|t0H8QHs5S-swV_2H9zTuqBn_oDoZJlwi"><cite>https://<strong>tvland</strong>.calreply.net</cite><span class="c_tlbxTrg"><span class="c_tlbxH" h="BASE:CACHEDPAGEDEFAULT" k="SERP,5195.1"></span></span></div><p><span class="mb_doct_txt">Mobile-friendly</span>&nbsp;· <strong>SET A REMINDER</strong>. GET A CALENDAR <strong>REMINDER</strong> WE'LL REMIND YOU BEFORE AN EVENT STARTS Close Back to website. Powered ...</p></div></li><li class="b_algo b_hide" data-bm="11"><h2><a _h="ga3UbsvUAS2MLVKuDEumS2WxsuD6jloCGCTuXub5T60" _v="1" _ctf="rdr_T" href="https://get.slack.help/hc/en-us/articles/208423427-Set-a-reminder" h="ID=SERP,5206.1"><strong>Set a reminder</strong> – Slack Help Center</a></h2><div class="b_caption"><div class="b_attribution" u="6|5039|4615772851340605|qq3sRiXeXZUzAvBnNPMDHQb6nkDcubaH"><cite>https://get.slack.help/hc/en-us/articles/208423427</cite><span class="c_tlbxTrg"><span class="c_tlbxH" h="BASE:CACHEDPAGEDEFAULT" k="SERP,5207.1"></span></span></div><p>Busy as a bee, or maybe feeling a little forgetful? 🐝 You can send yourself or your team members <strong>a reminder</strong> for anything: important meetings, to-do items, even ...</p></div></li><li class="b_algo b_hide" data-bm="12"><h2><a _h="hN7UCNZSDKLhRghYY8eUjmbGRZ7yVJbwSJ1WPrKpjds" _v="1" _ctf="rdr_T" href="https://support.google.com/inbox/answer/6062813?hl=en" h="ID=SERP,5222.1"><strong>Reminders</strong> - Inbox by Gmail Help - <strong>Google Support</strong></a></h2><div class="b_caption"><div class="b_attribution" u="7|5040|5034502079905991|mvMYtwki13DxbRDN2TAYjo-TjQdIDPaW"><cite class="sb_crmb"><span><strong>support.google.com</strong>&nbsp;› </span><span><a _h="ScUV_b1levKJp7uZSYFZCsMxakjzCaHFqCUql-kAqcs" _v="1" _ctf="rdr_T" href="https://support.google.com/inbox" h="ID=SERP,5219.1">Inbox by Gmail Help</a></span></cite><span class="c_tlbxTrg"><span class="c_tlbxH" h="BASE:CACHEDPAGEDEFAULT" k="SERP,5223.1"></span></span></div><p><span class="mb_doct_txt">Mobile-friendly</span>&nbsp;· Keep track of everything you need to do in one place. You can add <strong>reminders</strong> for yourself that show up right in your inbox. Your <strong>reminder</strong> will even help you …</p></div></li><li class="b_algo b_hide" data-bm="13"><h2><a _h="tGg__gINM59gCoVJTRTQrve63rdcwvyJQwEltnjWzQY" _v="1" _ctf="rdr_T" href="http://www.alarm.com/blog/set-security-alert-reminder" h="ID=SERP,5237.1"><strong>How to Set an Alarm.com Reminder</strong></a></h2><div class="b_caption"><div class="b_attribution" u="8|5041|4683517420438010|lyfnicl95ktR0SgeDoKgge2N19gZ4h-q"><cite><strong>www.alarm.com</strong>/blog/<strong>set</strong>-security-alert-<strong>reminder</strong></cite><span class="c_tlbxTrg"><span class="c_tlbxH" h="BASE:CACHEDPAGEDEFAULT" k="SERP,5238.1"></span></span></div><p><span class="mb_doct_txt">Mobile-friendly</span>&nbsp;· Did you remember to lock your front door this morning? If you had an <strong>Alarm.com</strong> smart home security <strong>reminder set</strong> up, you'd never worry about it again.</p></div></li><li class="b_algo b_hide" data-bm="14"><h2><a _h="SZsWEDiwLy5tT3a73MFkA3kFhsEvcfiKJyQ3VE_3qnI" _v="1" _ctf="rdr_T" href="https://support.apple.com/en-us/HT205890" h="ID=SERP,5253.1">Use <strong>Reminders</strong> on your iPhone, iPad, or iPod touch - Apple ...</a></h2><div class="b_caption"><div class="b_attribution" u="9|5042|4652550721241491|_4nAMB_wvPRDvCDFh4z546j9IICFRlkw"><cite>https://<strong>support.apple.com</strong>/en-us/HT205890</cite><span class="c_tlbxTrg"><span class="c_tlbxH" h="BASE:CACHEDPAGEDEFAULT" k="SERP,5254.1"></span></span></div><p><span class="mb_doct_txt">Mobile-friendly</span>&nbsp;· <span class="news_dt">Apr 15, 2016</span>&nbsp;· Use <strong>Reminders</strong> for projects, groceries, and anything else that you want to keep track of. You can <strong>set</strong> when and where you want to …</p></div></li><li class="b_ans b_hide" data-bm="15"><div class="b_rs"><h2 class="">Related searches</h2><div class="b_rich"><div class="b_vlist2col"><ul><li><a _ctf="rdr_T" href="/search?q=Set+a+Reminder+with+Cortana&amp;FORM=QSRE1" h="ID=SERP,5299.1"><strong>Set a Reminder</strong> with Cortana</a></li><li><a _ctf="rdr_T" href="/search?q=Set+a+Reminder+in+Windows+10&amp;FORM=QSRE2" h="ID=SERP,5300.1"><strong>Set a Reminder</strong> in Windows 10</a></li><li><a _ctf="rdr_T" href="/search?q=Set+Up+Reminder+on+Computer&amp;FORM=QSRE3" h="ID=SERP,5301.1"><strong>Set</strong> Up <strong>Reminder</strong> on Computer</a></li></ul><ul><li><a _ctf="rdr_T" href="/search?q=Set+Reminders+in+Windows+10+Calendar&amp;FORM=QSRE4" h="ID=SERP,5302.1"><strong>Set Reminders</strong> in Windows 10 Calendar</a></li><li><a _ctf="rdr_T" href="/search?q=How+to+Set+Reminders+on+My+Computer&amp;FORM=QSRE5" h="ID=SERP,5303.1">How to <strong>Set Reminders</strong> on My Computer</a></li><li><a _ctf="rdr_T" href="/search?q=Open+Reminders+in+Windows+10&amp;FORM=QSRE6" h="ID=SERP,5304.1">Open <strong>Reminders</strong> in Windows 10</a></li></ul></div></div></div></li><li class="b_msg" data-bm="16"><a class="recourseLink" _h="AMeRAUYZadDZBIWJWiq0FBfSrLXji0LCXtV9JarWVLw" _v="1" _ctf="rdr_T" href="javascript:sj_evt.fire('peekactivate', true);" h="ID=SERP,5324.1"><span title=""><span class="b_symb b_cortanaMDL2  cipt vatb square_mi"></span><span>See more results in Bing</span></span></a></li><li class="b_pag b_hide" data-bm="17"><div class="sb_pag clrfix"><span><a class="sb_pagS">1</a></span><span><a aria-label="Page 2" _ctf="rdr_T" href="/search?cc=us&amp;setlang=en-us&amp;mkt=en-us&amp;uncrunched=1&amp;addfeaturesnoexpansion=CoARealAsync%2cremindercox&amp;q=Set+a+reminder.&amp;first=11&amp;FORM=PERE" h="ID=SERP,5312.1">2</a></span><span><a aria-label="Page 3" _ctf="rdr_T" href="/search?cc=us&amp;setlang=en-us&amp;mkt=en-us&amp;uncrunched=1&amp;addfeaturesnoexpansion=CoARealAsync%2cremindercox&amp;q=Set+a+reminder.&amp;first=25&amp;FORM=PERE1" h="ID=SERP,5313.1">3</a></span><span><a class="sb_pagN" title="Next page" _ctf="rdr_T" href="/search?cc=us&amp;setlang=en-us&amp;mkt=en-us&amp;uncrunched=1&amp;addfeaturesnoexpansion=CoARealAsync%2cremindercox&amp;q=Set+a+reminder.&amp;first=11&amp;FORM=PORE" h="ID=SERP,5314.1"><div class="sb_pagIconN" role="button"><span class="sw_next">Next</span></div></a></span></div></li></ol></div><footer class="b_footer b_hide peek" role="contentinfo"><div id="CntFtr"><p id="fti3">© 2016 Microsoft</p><ul id="ftrLnks"><li><a _h="Ht63LNVbY85pxWeEayeeKzV1EWnJIoBYMLIckErfNTA" _v="1" _ctf="rdr_T" href="http://go.microsoft.com/fwlink/?LinkId=521839&amp;CLCID=0409" h="ID=SERP,5026.1">New Privacy</a></li><li><a _h="k3xlr7oc-vTiKFzrz9p65YPr64ZrsEOl0xkascdhXlY" _v="1" _ctf="rdr_T" href="http://go.microsoft.com/fwlink/?LinkID=246338&amp;CLCID=0409" h="ID=SERP,5027.1">New Legal</a></li><li><a _h="7go1tZKzu-B1eonBVmtV0NDrMG_0eEIXdKcHOuN13-Q" _v="1" _ctf="rdr_T" href="http://go.microsoft.com/fwlink/?LinkID=286759&amp;CLCID=409" h="ID=SERP,5028.1">Ad info</a></li><div class="clrall"></div></ul></div></footer><script type="text/javascript">//<![CDATA[
(function (_onload, si_PP) {
    onload = function () {
        _G.BPT = new Date();
        if (_onload) {
            _onload();
        }
        if (!_w.sb_ppCPL && si_PP) {
            sb_st(function () {
                si_PP(new Date);
            }, 0);
        }
    };
})(_w.onload, _w.si_PP);
;///<reference path="queue.ts"/>
BM.trigger();
;///<reference path="..\..\..\..\..\Answers\services\Shared\Content\Content\Script\Declarations\Shared.d.ts" />
var Lib;
(function (Lib) {
    var CssClass;
    (function (CssClass) {
        var supportsClassList = typeof (document.body.classList) !== 'undefined';
        function indexOf(elems, elem) {
            if (elem == null || elems == null) {
                throw new TypeError("Null element passed to Lib.CssClass");
            }
            if (elems.indexOf) {
                return elems.indexOf(elem);
            }
            var length = elems.length;
            for (var i = 0; i < length; i++) {
                if (elems[i] === elem) {
                    return i;
                }
            }
            return -1;
        }
        function add(elem, className) {
            if (elem == null) {
                throw new TypeError("Null element passed to Lib.CssClass");
            }
            if (contains(elem, className)) {
                return;
            }
            if (supportsClassList && elem.classList) {
                elem.classList.add(className);
            }
            else {
                elem.className += ' ' + className;
            }
        }
        CssClass.add = add;
        function remove(elem, className) {
            if (elem == null) {
                throw new TypeError("Null element passed to Lib.CssClass");
            }
            if (!contains(elem, className)) {
                return;
            }
            if (supportsClassList && elem.classList) {
                elem.classList.remove(className);
            }
            else {
                var classList = elem.className.split(' ');
                var classId = indexOf(classList, className);
                if (classId >= 0) {
                    classList.splice(classId, 1);
                }
                elem.className = classList.join(' ');
            }
        }
        CssClass.remove = remove;
        function toggle(elem, className) {
            if (elem == null) {
                throw new TypeError("Null element passed to Lib.CssClass");
            }
            if (supportsClassList && elem.classList) {
                elem.classList.toggle(className);
            }
            else {
                if (contains(elem, className)) {
                    remove(elem, className);
                }
                else {
                    add(elem, className);
                }
            }
        }
        CssClass.toggle = toggle;
        function contains(elem, className) {
            if (elem == null) {
                throw new TypeError("Null element passed to Lib.CssClass");
            }
            if (supportsClassList && elem.classList) {
                return elem.classList.contains(className);
            }
            else {
                var classList = elem.className.split(' ');
                return indexOf(classList, className) >= 0;
            }
        }
        CssClass.contains = contains;
    })(CssClass = Lib.CssClass || (Lib.CssClass = {}));
})(Lib || (Lib = {}));
;var keyMap = {
    Content: "b_content",
    SearchForm: "sb_form",
    SBoxId: "sb_form_q",
    Notification: "b_notificationContainer",
    Identity: "id_h",
    Prefix: "b_",
    RmsDefer: "aRmsDefer",
    RmsKeys: ["rms:answers:Shared:BingCore.Bundle", "rms:answers:AjaxSerp:Ajax.Bundle", "rms:answers:BoxModel:Framework"],
    AutoSug: "sa_as",
    IsHP: 0
};
;_w.rms.js({'A:0':0},{'A:rms:answers:BoxModel:Framework':'\/rms\/Framework\/nj\/92342395\/b2d8ec0a.js?bu=rms+answers+BoxModel+config.threshold%2ccore%2ccore%24viewport%2ccore%24layout%2ccore%24metrics%2cmodules%24mutation%2cmodules%24error%2cmodules%24network%2cmodules%24cursor%2cmodules%24keyboard%2cmodules%24bot'},{'A:1':1});;
//]]></script><div id="aRmsDefer"><div style="display:none"><!--//<![CDATA[
/// <reference path="../../../../Shared/Content/Content/script/Declarations/Shared.d.ts"/>
/// <reference path="../../../../Shared/Content/Content/script/Declarations/Threshold.Utilities.d.ts"/>
(function () {
    var kValueExtractionRegex = /ID=(\w+),(\d+(?:\.\d+)*)(&PR=(.*))?/i;
    function sendRequest(linkInfo, el, evt, typeOfClick) {
        if (linkInfo) {
            var gpingData = getGPingData(linkInfo, typeOfClick);
            var clickConfig = _w["ClickConfig"] || {};
            if (_w["Log2"]) {
                Log2.LogEvent(gpingData.eventType, gpingData.data, null, null, null, null, null, null);
                if (_w["ThresholdUtilities"]) {
                    var utilities = _w["ThresholdUtilities"];
                    utilities.uploadApiTimes("PCE");
                }
                if (clickConfig.ForceFlushOnClick || ((typeOfClick === 0) && clickLeavesPage())) {
                    // if we are leaving the page with this click we will flush all relevant logs
                    sj_evt.fire("visibility", document["hidden"]);
                    if (clickConfig.FlushSkipAbort) {
                        Log2.FlushMainQueueDontForce();
                    }
                    else {
                        Log2.ForceFlush();
                    }
                    _w["clickFlushedTime"] = sb_gt();
                }
            }
            else {
                si_t_b(linkInfo);
            }
        }
    }
    var siT = _w["si_T"];
    _w["si_T"] = sendRequest;
    function si_t_b(a) {
        if (siT) {
            siT(a);
        }
        else {
            if (document.images) {
                _G.GPImg = new Image;
                _G.GPImg.src = _G.gpUrl + 'IG=' + _G.IG + (_G.CID ? '&CID=' + _G.CID : '') + '&TS=' + (new Date().getTime()) + a;
            }
        }
    }
    function clickLeavesPage() {
        if (_w.event && _w.event.srcElement) {
            var linkToCheck = _w.event.srcElement;
            while (!linkToCheck.href) {
                if (linkToCheck.parentElement) {
                    linkToCheck = linkToCheck.parentElement;
                }
                else {
                    // we have no further up to go, this means the user didn't click on a link
                    return false;
                }
            }
            if (linkToCheck.href.split("#")[0] !== _d.URL.split("#")[0]) {
                return true;
            }
        }
        return false;
    }
    function getGPingData(linkInfo, typeOfClick) {
        var matches = linkInfo.match(kValueExtractionRegex);
        if (matches) {
            var gpingData = {
                eventType: "Click",
                data: {
                    AppNS: matches[1],
                    K: matches[2],
                    Case: typeOfClick
                }
            };
            if (matches[4]) {
                gpingData.data.Properties = JSON.parse(matches[4]);
            }
            return gpingData;
        }
        throw new Error("hValue passed to click tracking was unable to be parsed: " + linkInfo);
    }
})();
;///<amd-module name="onHTML" />
define("onHTML", ["require", "exports", "event.custom"], function (require, exports, customEvents) {
    customEvents.fire("onHTML");
});
;///<reference path="Declarations\Shared.d.ts"/>
// Prevent zooming via ctrl + mousewheel
sj_be(_d, "mousewheel", function (evt) {
    if (evt.ctrlKey == true) {
        sj_pd(evt);
    }
});
// Prevent zooming via ctrl +/-
sj_be(_d, "keydown", function (evt) {
    if (evt.ctrlKey == true && (evt.keyCode == 107 || evt.keyCode == 109 || evt.keyCode == 187 || evt.keyCode == 189)) {
        sj_pd(evt);
    }
});
;///<reference path="Declarations\Shared.d.ts" />
/*
Instrumentation library for server and client powered apps in Windows smartsearch
Per this design, Server sets the visibility to false (v=0) on all the app links and client sends the Merge update through MergeInstruction format
setting v=1 on link being shown and also sends the Datasource merge event setting correct installstate of the app.
*/
var AppInst;
(function (AppInst) {
    var kValueExtractionRegex = /ID=([\w]+),([\d]+\.[\d]+)/i;
    var kValueNew = 1;
    AppInst.layoutJson = [];
    AppInst.datasourceJson = [];
    (function (InstallState) {
        InstallState[InstallState["Installed"] = 0] = "Installed";
        InstallState[InstallState["NotInstalled"] = 1] = "NotInstalled";
    })(AppInst.InstallState || (AppInst.InstallState = {}));
    var InstallState = AppInst.InstallState;
    // queues for submission or submits the instrumentation log for server powered apps in smartsearch
    function queueServerAppLog(hVisibleLayout, appInfoDsKValue, installState, hideIfNotInstalled, canSubmit) {
        if (canSubmit === void 0) { canSubmit = true; }
        var namespace = "";
        if (hVisibleLayout) {
            var matches = hVisibleLayout.match(kValueExtractionRegex);
            if (matches && matches.length >= 3) {
                // Store the namespace and K value.
                namespace = matches[1];
                var kValue = matches[2];
                if (installState !== 1 /* NotInstalled */ || !hideIfNotInstalled) {
                    AppInst.layoutJson.push({
                        "T": "L.MI",
                        "Action": "Update",
                        "AppNS": namespace,
                        "K": kValue,
                        "V": "1"
                    });
                }
            }
        }
        if (appInfoDsKValue) {
            AppInst.datasourceJson.push({
                "T": "D.MI",
                "Action": "Update",
                "AppNS": namespace,
                "K": appInfoDsKValue,
                "InstallState": getInstallStateString(installState)
            });
        }
        if (canSubmit) {
            submitLog();
        }
    }
    AppInst.queueServerAppLog = queueServerAppLog;
    function getInstallStateString(installState) {
        switch (installState) {
            case 0 /* Installed */:
                return "Installed";
            case 1 /* NotInstalled */:
                return "NotInstalled";
            default:
                return "Unknown";
        }
    }
    function getUniqueId() {
        return kValueNew++;
    }
    AppInst.getUniqueId = getUniqueId;
    // submits the instrumentation log in Merge instruction (MI) format.
    function submitLog() {
        var data = [];
        if (AppInst.layoutJson.length > 0) {
            data.push({
                "Page": AppInst.layoutJson
            });
            AppInst.layoutJson = [];
        }
        if (AppInst.datasourceJson.length > 0) {
            data.push(AppInst.datasourceJson);
            AppInst.datasourceJson = [];
        }
        if (data.length > 0) {
            postLog(JSON.stringify(data));
        }
    }
    AppInst.submitLog = submitLog;
    function postLog(data) {
        if (data) {
            if (_w["Log2"]) {
                Log2.LogEvent("ClientInst", JSON.parse(data), null, null, null, null, null, null);
            }
            else {
                // If ClientInstV2 is not supported
                var time = sb_gt();
                var payload = "<E><T>Event.ClientInst</T><IG>" + _G.IG + "</IG><TS>" + time + "</TS><D>" + data + "</D></E>";
                var xml = "<ClientInstRequest><Events>" + payload + "</Events><STS>" + time + "</STS></ClientInstRequest>";
                var request = sj_gx();
                request.open("POST", "/fd/ls/lsp.aspx", true);
                request.setRequestHeader("Content-Type", "text/xml");
                request.send(xml);
            }
        }
    }
})(AppInst || (AppInst = {}));
;///<reference path="..\Declarations\Shared.d.ts"/>
///<reference path="..\AppInst.ts"/>
// this module is used to initialize the Hose page to have app context sense
var AppApi;
(function (AppApi) {
    // Adds a handler for the specified control name
    function AddControlHandler(controlName, handler) {
        if (!controlHandlers[controlName]) {
            controlHandlers[controlName] = handler;
        }
    }
    AppApi.AddControlHandler = AddControlHandler;
    // The map of handlers for each control type
    var controlHandlers = {};
    // holding a cache of current page apps
    var pageApps = null;
    var instrumentationEnabled = typeof (AppInst) != 'undefined';
    // update app
    function updateApp(app) {
        if (pageApps && app) {
            var elements = pageApps[app.id];
            if (elements) {
                for (var i = 0; i < elements.length; ++i) {
                    updateAppElement(elements[i], app);
                }
            }
        }
    }
    // Invokes the control-specific handler
    function updateAppElement(element, app) {
        var hideIfNotInstalled = Boolean(element.getAttribute("data-hideIfNotInstalled"));
        if (instrumentationEnabled) {
            // Setting canSubmit to 'false' here so that single payload can be submitted later for all the Apps through explicit call to AppInst.SubmitLog function.
            var canSubmit = false;
            var installState = app.installed ? 0 /* Installed */ : 1 /* NotInstalled */;
            AppInst.queueServerAppLog(element.getAttribute("h"), element.getAttribute("data-appInfoDsK"), installState, hideIfNotInstalled, canSubmit);
        }
        var controlName = element.getAttribute("data-controlName");
        if (controlName) {
            var handler = controlHandlers[controlName];
            if (handler) {
                var minVersionStr = element.getAttribute("data-minVersion");
                var additionalPropsStr = element.getAttribute("data-additionalProps");
                var installedVersion = app.installedAppVersion ? stringToVersion(app.installedAppVersion) : null;
                var requiredMinVersion = minVersionStr ? stringToVersion(minVersionStr) : null;
                var eventArgs = {
                    appElement: element,
                    appInfo: app,
                    installedVersion: installedVersion,
                    requiredMinVersion: requiredMinVersion,
                    // if the min version is not specified, no update is needed
                    updateRequired: requiredMinVersion && installedVersion ? compareAppVersions(installedVersion, requiredMinVersion) < 0 : false,
                    updateAvailable: app.updateAvailable,
                    hideIfNotInstalled: hideIfNotInstalled,
                    additionalProps: null
                };
                try {
                    eventArgs.additionalProps = additionalPropsStr ? JSON.parse(additionalPropsStr) : null;
                    handler(eventArgs);
                }
                catch (ex) {
                    // Nothing we can do, really...
                    Log.Log("Error", "AppApi", "Handler_" + controlName, false, "Tx", ex.message);
                }
                if (app.installed && hideIfNotInstalled) {
                    // Show previously hidden apps
                    element.classList.remove('b_hide');
                }
            }
        }
    }
    // Reads the app from current page
    function readApps() {
        // We create the list of apps on first call to UpdateApp
        if (pageApps) {
            return;
        }
        pageApps = {};
        var dataAttr = "data-appid";
        // Scrape the DOM to get all the DOM Elements related to apps
        var appLinks = _d.querySelectorAll("[" + dataAttr + "]");
        for (var i = 0; i < appLinks.length; i++) {
            var appLink = appLinks[i];
            if (appLink) {
                // Get the value of data - appid attribute
                var appId = appLink.getAttribute(dataAttr);
                // If the app id is valid, then add it to the collection
                if (appId) {
                    var appElementList = pageApps[appId];
                    if (appElementList) {
                        // add it to the existing collection
                        appElementList.push(appLink);
                    }
                    else {
                        // create a new list to hold apps
                        pageApps[appId] = [appLink];
                    }
                }
            }
        }
    }
    // Make an element a launch link with proper instrumentation
    function setLaunchLink(targetElement, appElement, appId, launchUrl) {
        targetElement.setAttribute("href", launchUrl);
        // This code sets proper instrumentation attribute on the launch link
        // We cannot have two identical apps within the same DOM element, for example in the same pivot. We can have two
        // identical apps on different pivots, e.g. OpenTable on About and Apps, however they will have different K values
        // so we need to select the correct sibling element which contains the launch K value to use.
        var siblingInstElement = querySelector(appElement.parentElement, "[data-launchappid='" + appId + "']");
        if (siblingInstElement) {
            var hAttr = "h";
            // data-inst will only be present behind FD
            var hValue = siblingInstElement.getAttribute(hAttr);
            if (hValue && hValue.length > 0) {
                targetElement.setAttribute(hAttr, hValue);
            }
        }
    }
    AppApi.setLaunchLink = setLaunchLink;
    function instrumentUpgradeLink(appElement) {
        // If upgrade link is instrumented with it's own InstLink and h value, then set that to be the h value of rendered link.
        // This is currently applicable for Windows app links which use separate link for upgrade state.
        var upgradeLinkElement = querySelector(appElement.parentElement, "[data-linkRole='Upgrade']");
        if (upgradeLinkElement) {
            var hUpgradeLink = upgradeLinkElement.getAttribute("h");
            if (hUpgradeLink) {
                appElement.setAttribute("h", hUpgradeLink);
            }
        }
    }
    AppApi.instrumentUpgradeLink = instrumentUpgradeLink;
    // Shell will call this method to update app info with app list
    // This function name and its namespace can't be changed.
    function UpdateAppInfo(apps) {
        if (apps) {
            // This will only read the app element list once, caching it for all subsequent calls
            readApps();
            for (var i = 0; i < apps.length; ++i) {
                updateApp(apps[i]);
            }
        }
        // At this point, we have enqueued the logs for all the app links through AppInst.queueServerAppLog function calls.
        // For perf reasons, we submit them all at once in single payload through the following function call.
        if (instrumentationEnabled) {
            AppInst.submitLog();
        }
    }
    AppApi.UpdateAppInfo = UpdateAppInfo;
    function stringToVersion(versionStr) {
        return versionStr.split('.').map(function (s) { return Number(s); });
    }
    // Version comparison function
    function compareAppVersions(version1, version2) {
        var commonLength = Math.min(version1.length, version2.length);
        for (var i = 0; i < commonLength; i++) {
            var diff = version1[i] - version2[i];
            if (diff != 0) {
                return diff;
            }
        }
        // The longer version number is considered greater
        return version1.length - version2.length;
    }
    function querySelector(element, query) {
        return element.querySelector(query);
    }
})(AppApi || (AppApi = {}));
;// ------------------------------------------------------------------------------
// <copyright file="SmartSearch.Navigation.ts" company="Microsoft Corporation">
//     Copyright (c) Microsoft Corporation. All Rights Reserved.
//     Information Contained Herein is Proprietary and Confidential.
// </copyright>
// ------------------------------------------------------------------------------
///<reference path="..\..\..\..\Shared\Content\Content\script\Declarations\Shared.d.ts"/>
///<reference path="..\..\..\..\Shared\Content\Content\Script\Declarations\Threshold.Utilities.d.ts" />
///<reference path="SearchApp.Mock.ts" />
///<reference path="Declarations\CortanaEnums.d.ts" />
var CachedDeviceItems = {};
var SmartSearch;
(function (SmartSearch) {
    var cortanaApp = SearchAppWrapper.CortanaApp;
    var _supportedPaths = null;
    var baseProtocol = null;
    var baseHostname = null;
    var launchApiAllowedLatency = 100;
    var bingToken = "bing";
    var apiNameAbbreviator = /(^.)|([A-Z])/g;
    function isSupportedPath(path, search) {
        var supportedPathsCollection = getSupportedPaths();
        path = cleanPath(path);
        // Cut off the leading ? in the search parameters
        if (search && search.substring) {
            search = search.substring(1);
        }
        // A path is supported if it's not blocked and there is a supported path for it
        // Check block lists first as they should be shorter
        return (!isPathSatisfied(supportedPathsCollection.Blocked, path, search) && isPathSatisfied(supportedPathsCollection.Supported, path, search));
    }
    SmartSearch.isSupportedPath = isSupportedPath;
    /// Called by test code to reset cached state between tests
    function reset() {
        _supportedPaths = null;
    }
    SmartSearch.reset = reset;
    function cleanPath(path) {
        var cleanPath = path;
        if (cleanPath) {
            var cleanPath = cleanPath.toLowerCase();
            var cutIndex = -1;
            for (var i = 0; i < cleanPath.length && cleanPath[i] === "/"; i++) {
                cutIndex = i;
            }
            if (cutIndex >= 0) {
                cleanPath = cleanPath.substring(cutIndex + 1);
            }
        }
        return cleanPath;
    }
    function getSupportedPaths() {
        if (!_supportedPaths) {
            var thresholdConfig = _TC;
            if (thresholdConfig) {
                var supportedPaths = null;
                var blockedPaths = null;
                if (thresholdConfig.SP) {
                    supportedPaths = parsePathList(thresholdConfig.SP);
                }
                if (thresholdConfig.BP) {
                    blockedPaths = parsePathList(thresholdConfig.BP);
                }
                _supportedPaths = { Supported: supportedPaths, Blocked: blockedPaths };
            }
        }
        return _supportedPaths;
    }
    function isPathSatisfied(supportedPathsMap, path, search) {
        for (var i in supportedPathsMap) {
            if (path.indexOf(i) >= 0) {
                var requiredParameters = supportedPathsMap[i];
                var allParametersPresent = true;
                // Check if this path requires specific querystring parameters
                if (requiredParameters.length > 0) {
                    // If we require some parameters we assume we don't have them until we succeed with parsing
                    allParametersPresent = false;
                    if (search) {
                        var parsedPathParameters = cleanArray(search.split("&"));
                        // If we require some parameters and have parameters in the input path then we assume we've got what we need until we find a parameter is missing
                        allParametersPresent = parsedPathParameters.length >= requiredParameters.length;
                        if (allParametersPresent) {
                            for (var requiredParameterIndex in requiredParameters) {
                                if (parsedPathParameters.indexOf(requiredParameters[requiredParameterIndex]) < 0) {
                                    // We've failed to find a required parameter, so we know this is not a match
                                    allParametersPresent = false;
                                    break;
                                }
                            }
                        }
                    }
                }
                // We found all required parameters or there were no required parameters.  This is a match.
                if (allParametersPresent) {
                    return true;
                }
            }
        }
        return false;
    }
    function parsePathList(supportedPaths) {
        var parsedPaths = {};
        supportedPaths = supportedPaths.toLowerCase();
        var supportedFullPaths = supportedPaths.split(",");
        var defaultRequiredQueryStrings = [];
        for (var supportedFullPathIndex in supportedFullPaths) {
            var pathAndQuery = cleanArray(supportedFullPaths[supportedFullPathIndex].split("?"));
            var requiredQueryStrings = defaultRequiredQueryStrings;
            if (pathAndQuery.length > 1) {
                requiredQueryStrings = cleanArray(pathAndQuery[1].split("&"));
            }
            parsedPaths[cleanPath(pathAndQuery[0])] = requiredQueryStrings;
        }
        return parsedPaths;
    }
    function cleanArray(inputArray) {
        var returnValue = inputArray;
        if (inputArray) {
            var startIndex = 0;
            var foundItemToClean = false;
            for (var i = startIndex; i < inputArray.length; i++) {
                if (!inputArray[i]) {
                    if (!foundItemToClean) {
                        returnValue = [];
                        foundItemToClean = true;
                    }
                    if (i > startIndex) {
                        returnValue.push.apply(returnValue, inputArray.slice(startIndex, i));
                    }
                    startIndex = i + 1;
                }
            }
        }
        return returnValue;
    }
    function signalComplete() {
        sj_evt.fire("NavigationComplete");
    }
    function navigateTo(targetElement, event) {
        var preventDefault = true;
        // Check if target element link is internal or external
        if (targetElement) {
            var searchUtils = ThresholdUtilities;
            var destinationPath = targetElement.pathname;
            var destinationHostname = getHostname(targetElement);
            var destinationProtocol = targetElement.protocol;
            var destinationSearch = targetElement.search;
            var destinationHash = targetElement.hash;
            if (!baseHostname || !baseProtocol) {
                getBaseUrl();
            }
            var destinationLink = targetElement.href;
            // If the link is really a javascript invocation (like "javascript:void(0)"), bail out.
            if (destinationProtocol.toLowerCase() === "javascript:") {
                return;
            }
            if (!destinationHostname) {
                destinationHostname = baseHostname; // automatically accquire current domain for relative links
            }
            // If both hosts contain bing, or neither host contains bing we'll treat them as potentially equivalent and force evaluation of all other properties.
            var destinationHostIsBing = destinationHostname && destinationHostname.toLowerCase().indexOf(bingToken) >= 0;
            var currentHostname = getHostname(_w.location);
            var currentHostIsBing = currentHostname && currentHostname.toLowerCase().indexOf(bingToken) >= 0;
            // We also respect protocol because http://www.bing.com is not the same page as https://www.bing.com (potentially different cookies and page content).
            if (destinationHostIsBing === currentHostIsBing && destinationProtocol.toLowerCase() === _w.location.protocol.toLowerCase() && destinationPath.toLowerCase() === _w.location.pathname.toLowerCase() && destinationSearch.toLowerCase() === _w.location.search.toLowerCase() && destinationHash.toLowerCase() === _w.location.hash.toLowerCase()) {
                SharedLogHelper.LogWarning("SelfNavigate");
            }
            else if (destinationLink) {
                // Determine if a link is relative.
                // Handle a weird case where the url is ms-windows-store:PDP?PFN=..., no host, and "ms-windows-store:" protocol
                var isRelative = (!destinationProtocol || destinationProtocol.indexOf("http") === 0) && (destinationHostname === baseHostname || destinationHostname === getHostname(location));
                var urlType = getUrlType(destinationPath, destinationSearch, destinationHostname, isRelative);
                var launcher = cortanaApp.launcher;
                switch (urlType) {
                    case 5 /* Search */:
                    case 3 /* Navigation */:
                        if (isRelative) {
                            rebaseLink(targetElement);
                            // Need to refresh after changing the link properties
                            destinationLink = targetElement.href;
                        }
                        if (urlType === 5 /* Search */) {
                            // Force Cat3b (search)
                            var joiningChar = destinationLink.indexOf("?") === -1 ? "?" : "&";
                            destinationLink += joiningChar + "persona=0";
                        }
                        var navigateWebViewFunctionName = "navigateWebViewAsync";
                        var launchWebContentFunctionName = "launchWebContent";
                        var thresholdConfig = _TC;
                        if (thresholdConfig && thresholdConfig.NW && launcher[launchWebContentFunctionName]) {
                            var launchOptions = launcher.createWebContentLaunchOptions();
                            launchOptions.uri = destinationLink;
                            searchUtils.wrapSynchronousApiCall(launcher, launchWebContentFunctionName, createInstrumentationKey(launchWebContentFunctionName), null, launchOptions);
                            signalComplete();
                        }
                        else if (cortanaApp[navigateWebViewFunctionName]) {
                            searchUtils.wrapApiCallWithTimeout(cortanaApp, navigateWebViewFunctionName, createInstrumentationKey(navigateWebViewFunctionName), destinationLink, launchApiAllowedLatency, null, destinationLink).done(signalComplete);
                        }
                        else {
                            // We're in charge of the actual navigation
                            preventDefault = false;
                        }
                        break;
                    case 0 /* App */:
                        var options = null;
                        var appContext = targetElement.getAttribute("data-appcontext");
                        if (appContext) {
                            options = launcher.createAppLaunchOptions();
                            options.appContext = appContext;
                        }
                        var itemId = targetElement.getAttribute("data-appid");
                        if (itemId) {
                            var itemSource = targetElement.getAttribute("data-source");
                            var deviceItem = CachedDeviceItems[itemId + ":" + itemSource];
                            if (deviceItem) {
                                var launchSearchItemAsyncPromise;
                                var functionName = "launchSearchItemAsync";
                                if (options) {
                                    launchSearchItemAsyncPromise = searchUtils.wrapApiCallWithTimeout(launcher, functionName, createInstrumentationKey(functionName), deviceItem.id, launchApiAllowedLatency, null, deviceItem, options);
                                }
                                else {
                                    launchSearchItemAsyncPromise = searchUtils.wrapApiCallWithTimeout(launcher, functionName, createInstrumentationKey(functionName), deviceItem.id, launchApiAllowedLatency, null, deviceItem);
                                }
                                launchSearchItemAsyncPromise.done(signalComplete);
                            }
                            else {
                                var itemType = targetElement.getAttribute("data-itemtype");
                                var functionName = itemType && itemType === "settings" ? "findSettingsAsync" : "findAppsAsync";
                                searchUtils.wrapApiCallWithTimeout(cortanaApp.searchResultsView.deviceSearch, functionName, createInstrumentationKey(functionName), "Navigation", launchApiAllowedLatency, null, [itemId]).then(sj_df(launchFirstFoundItem, options));
                            }
                        }
                        break;
                    case 4 /* Experience */:
                        var experienceName = targetElement.getAttribute("data-experiencename");
                        if (experienceName) {
                            SearchAppWrapper.CortanaApp.launchExperienceByName(experienceName, null);
                        }
                        break;
                    case 2 /* Explore */:
                        var destination = targetElement.getAttribute("data-dest");
                        if (destination) {
                            launcher.launchSearchInApp(destination, ThresholdUtilities.getDecodedQuery(_w.location.toString()));
                            signalComplete();
                        }
                        break;
                    case 1 /* Web */:
                        if (isRelative) {
                            rebaseLink(targetElement);
                            // Need to refresh after changing the link properties
                            destinationLink = targetElement.href;
                            // Instrument the time of the click to allow us to join the impressions. These requests are from two
                            // different apps, so will be seen as 2 different users, making it difficult to measure e2e perf from
                            // app click to browser page load without this query param.
                            var joiningChar = destinationLink.indexOf("?") === -1 ? "?" : "&";
                            destinationLink += joiningChar + "ts=" + sb_gt();
                            if (_G.nclid) {
                                destinationLink += "&nclid=" + _G.nclid;
                            }
                        }
                        var functionName = "launchUriAsync";
                        searchUtils.wrapApiCallWithTimeout(launcher, functionName, createInstrumentationKey(functionName), "Navigation", launchApiAllowedLatency, null, destinationLink).then(signalComplete);
                        break;
                }
            }
        }
        if (event && preventDefault) {
            event.preventDefault();
        }
    }
    ;
    function createInstrumentationKey(apiName) {
        return apiName.match(apiNameAbbreviator).join("").toUpperCase();
    }
    function launchFirstFoundItem(result, options) {
        if (result != null) {
            for (var i in result) {
                var currentResult = result[i];
                // This check seems unecessary, but the mapping returned maps IDs to empty objects when it fails to find it on the machine.
                if (currentResult && currentResult.id) {
                    var functionName = "launchSearchItemAsync";
                    ThresholdUtilities.wrapApiCallWithTimeout(SearchAppWrapper.CortanaApp.launcher, functionName, createInstrumentationKey(functionName), null, launchApiAllowedLatency, null, currentResult, options).then(signalComplete);
                    break;
                }
            }
        }
    }
    function getUrlType(destinationPath, destinationSearch, destinationHostname, isRelative) {
        if (isRelative && isSupportedPath(destinationPath, destinationSearch)) {
            // This is a requery on search
            if (destinationPath === "search" || destinationPath === "/search") {
                return 5 /* Search */;
            }
            // This is a navigation link to another bing page
            return 3 /* Navigation */;
        }
        else if (destinationHostname === "ms-smartsearch") {
            if (destinationPath === "app" || destinationPath === "/app") {
                return 0 /* App */;
            }
            else if (destinationPath === "searchInApp" || destinationPath === "/searchInApp") {
                return 2 /* Explore */;
            }
            else if (destinationPath === "experience" || destinationPath === "/experience") {
                return 4 /* Experience */;
            }
        }
        // Any other links should be launched in browser.
        return 1 /* Web */;
    }
    ;
    function onClickHandler(evt) {
        if (!evt.defaultPrevented) {
            var element = evt.target;
            var targetElement = getParentContainer(element, "A");
            if (targetElement) {
                navigateTo(targetElement, evt);
            }
        }
    }
    ;
    function getParentContainer(target, tagName) {
        for (; target && target !== document; target = target.parentNode) {
            if (target.tagName === tagName) {
                return target;
            }
        }
    }
    ;
    function getBaseUrl() {
        if (_w["_TH_BU"]) {
            var baseUrlPieces = _TH_BU.split("//", 2);
            if (baseUrlPieces.length === 2) {
                baseProtocol = baseUrlPieces[0];
                baseHostname = baseUrlPieces[1];
                return;
            }
        }
        baseProtocol = location.protocol;
        baseHostname = getHostname(location);
    }
    function rebaseLink(element) {
        element.protocol = baseProtocol;
        element.hostname = baseHostname;
        element.port = baseProtocol === "https:" ? "443" : "80";
    }
    function getHostname(element) {
        if (!element) {
            return null;
        }
        var hostname = element.hostname;
        if (!hostname) {
            return null;
        }
        // Microsoft Edge drops the [ ] for IPv6 urls, and we cannot actually navigate to IPv6 hosts without them.
        // Add them if they're missing.
        if (hostname.indexOf(":") >= 0 && hostname.indexOf("[") < 0) {
            hostname = "[" + hostname + "]";
        }
        return hostname;
    }
    sj_be(_w, "click", onClickHandler);
    var UrlType;
    (function (UrlType) {
        UrlType[UrlType["App"] = 0] = "App";
        UrlType[UrlType["Web"] = 1] = "Web";
        UrlType[UrlType["Explore"] = 2] = "Explore";
        UrlType[UrlType["Navigation"] = 3] = "Navigation";
        UrlType[UrlType["Experience"] = 4] = "Experience";
        UrlType[UrlType["Search"] = 5] = "Search";
    })(UrlType || (UrlType = {}));
})(SmartSearch || (SmartSearch = {}));
;// ------------------------------------------------------------------------------
// <copyright file="SmartSearch.ts" company="Microsoft Corporation">
//     Copyright (c) Microsoft Corporation. All Rights Reserved.
//     Information Contained Herein is Proprietary and Confidential.
// </copyright>
// ------------------------------------------------------------------------------
///<reference path="..\..\..\..\Shared\Content\Content\script\Declarations\AppApi.d.ts"/>
///<reference path="..\..\..\..\Shared\Content\Content\script\Declarations\Shared.d.ts"/>
///<reference path="..\..\..\..\Shared\Content\Content\Script\Declarations\Threshold.Utilities.d.ts" />
///<reference path="SmartSearch.Navigation.ts"/>
///<reference path="SearchApp.Mock.ts"/>
(function () {
    var appIdAttribute = "data-appid";
    if (typeof AppApi === "undefined" || !AppApi.UpdateAppInfo || !SearchAppWrapper.CortanaApp || !SearchAppWrapper.CortanaApp.searchResultsView) {
        return;
    }
    // Get app ids
    var appIds = [];
    var appLinks = document.querySelectorAll("[" + appIdAttribute + "]");
    for (var i = 0; i < appLinks.length; i++) {
        var appId = appLinks[i].getAttribute(appIdAttribute);
        if (appIds.indexOf(appId) < 0) {
            appIds.push(appId);
        }
    }
    var processApplicationMap = function (results) {
        var apps = [];
        for (var index in appIds) {
            var appId = appIds[index];
            if (results.hasKey(appId)) {
                var item = results[appId];
                if (item) {
                    var app = {
                        id: appId,
                        installedAppVersion: item.version,
                        installed: true
                    };
                    apps.push(app);
                    if (CachedDeviceItems && !CachedDeviceItems[appId]) {
                        CachedDeviceItems[appId] = item;
                    }
                }
            }
        }
        AppApi.UpdateAppInfo(apps);
        ThresholdUtilities.uploadApiTimes("ALR");
    };
    // Check the app install state and update app info, only if we have some apps to check
    if (appIds.length > 0) {
        ThresholdUtilities.wrapApiCall(SearchAppWrapper.CortanaApp.searchResultsView.deviceSearch, "findAppsAsync", "AL", "AppLinking", appIds).then(processApplicationMap);
    }
})();
;///<reference path="..\..\..\answers\services\Shared\Content\Content\script\Declarations\Shared.d.ts"/>
// Sets a persistent cookie crumb with javascsript observations.  The browser's inner width and height, the device pixel ratio, and the UTC offset.
(function () {
    var clientCookie = "SRCHHPGUSR";
    function setHeightAndWidthCrumbs() {
        var cwCookie = sj_cook.get(clientCookie, "CW");
        if (!cwCookie || (window["sj_b"] && cwCookie != sj_b.clientWidth)) {
            sj_cook.set(clientCookie, "CW", (sb_de.clientWidth || sj_b.clientWidth).toString(), true, "/", null);
        }
        var chCookie = sj_cook.get(clientCookie, "CH");
        var clientHeight = sb_de.clientHeight.toString();
        if (!chCookie || chCookie !== clientHeight) {
            sj_cook.set(clientCookie, "CH", clientHeight, true, "/", null);
        }
    }
    function setClientCookieDataOnLoad() {
        var dprCookie = sj_cook.get(clientCookie, "DPR");
        var dpr = _w["devicePixelRatio"];
        if (dpr && (!dprCookie || parseInt(dprCookie) !== dpr)) {
            sj_cook.set(clientCookie, "DPR", dpr.toString(), true, "/", null);
        }
        var utcCookie = sj_cook.get(clientCookie, "UTC");
        var utcOffset = (new Date().getTimezoneOffset() * -1).toString();
        if (utcCookie == null || utcCookie !== utcOffset) {
            sj_cook.set(clientCookie, "UTC", utcOffset, true, "/", null);
        }
    }
    function setClientCookie() {
        setHeightAndWidthCrumbs();
        setClientCookieDataOnLoad();
    }
    sj_be(_w, "load", setClientCookie);
    sj_be(_w, "resize", setHeightAndWidthCrumbs);
})();
;/// <reference path="..\..\..\..\Shared\Content\Content\Script\Declarations\Shared.d.ts" />
/// <reference path='..\..\..\..\Shared\Content\Content\Script\Declarations\Threshold.Utilities.d.ts' />
/// <reference path="..\..\..\..\Threshold\src\Content\Script\Declarations\SearchAppWrapper.d.ts" />
/*This is a hack and temporary fix. TFS 5405929 tracks its removal as soon as LG issue is fixed for entity carousel from the backend.
invocation of "respond" API is necessary from the Cortana client perspective as it requres this API for removal of thinking canvas.
So this change is to unblock mobile2cortana flight while the right fix is being worked upon from backend side. */
(function () {
    if (SearchAppWrapper && SearchAppWrapper.CortanaApp) {
        var cat3AAnswer = _d.querySelector(".b_cat3a");
        var languageGenerationElement = cat3AAnswer && cat3AAnswer.querySelector("div[data-ssml]");
        if (languageGenerationElement) {
            ThresholdUtilities.wrapSynchronousApiCall(SearchAppWrapper.CortanaApp, "respond", null, "respond", languageGenerationElement.getAttribute("data-ssml"), languageGenerationElement.getAttribute("data-postssmlaction"), languageGenerationElement.getAttribute("data-secondarytext-small"), languageGenerationElement.getAttribute("data-secondarytext-medium"), languageGenerationElement.getAttribute("data-secondarytext-large"));
        }
        else {
            var emptySpaceString = " ";
            ThresholdUtilities.wrapSynchronousApiCall(SearchAppWrapper.CortanaApp, "respond", null, "respond", emptySpaceString, emptySpaceString, emptySpaceString, emptySpaceString, emptySpaceString);
        }
        var emotionElement = cat3AAnswer && cat3AAnswer.querySelector("div[data-emot]");
        if (emotionElement) {
            ThresholdUtilities.wrapSynchronousApiCall(SearchAppWrapper.CortanaApp, "setEmotion", null, "setEmotion", emotionElement.getAttribute("data-emot"), emotionElement.getAttribute("data-emot-size") === "large", emotionElement.hasAttribute("data-emot-overridespeaking"));
        }
    }
})();
;///<reference path="..\Declarations\Shared.d.ts" />
// Please don't change this module name - it's part of Cortana spec
var BMPage;
(function (BMPage) {
    function UpdateUserDisplayName(name) {
        if (!name) {
            return;
        }
        var userNameContainers = _d.querySelectorAll("[data-userDisplayName]");
        for (var i = 0; i < userNameContainers.length; i++) {
            var userNameContainer = userNameContainers[i];
            userNameContainer.innerText = name;
        }
    }
    BMPage.UpdateUserDisplayName = UpdateUserDisplayName;
})(BMPage || (BMPage = {}));
;CUDialog.sendAction({"Cat3AAction":"{\"Uri\":\"action://CuOutput\",\"SystemAction\":{\"Uri\":\"action://Conversation/LaunchSPA\",\"Version\":\"1.0\"},\"ConversationId\":\"52173f4c-795f-69c5-10c0-8083187df6ad\",\"TraceId\":\"8F51D2F040854E27BAEA1780BD005BDC\",\"ImpressionId\":\"4aed71533adb72fa437ea2a3e14abcac\",\"LgObject\":null}","Cat3BAction":""});;/// <reference path='..\..\..\..\Shared\Content\Content\Script\Declarations\Threshold.Utilities.d.ts' />
var ThemablePage;
(function (ThemablePage) {
    // Find the themable page indicator and apply theme classname(s) to body element.
    // We do this in script because the body element already rendered in the first chunk before we found out we needed a different theme in the second chunk.
    var themeIndicator = _ge("b_thp");
    if (themeIndicator) {
        sb_de.classList.add("b_theme");
        var themeClasses = themeIndicator.classList;
        for (var additionalClass = 0; additionalClass < themeClasses.length; additionalClass++) {
            sb_de.classList.add(themeClasses[additionalClass]);
        }
    }
})(ThemablePage || (ThemablePage = {}));
;var SPAClientLoggingConfig = {};
;define("ajax.shared", ["require", "exports"], function (require, exports) {
    ///<reference path="..\ajax.keymap.d.ts"/>
    ///<reference path="..\..\..\..\..\Shared\Content\Content\Script\Declarations\Shared.d.ts"/>
    function getPlaceholder(key) {
        var placeholderKey = keyMap[key] ? keyMap[key] : keyMap.Prefix + key;
        var placeholder = document.getElementById(placeholderKey);
        if (!placeholder && document.getElementsByClassName) {
            var holderClass = document.getElementsByClassName(placeholderKey);
            placeholder = holderClass && holderClass.length ? holderClass[0] : null;
        }
        return placeholder;
    }
    exports.getPlaceholder = getPlaceholder;
    function getRelativeUrl(url) {
        var a = sj_ce('a');
        a.href = url;
        var allowedPath = a.pathname;
        if (allowedPath[0] !== '/') {
            allowedPath = "/" + allowedPath;
        }
        var relativeUrl = "";
        if (allowedPath === "/") {
            relativeUrl = allowedPath;
        }
        else {
            var index = url.indexOf(allowedPath);
            relativeUrl = index > -1 ? url.substr(index) : "";
        }
        return relativeUrl;
    }
    exports.getRelativeUrl = getRelativeUrl;
    function getParentContainer(target, tagName, tag) {
        for (; target && target !== document; target = target.parentNode) {
            if (target[tagName] === tag) {
                return target;
            }
            if (target === undefined) {
                break;
            }
        }
    }
    exports.getParentContainer = getParentContainer;
    ;
});
;///<amd-module name="ajax.render" />
define("ajax.render", ["require", "exports", "ajax.shared"], function (require, exports, ajaxShared) {
    var dom = require("dom");
    var customEvents = require("event.custom");
    var queue = [];
    var isScriptDownloading = false;
    var pendingStyleBackup = true;
    customEvents.bind("ajax.unload", function () { return pendingStyleBackup = true; });
    function renderJson(json, renderItem) {
        for (var key in json) {
            if (key === "Script") {
                for (var i = 0; i < json[key].length; i++) {
                    queueForRendering(key, json[key][i], renderItem);
                }
            }
            else {
                queueForRendering(key, json[key], renderItem);
            }
        }
    }
    exports.renderJson = renderJson;
    function queueForRendering(key, value, render) {
        if (!isScriptDownloading) {
            checkAndRender(key, value, render);
        }
        else {
            queue.push({ k: key, v: value, r: render });
        }
    }
    function checkAndRender(key, value, render) {
        // Do default rendering action if render function does not exist or render function
        // explicitly asks to invoke the default action.
        if (!render || render(key, value)) {
            renderItem(key, value);
        }
    }
    function backupStyles() {
        if (pendingStyleBackup) {
            var backupCssHolder = dom.getCssHolder();
            backupCssHolder.id = "ajaxStylesBackup";
            var cssHolder = dom.getCssHolder();
            var backupCssHolderSibling = backupCssHolder.nextSibling;
            if (backupCssHolderSibling) {
                backupCssHolder.parentNode.insertBefore(cssHolder, backupCssHolderSibling);
            }
            pendingStyleBackup = false;
        }
    }
    function cleanupStyles() {
        var backupCssHolder = document.getElementById("ajaxStylesBackup");
        if (backupCssHolder)
            backupCssHolder.parentNode.removeChild(backupCssHolder);
    }
    function renderItem(key, value) {
        switch (key) {
            case "Script":
                appendScripts(value);
                break;
            case "Style":
                backupStyles();
                dom.getCssHolder().innerHTML += '<div></div>' + value;
                break;
            case "IG":
                _G.IG = value;
                break;
            case "PageName":
                _G.PN = value;
                break;
            case "Title":
                document.title = value;
                break;
            case "HBop":
                var div = document.createElement("div");
                document.getElementById(keyMap.Content).appendChild(div);
                div.outerHTML = value;
                break;
            case "RmsDefer":
                var rmsContainer = ajaxShared.getPlaceholder(key);
                if (!rmsContainer) {
                    rmsContainer = document.createElement("div");
                    document.body.appendChild(rmsContainer);
                }
                rmsContainer.outerHTML = value;
                break;
            case "Content":
                appendContent(key, value);
                break;
            case "EOS":
                cleanupStyles();
                break;
            case "EOC":
                if (value === "1") {
                    customEvents.fire("ajax.firstChunkEnd");
                }
                break;
            default:
                appendContent(key, value);
        }
    }
    function appendContent(key, value) {
        var placeholder = ajaxShared.getPlaceholder(key);
        if (placeholder) {
            if (typeof value === "string") {
                placeholder.outerHTML = value;
            }
            else {
                placeholder.parentNode.replaceChild(value, placeholder);
            }
        }
    }
    function appendScripts(script) {
        var value = script;
        if (value["Method"] === "reference") {
            fetchReferenceScript(value["Content"]);
        }
        else {
            dom.includeScript(value["Content"]);
        }
    }
    function continueRender() {
        while (queue.length) {
            if (isScriptDownloading) {
                break;
            }
            var obj = queue.shift();
            checkAndRender(obj.k, obj.v, obj.r);
        }
    }
    function fetchReferenceScript(url) {
        isScriptDownloading = true;
        var request = new XMLHttpRequest();
        var timeoutHandler;
        request.open("get", url, true);
        request.onreadystatechange = function () {
            if (request.readyState === 4) {
                if (timeoutHandler !== null) {
                    clearTimeout(timeoutHandler);
                }
                if (request.status === 200) {
                    dom.includeScript(request.responseText);
                }
                isScriptDownloading = false;
                continueRender();
            }
        };
        request.send();
        timeoutHandler = setTimeout(function () {
            request.abort();
            isScriptDownloading = false;
            continueRender();
        }, 10000);
    }
});
;///<amd-module name="ajax.providers" />
///<reference path="..\Declarations\ajax.d.ts"/>
define("ajax.providers", ["require", "exports"], function (require, exports) {
    var providers = [];
    function registerProvider(responseCreator) {
        if (!responseCreator.sanitizeUrl) {
            responseCreator.sanitizeUrl = dummySanitizeUrl;
        }
        providers.push(responseCreator);
    }
    exports.registerProvider = registerProvider;
    function getAjaxController(url, origin, elem) {
        var length = providers.length;
        for (var i = 0; i < length; i++) {
            var responseCreator = providers[i];
            if (responseCreator.shouldAjax(url, origin, elem)) {
                return responseCreator;
            }
        }
        return null;
    }
    exports.getAjaxController = getAjaxController;
    function dummySanitizeUrl(url) {
        return url;
    }
});
;///<amd-module name="ajax.lifeCycle" />
///<reference path="..\ajax.keymap.d.ts"/>
///<reference path="..\Declarations\ajax.d.ts"/>
define("ajax.lifeCycle", ["require", "exports", "ajax.shared", "ajax.history", "ajax.providers", "ajax.render"], function (require, exports, ajaxShared, history, ajaxProviders, ajaxRender) {
    var dom = require("dom");
    var env = require("env");
    var cookies = require("cookies");
    var nativeEvents = require("event.native");
    var customEvents = require("event.custom");
    var hasOnPPFired = false;
    var rms = require("rmsajax");
    var shared = require("shared");
    var jsNamespaceBlacklist = ["Bnp", "RMS_IACL", "sched", "TP", "bepns", "Identity", "initComCtrl", "ccal", "ccal_bundle", "expitem", "si_sendCReq"];
    var divClassNameBlackList = ["bubblePlaceholder", "irhc", "vrhc"];
    var _undefined;
    var lastRenderedOrigin = 1 /* Click */;
    var lastRenderedUrl = ajaxShared.getRelativeUrl(window.location.href);
    var pendingRequestUrls = [];
    // Value to check if autosuggest is turned on.
    var autoSuggest;
    // For checking if query has at least one non whitespace character
    var queryRegex = /\S/;
    // For removing sid, format and jsoncbid parameters
    var urlRegex = /(&|%26)sid(=|%3d)\w+(&|%26)format(=|%3d)jsonv2(&|%26)jsoncbid(=|%3d)\d+/gm;
    function init() {
        autoSuggest = cookies.get("SRCHHPGUSR", "AS");
        wireup();
        customEvents.bind("ajax.state", handleHistoryChange);
        // Disabling escape key for ajax scenario
        nativeEvents.bind(document, "keydown", function (evt) {
            if (evt.keyCode === 27) {
                shared.preventDefault(evt);
            }
        });
        // this is used in GPing redirection code to check whether it's running on an AJAX SERP page
        _w["sj_isAjax"] = true;
        customEvents.fire("ajaxReady");
        customEvents.unbind("onP1", init);
    }
    function wireup() {
        var searchForm = document.getElementById("sb_form");
        nativeEvents.bind(searchForm, "submit", handleSearchForm);
        customEvents.bind("autoSugLoaded", function () {
            nativeEvents.unbind(searchForm, "submit", handleSearchForm);
            searchForm.submit = handleSearchForm;
        }, true);
        document.onclick = clickHandler;
        nativeEvents.bind(_w, "hashchange", handleHashChange, false);
        // Wireup location change script
        window["sj_lc"] = function (url, originInput) {
            var originValue = originInput;
            if (!originValue) {
                originValue = 3 /* AS */;
            }
            handleLocationChange(url, originValue);
        };
    }
    // Wireup onClick handler to activate AJAX experience
    function clickHandler(evt) {
        // We ignore handling the click for the following cases
        // 1) The click was already prevented from doing default behavior by some other feature on the page.
        // 2) The control key/shift key was pressed along with click, which indicates user was trying to open in new tab/window
        // 3) The click was due to a right button click. (Firefox fires the click event even for a right click)
        // 4) The url pointed to by the anchor tag is not going to serp vertical.
        // 5) The url pointed to by the anchor tag is same as the current page url.
        if (!evt.defaultPrevented && !evt.ctrlKey && !evt.shiftKey && evt.button === 0) {
            var element = evt.target;
            var targetElement = ajaxShared.getParentContainer(element, "tagName", "A");
            if (targetElement) {
                var ajaxController = ajaxProviders.getAjaxController(targetElement.href, 1 /* Click */, targetElement);
                if (!ajaxController) {
                    return;
                }
                var destinationPath = targetElement.pathname;
                var destionationProtocol = targetElement.protocol ? targetElement.protocol : location.protocol;
                var destinationHostname = targetElement.hostname ? targetElement.hostname : location.hostname; // automatically accquire current domain for relative links
                var destinationLink = targetElement.href;
                // If any links have a sid, format and jsoncbid property on them, we need to remove it
                destinationLink = ajaxController.sanitizeUrl(destinationLink);
                if (destinationLink) {
                    targetElement.href = destinationLink;
                }
                if (destinationHostname === location.hostname && location.protocol === destionationProtocol) {
                    // Make link relative
                    destinationLink = destinationLink.substr(destinationLink.indexOf(destinationPath));
                    loadPage(destinationLink, 1 /* Click */, ajaxController);
                    evt.preventDefault();
                }
            }
        }
    }
    // Autosuggest & Searchbox
    function getSearchUrl(query) {
        return _w.location.pathname + "?q=" + encodeURIComponent(query);
    }
    function getFormParameters(form) {
        var value = "";
        var inputFields = form.getElementsByTagName("input");
        for (var i = 0; i < inputFields.length; i++) {
            if (inputFields[i]["type"] === "hidden") {
                value += "&" + inputFields[i]["name"] + "=" + encodeURIComponent(inputFields[i]["value"]);
            }
        }
        return value;
    }
    function handleSearchForm(evt) {
        var form = document.getElementById(keyMap.SearchForm);
        var query = document.getElementById(keyMap.SBoxId)["value"];
        if (queryRegex.test(query)) {
            // Query is not empty and not just whitespace
            shared.preventDefault(evt);
            var relativeUrl = getSearchUrl(query) + getFormParameters(form);
            renderPage(relativeUrl, 3 /* AS */);
        }
    }
    function handleHistoryChange(data) {
        if (data && data.length > 1) {
            var currentUrl = data[1];
            // prevent re-rendering same page twice
            if (currentUrl) {
                renderPage(currentUrl, 2 /* History */);
            }
        }
    }
    function handleHashChange() {
        handleLocationChange(_w.location.toString(), 5 /* Hash */);
    }
    function handleLocationChange(url, originValue) {
        var relativeUrl = ajaxShared.getRelativeUrl(url);
        var ajaxController = ajaxProviders.getAjaxController(url, originValue);
        if (ajaxController) {
            loadPage(relativeUrl, originValue, ajaxController);
        }
        else if (window.location.href !== url) {
            window.location.assign(url);
        }
    }
    // First run operations
    customEvents.bind("onP1", init, true);
    function sendPerfPing() {
        // In case si_PP doesn't fire onPP by itself we need to make sure onPP fires.
        hasOnPPFired = false;
        customEvents.bind("onPP", function () { return hasOnPPFired = true; });
        _G.PPS = false;
        si_PP(new Date());
    }
    function isPendingUrl(url) {
        return pendingRequestUrls.indexOf(url) !== -1;
    }
    // Ajax Load Page
    function beforeRender(url, origin) {
        pendingRequestUrls.push(url);
        lastRenderedOrigin = origin;
        lastRenderedUrl = url;
        if (origin === 4 /* DirectNav */) {
            return;
        }
        customEvents.fire("unload");
        customEvents.fire("ajax.unload");
        env.clear();
        // Clear out black listed javascript namespaces
        shared.forEach(jsNamespaceBlacklist, function (jsNamespace) {
            if (window.hasOwnProperty(jsNamespace)) {
                window[jsNamespace] = _undefined;
                delete window[jsNamespace];
            }
        });
        shared.forEach(divClassNameBlackList, function (className) {
            var el = document.getElementsByClassName(className);
            for (var i = 0; i < el.length; i++) {
                var element = el[i];
                element.parentNode.removeChild(element);
            }
        });
        clearMaps();
        removeNotification();
        customEvents.reset();
        rms.reset();
    }
    function afterRender() {
        if (lastRenderedOrigin === 4 /* DirectNav */) {
            updateLocation(lastRenderedUrl);
            customEvents.fire("directNavComplete");
            return;
        }
        sendPerfPing();
        updateLocation(lastRenderedUrl);
        wireup();
        // Only fire post load events after perfping has had a chance to
        // upload data immediately.
        env.setTimeout(function () { return fireEvents(); }, 1);
    }
    function fireEvents() {
        customEvents.fire("ajax.load");
        customEvents.fire("onHTML");
        if (!hasOnPPFired) {
            customEvents.fire("onPP");
        }
        customEvents.fire("onP1Lazy");
        customEvents.fire("ajax.postload");
    }
    // Short-term solutions
    function removeNotification() {
        var div = document.getElementById(keyMap.Notification);
        if (div) {
            div.parentNode.removeChild(div);
            var identity = document.getElementById("id_h");
            if (identity)
                identity.style.top = "0";
        }
    }
    // Bug 1060372: Cleanup once there is a more effective way to clear out unnecessary global variables.
    // Clear namespaces related to maps. Needed for map pins to work properly.
    function clearMaps() {
        if (window["Bing"] && Bing.hasOwnProperty("MapControl")) {
            Bing.MapControl = _undefined;
            delete Bing.MapControl;
        }
        if (window["$MapsNamespace"]) {
            if (window.hasOwnProperty($MapsNamespace)) {
                window[$MapsNamespace] = _undefined;
                delete window[$MapsNamespace];
            }
        }
    }
    // Basic navigation methods to clean up existing page, change location and update history
    function updateLocation(url) {
        nativeEvents.unbind(_w, "hashchange", handleHashChange, false);
        if (lastRenderedOrigin !== 2 /* History */ && lastRenderedOrigin !== 4 /* DirectNav */ && lastRenderedOrigin !== 5 /* Hash */) {
            history.pushState(url);
        }
        // Clear out all pending URLs now that we're starting a fresh page
        pendingRequestUrls = [];
    }
    function renderPage(url, origin) {
        var ajaxController = ajaxProviders.getAjaxController(url, origin);
        if (ajaxController) {
            var sanitizedUrl = ajaxShared.getRelativeUrl(ajaxController.sanitizeUrl(url));
            loadPage(sanitizedUrl, origin, ajaxController);
        }
    }
    exports.renderPage = renderPage;
    function loadPage(url, origin, ajaxController) {
        if (isPendingUrl(url)) {
            return;
        }
        beforeRender(url, origin);
        customEvents.fire("ajax.navigateStart", url);
        ajaxController.createJsonAsync(url, function (json, renderItem) { return callback(url, json, renderItem); });
    }
    function callback(url, json, renderItem) {
        var endOfStream = "EOS";
        var renderFunc = json[endOfStream] ? function (k, v) {
            var retval = !renderItem || renderItem(k, v);
            if (k === endOfStream) {
                afterRender();
            }
            return retval;
        } : renderItem;
        ajaxRender.renderJson(json, renderFunc);
    }
});
;///<amd-module name="ajax.cortanaprovider" />
///<reference path="..\ajax.lifecycle.ts"/>
///<reference path="..\..\Declarations\ajax.d.ts"/>
define("ajax.cortanaprovider", ["require", "exports", "ajax.providers", "ajax.lifeCycle"], function (require, exports, ajaxProviders, pageLifeCycle) {
    var currentUrl;
    window["AjaxCB"] = [];
    var requestBuilder;
    function navigate(url, loader, origin) {
        currentUrl = url;
        if (!origin) {
            origin = 4 /* DirectNav */;
        }
        requestBuilder = loader;
        pageLifeCycle.renderPage(url, origin);
    }
    exports.navigate = navigate;
    function addJsonParameters(url) {
        if (url.indexOf("?") <= 0) {
            url += "?";
        }
        return "" + url + "&format=snrjson&jsoncbid=" + (window["AjaxCB"].length - 1);
    }
    function createJsonAsync(relativeUrl, callback) {
        window["AjaxCB"].push(callback);
        if (requestBuilder) {
            requestBuilder(relativeUrl, function (response, isJsonReponse) {
                var container = document.body;
                if (response && container) {
                    sj_appHTML(container, response);
                }
                if (!isJsonReponse) {
                    callback({ "EOS": 1 });
                }
            }, addJsonParameters);
            requestBuilder = null;
        }
        currentUrl = "";
    }
    function shouldAjax(url, origin, elem) {
        return url === currentUrl;
    }
    ajaxProviders.registerProvider({
        "shouldAjax": shouldAjax,
        "createJsonAsync": createJsonAsync
    });
});
;///<reference path="..\..\..\..\Shared\Content\Content\Script\Declarations\Shared.d.ts" />
///<reference path="..\..\..\..\Threshold\src\Content\Script\Declarations\SearchAppWrapper.d.ts" />
///<reference path="..\..\..\..\Shared\Content\Content\Script\Declarations\Threshold.Utilities.d.ts" />
///<reference path="..\..\..\..\..\..\Sparkle\src\content\Sparkle.d.ts" />
var ReminderClickAction;
(function (ReminderClickAction) {
    function createReminderAction(SPAAction, ImpressionId) {
        //var remindButton = <HTMLElement>_ge('remindButton');
        //var title = <string>_ge('remindTitle').nodeValue.toString();
        //var date = <string>_ge('remindDate').nodeValue.toString();
        //var time = <string>_ge('remindTime').nodeValue.toString();
        //remindButton.onclick = ev => {
        //    SearchAppWrapper.CortanaApp.processNLCommandAsync(SPAAction, ImpressionId);
        //};
        //navigateToNewCard("PortableCortanaReminder:PortableCortanaReminderCreate",
        //    "PortableCortanaReminderCreateViewModel",
        //    "remindButton");
        SearchAppWrapper.CortanaApp.processNLCommandAsync(SPAAction, ImpressionId);
    }
    ReminderClickAction.createReminderAction = createReminderAction;
    function cancelReminderAction() {
        navigateToNewCard("PortableCortanaReminder:PortableCortanaReminderCancel", "PortableCortanaReminderCancelViewModel", "cancelButton");
    }
    ReminderClickAction.cancelReminderAction = cancelReminderAction;
    function navigateToNewCard(viewName, viewModel, containerId) {
        Sparkle.render(viewName, {
            uiCulture: SearchAppWrapper.CortanaApp.uiLanguage,
            properties: {
                ViewModel: viewModel
            },
            viewData: {}
        }, _ge(containerId));
    }
    ReminderClickAction.navigateToNewCard = navigateToNewCard;
    function openFirstTurnSearchRemindMeToLink(url) {
        var link = _ge('legacyRecourse');
        link.onclick = function (ev) {
            openUri(url);
        };
    }
    ReminderClickAction.openFirstTurnSearchRemindMeToLink = openFirstTurnSearchRemindMeToLink;
    function openUri(uri) {
        return ThresholdUtilities.wrapApiCall(SearchAppWrapper.CortanaApp.launcher, "launchUriAsync", uri, "SearchRemindMeTo", uri).then(closeCortana);
    }
    function closeCortana() {
        SearchAppWrapper.CortanaApp.dismissApp();
    }
})(ReminderClickAction || (ReminderClickAction = {}));
;(function () {
    function Promote() {
        var isBingSE = _w["isBingCurrentSearchDefault"];
        var setSE = _w["setBingCurrentSearchDefault"];
        if (setSE && isBingSE) {
            var promptNow = false;
            var currDate = new Date();
            if (typeof (Storage) !== "undefined" && _w.localStorage) {
                var tempFlagData = localStorage.getItem("lastSEPromptShownFlag");
                if (tempFlagData != null && tempFlagData != "false") {
                    if (isBingSE() == false) {
                        Log.Log("SetSE", "SetSE", "setBingCurrentSearchDefault", true, "PSE", "Non-Bing", "SE", "Non-Bing", "UA", "Denied");
                    }
                    else {
                        Log.Log("SetSE", "SetSE", "setBingCurrentSearchDefault", true, "PSE", "Non-Bing", "SE", "Bing", "UA", "Accepted");
                    }
                    localStorage.setItem("lastSEPromptShownFlag", false);
                }
                if (!localStorage.getItem("lastSEPromptDate")) {
                    promptNow = true;
                }
                else {
                    if (currDate.getTime() - new Date(localStorage.getItem("lastSEPromptDate")).getTime() > 1000 * 60 * 60 * 24 * 7) {
                        promptNow = true;
                    }
                    else {
                        promptNow = false;
                    }
                }
            }
            if (promptNow && isBingSE() == false) {
                try {
                    localStorage.setItem("lastSEPromptDate", currDate);
                    localStorage.setItem("lastSEPromptShownFlag", true);
                    var result = setSE();
                }
                catch (err) {
                    promptNow = false;
                }
            }
        }
    }
    sj_be(_w, "load", Promote);
})();
;///<reference path="Declarations\Shared.d.ts" />
var SelectorHelper;
(function (SelectorHelper) {
    // This method is intended to work cross-browser. On down-level browsers without native javascript support, the DOM is walked to find a match.  Please be mindful of performance when calling this for down-level browsers.
    function selectorMatches(e, selector) {
        if (e["matches"]) {
            return e["matches"](selector);
        }
        else if (e["webkitMatchesSelector"]) {
            return e["webkitMatchesSelector"](selector);
        }
        else if (e["mozMatchesSelector"]) {
            return e["mozMatchesSelector"](selector);
        }
        else if (e["msMatchesSelector"]) {
            return e["msMatchesSelector"](selector);
        }
        else {
            var eles = _d.querySelectorAll(selector);
            if (eles) {
                for (var i = 0; i < eles.length; i++) {
                    if (eles[i] === e) {
                        return true;
                    }
                }
            }
            return false;
        }
    }
    SelectorHelper.selectorMatches = selectorMatches;
    function findFirstAncestorWithSelector(e, selector) {
        var p = e;
        do {
            p = p.parentElement;
        } while (p != null && !selectorMatches(p, selector));
        return p;
    }
    SelectorHelper.findFirstAncestorWithSelector = findFirstAncestorWithSelector;
})(SelectorHelper || (SelectorHelper = {}));
;///<reference path="..\Declarations\Shared.d.ts" />
///<reference path="..\SelectorHelper.ts" />
var AnswerActionsHelper;
(function (AnswerActionsHelper) {
    function createUndoContainer(undoText, confirmText) {
        if (undoText == null || confirmText == null) {
            return null;
        }
        var msgContainer = sj_ce("div", null, "b_undoContainer b_hide");
        var confirmContainer = sj_ce("div", null, "confirmMsg");
        confirmContainer.innerHTML = confirmText;
        var undoLink = sj_ce("a");
        undoLink.setAttribute("href", "javascript:void(0);");
        undoLink.innerText = undoText;
        msgContainer.appendChild(confirmContainer);
        msgContainer.appendChild(undoLink);
        return msgContainer;
    }
    AnswerActionsHelper.createUndoContainer = createUndoContainer;
    function createErrorHandler(actionLink, errorString, isButtons) {
        return function () {
            // Let the action link be functional again and set error text
            actionLink["isHandling"] = false;
            actionLink.innerText = errorString;
            actionLink.classList.remove("b_demoteText");
            if (!isButtons) {
                actionLink.classList.add("b_accentColor");
            }
        };
    }
    AnswerActionsHelper.createErrorHandler = createErrorHandler;
    // For a given element, find the answer card it's contained within.
    function findContainingCard(element) {
        var card = SelectorHelper.findFirstAncestorWithSelector(element, "#b_pole,.b_ans,.b_ansSlice,.answer,.b_inlActions");
        var isInlineActionContainer = card.classList.contains("b_inlActions");
        if (isInlineActionContainer) {
            var ansCard = SelectorHelper.findFirstAncestorWithSelector(card, "#b_pole,.b_ans,.b_ansSlice,.answer");
            if (ansCard) {
                card = ansCard;
            }
        }
        return card;
    }
    AnswerActionsHelper.findContainingCard = findContainingCard;
    // Determines whether an element is a wrapper used for swapping.
    function isSwapWrapper(element) {
        return element.getAttribute("data-type") === "wrapper";
    }
    AnswerActionsHelper.isSwapWrapper = isSwapWrapper;
    function fade(element) {
        if (element == null) {
            return;
        }
        element.classList.add("b_anim");
        // For the animation to work correctly, it has to transition from one property to another.
        // So to transition to zero properly, we need to set the height explicitly first.
        element.style.height = _w.getComputedStyle(element).height;
        // Start the animation. We need a miniscule amount of time to have the above style change repaint.
        sb_st(function () {
            element.classList.add("b_hide");
            sj_evt.fire('elementgone', element);
        }, 1);
    }
    AnswerActionsHelper.fade = fade;
    function createResponseCard(content, oldCard) {
        if (!oldCard) {
            return null;
        }
        var container = sj_ce(oldCard.tagName, "", oldCard.className);
        container.innerHTML = content;
        return container;
    }
    AnswerActionsHelper.createResponseCard = createResponseCard;
    function swapElements(newElement, oldElement, fadeIfNoReplacement) {
        if (newElement == null || oldElement == null) {
            if (oldElement != null && fadeIfNoReplacement) {
                fade(oldElement);
            }
            return;
        }
        // Create a wrapper element that houses both the new and old elements.
        // Try to reuse an existing wrapper if we find one to keep the DOM shallow.
        var parent = oldElement.parentElement;
        var container;
        if (isSwapWrapper(parent)) {
            container = parent;
        }
        else {
            container = sj_ce("div");
            container.setAttribute("data-type", "wrapper");
            container.classList.add('b_anim');
            parent.insertBefore(container, oldElement);
            container.appendChild(oldElement);
        }
        // Move the new element to the wrapper too
        container.appendChild(newElement);
        // We want to ensure the container animates the height change. To do this we:
        //   1. Set the height to the old element's height
        //   2. Set the height to the new element's height after the above height change goes into effect.
        //   3. When the height has animated, reset the value so that the style is not affecting other transformations on page
        container.style.height = getTotalHeight(oldElement) + "px";
        sb_st(function () {
            container.style.height = getTotalHeight(newElement) + "px";
            sb_st(function () { return container.style.height = ''; }, 0);
        }, 0);
        // Fade out the old element
        fade(oldElement);
    }
    AnswerActionsHelper.swapElements = swapElements;
    function findImmediateChild(parent, descendant) {
        while (descendant && descendant.parentElement !== parent) {
            descendant = descendant.parentElement;
        }
        return descendant;
    }
    function wrapWithDiv(elements, excludedElements) {
        var wrapper = sj_ce("div");
        var i = 0;
        while (i < elements.length) {
            var child = elements[i];
            if (excludedElements == null || excludedElements.indexOf(child) < 0) {
                wrapper.appendChild(child);
            }
            else {
                i++;
            }
        }
        return wrapper;
    }
    function getTotalHeight(element) {
        return convertStyleToPixels(_w.getComputedStyle(element).height) + convertStyleToPixels(_w.getComputedStyle(element).paddingBottom);
    }
    function convertStyleToPixels(style) {
        // Cut off the "px" suffix
        return parseInt(style.substring(0, style.length - 2));
    }
    function insertScriptIntoHead(script) {
        var returnScript = sj_ce("script", "");
        returnScript.type = "text/javascript";
        if (script.src) {
            returnScript.src = script.src;
        }
        else {
            returnScript.innerHTML = script.innerHTML;
        }
        insertNodeIntoHead(returnScript);
    }
    function dismissCard(action) {
        var lastClickedCard = AnswerActionsHelper.findContainingCard(action);
        AnswerActionsHelper.fade(lastClickedCard);
        var answerContainer = SelectorHelper.findFirstAncestorWithSelector(lastClickedCard, "#b_pole,.b_ans");
        if (answerContainer) {
            sb_st(function () {
                var subAnswers = AnswerActionsHelper.findInCard(answerContainer, ".b_ansSlice", false);
                if (!subAnswers) {
                    AnswerActionsHelper.fade(answerContainer);
                }
                sj_evt.fire("dismissCard");
            }, 1);
        }
    }
    AnswerActionsHelper.dismissCard = dismissCard;
    function replaceCard(action, newContent) {
        // Find the old and new answer cards
        var oldCard = findContainingCard(action);
        var newCard = createResponseCard(newContent, oldCard);
        if (oldCard == null || newCard == null) {
            if (oldCard != null) {
                // No new card came back but the action was successfull. Just dismiss the card.
                fade(oldCard);
            }
            return;
        }
        var isSearchReversed = false;
        var ansSlices = oldCard.querySelectorAll("div.b_ansSlice");
        if (ansSlices) {
            isSearchReversed = true;
        }
        // Extract styles and throw them into the DOM
        var styles = newCard.querySelectorAll("style, link");
        if (styles) {
            for (var i = 0; i < styles.length; i++) {
                insertNodeIntoHead(styles[i]);
            }
        }
        // Find the old explanation
        var newExplanation = findExplanation(newCard, false);
        var oldExplanation = findExplanation(oldCard, isSearchReversed);
        // Find the old and new annotations
        var newAnnotation = findAnnotation(newCard, false);
        var oldAnnotation = findAnnotation(oldCard, false);
        // Find the old and new actions
        var newActions = findActions(newCard, false);
        var oldActions = findActions(oldCard, isSearchReversed);
        // Find and swap the old and new captions
        var newCaption = wrapCaption(newAnnotation, newActions, newExplanation);
        var oldCaption = wrapCaption(oldAnnotation, oldActions, oldExplanation);
        // Extract scripts to later throw them into the DOM
        var scripts = newCard.querySelectorAll("script");
        // All animations go! Note that each of these animate independantly.
        swapElements(newAnnotation, oldAnnotation, false);
        swapElements(newCaption, oldCaption, false);
        swapElements(newActions, oldActions, true);
        swapElements(newExplanation, oldExplanation, true);
        if (scripts) {
            for (var i = 0; i < scripts.length; i++) {
                insertScriptIntoHead(scripts[i]);
            }
        }
        sj_evt.fire("replaceCard");
    }
    AnswerActionsHelper.replaceCard = replaceCard;
    // Find the element having a parent with data-type = "infoldAction"
    function findInlineActionContainer(action) {
        while (action != null) {
            var parent = action.parentElement;
            if (parent && parent.getAttribute && parent.getAttribute("data-type") === "InlineActionsWrapper") {
                return action;
            }
            action = parent;
        }
        return null;
    }
    AnswerActionsHelper.findInlineActionContainer = findInlineActionContainer;
    function insertNodeIntoHead(node) {
        _d.head.appendChild(node);
    }
    function findAnnotation(card, isSearchReversed) {
        return findInCard(card, '.b_anno,[data-anno]', isSearchReversed);
    }
    AnswerActionsHelper.findAnnotation = findAnnotation;
    function findTitle(card) {
        return findInCard(card, '.b_anno~h2,.b_anno~.b_focusLabel', false);
    }
    AnswerActionsHelper.findTitle = findTitle;
    function nodeListContains(nodelist, elem) {
        for (var i = 0; i < nodelist.length; i++) {
            if (nodelist[i] == elem) {
                return true;
            }
        }
        return false;
    }
    AnswerActionsHelper.nodeListContains = nodeListContains;
    function findActions(card, isSearchReversed) {
        var expandableActions = findInCard(card, '[data-type="expandableActions"]', isSearchReversed);
        return expandableActions ? expandableActions : findInCard(card, '[data-type="actions"]', isSearchReversed);
    }
    AnswerActionsHelper.findActions = findActions;
    function findExplanation(card, isSearchReversed) {
        return findInCard(card, '.actExpl', isSearchReversed);
    }
    AnswerActionsHelper.findExplanation = findExplanation;
    function findInCard(card, selector, isSearchReversed) {
        if (card) {
            var elements = card.querySelectorAll(selector);
            for (var i = (isSearchReversed ? elements.length - 1 : 0); (!isSearchReversed && i < elements.length) || (isSearchReversed && i >= 0); isSearchReversed ? i-- : i++) {
                var element = elements[i];
                if (element.classList.contains('b_hide')) {
                    // If we find an already faded element, go ahead and do some housekeeping to just remove it from the DOM.
                    element.parentNode.removeChild(element);
                }
                else {
                    return element;
                }
            }
        }
        return null;
    }
    AnswerActionsHelper.findInCard = findInCard;
    function wrapCaption(annotation, actions, explanation) {
        if (!annotation) {
            return null;
        }
        var parent = findContainingCard(annotation);
        var annotationImmediateChild = findImmediateChild(parent, annotation);
        var caption = wrapWithDiv(parent.childNodes, [annotationImmediateChild, findImmediateChild(parent, actions), findImmediateChild(parent, explanation)]);
        return parent.insertBefore(caption, annotationImmediateChild.nextSibling);
    }
})(AnswerActionsHelper || (AnswerActionsHelper = {}));
;///<reference path="..\..\..\..\Shared\Content\Content\Script\Declarations\Shared.d.ts" />
///<reference path="..\..\..\..\Shared\Content\Content\Script\Declarations\Animation.d.ts" />
///<reference path="..\..\..\..\Threshold\src\Content\Script\Declarations\SearchAppWrapper.d.ts" />
var SearchPeek;
(function (SearchPeek) {
    // const aliases for perf
    var Load = "load";
    var Peek = "peek";
    var PeekExpand = "peekExpand";
    var HideClass = "b_hide";
    var content = _ge("b_content");
    var results = _ge("b_results");
    var resultsItems = results.querySelectorAll(".b_ans,.b_algo,.b_ad");
    var poleAnswer = _ge("b_pole");
    var isCat3a = poleAnswer != null && poleAnswer.querySelector(".b_anno") != null;
    var annotation = isCat3a ? poleAnswer.querySelector(".b_anno") : null;
    var title = isCat3a ? poleAnswer.querySelector(".b_anno~h2,.b_anno~.b_focusLabel") : null;
    var header = _ge("b_header");
    var pagination = results.querySelector(".b_pag");
    var footer = _d.querySelector(".b_footer");
    var messageModules = results.querySelectorAll(".b_msg");
    var recourseLink = results.querySelector(".recourseLink").parentNode;
    var feedbackDiv = _ge("sb_feedback");
    var feedbackBadge = feedbackDiv ? feedbackDiv.parentNode : null;
    var hasPeekActivated = false;
    function activatePeek() {
        if (hasPeekActivated) {
            return;
        }
        hasPeekActivated = true;
        // change the background color
        _d.documentElement.classList.remove(Peek);
        sj_b.classList.remove(Peek);
        _d.documentElement.classList.add(PeekExpand);
        sj_b.classList.add(PeekExpand);
        // hide the pole answer based on a flag set by the answer
        if (annotation.getAttribute("data-mainContent") === "1") {
            Animation.toggleSlide(poleAnswer);
        }
        else {
            // answer will be shown in Cat3B, show/hide/animate the elements
            if (title) {
                title.classList.remove(HideClass);
            }
            annotation.classList.add(HideClass);
        }
        // Hide the recourse links        
        recourseLink.classList.add(HideClass);
        // Fade in the header, results, pagination, footer, etc.
        Animation.toggleSlideTranslate(header);
        content.classList.add(PeekExpand);
        results.classList.add("b_slideListHide");
        for (var i = 0; i < resultsItems.length; i++) {
            var result = resultsItems[i];
            result.classList.remove(HideClass);
        }
        if (pagination != null) {
            pagination.classList.remove(HideClass);
        }
        footer.classList.remove(HideClass);
        Animation.cascadeList(results);
        // Hide the client header
        SearchAppWrapper.CortanaApp.setChromeState(7 /* NoHeader */);
        // Let others know the peek happened
        sj_evt.fire("peekexpand", true);
    }
    function showPeek() {
        if (isCat3a) {
            // The title stays hidden
            if (title != null) {
                title.classList.add(HideClass);
                title.classList.add(Peek);
            }
            annotation.classList.remove("b_anim");
            // The scope bar stays hidden
            header.classList.add(HideClass);
            header.classList.add(Peek);
            // results stay hidden
            results.classList.add(Peek);
            for (var i = 0; i < resultsItems.length; i++) {
                var result = resultsItems[i];
                result.classList.add(HideClass);
            }
            for (var i = 0; i < messageModules.length; i++) {
                var messageModule = messageModules[i];
                if (messageModule !== recourseLink && messageModule !== feedbackBadge) {
                    messageModule.classList.add(HideClass);
                }
            }
            // pagination stays hidden
            if (pagination != null) {
                pagination.classList.add(HideClass);
            }
            // The footer stays hidden
            footer.classList.add(HideClass);
            footer.classList.add(Peek);
            // Wait for user to click the recourse link.
            sj_evt.bind("peekactivate", activatePeek, true);
        }
        else {
            // Hide the recourse link
            recourseLink.classList.add(HideClass);
            // Fade in the header, results, footer, etc.
            header.classList.add(Peek);
            content.classList.add(PeekExpand);
            results.classList.add(PeekExpand);
            results.classList.add(Peek);
            footer.classList.add(Peek);
        }
        // Clean up event binding
        sj_ue(_w, Load, showPeek);
    }
    if (content != null && results != null && header != null && recourseLink != null && footer != null) {
        // Because of timing and dimensions-related issues related to the browser itself sliding up from the bottom of the screen,
        // we should just hide the results until after we load and have a chance to properly set peek padding.
        sj_be(_w, Load, showPeek);
    }
    // background color needs to be applied before onload so the initial paint gets the right background for cat3a
    if (isCat3a) {
        _d.documentElement.classList.add(Peek);
        sj_b.classList.add(Peek);
    }
})(SearchPeek || (SearchPeek = {}));
;sj_evt.bind("ajax.feedback.initialized", function(args) { args[1].debugCollector.setContextValue("FederationDebugInfo", "QueryID : f37e5489713849c787f805b462a1513f"); });;
//]]>--></div><div style="display:none"><!--//<![CDATA[
///<reference path="..\..\..\..\answers\services\Shared\Content\Content\script\Declarations\Shared.d.ts"/>
/**
*   Parses the content as HTML and attaches it to the given element.
*   The function takes care of attaching styles and scripts as well.
*   !!! For IE8 and below please make sure dom element passed to the
*       function is part of the DOM tree. !!!
*   @private
*   @param elem - The element to which the parsed content is appended
*   @param content - html content that has to be parsed
*   @example - sj_appHTML(_d.body,"<div>hello</div>");
*/
// BUGBUG: TFS 780914: TypeScript throws build error when two ts file declare the same variable
var sj_appHTML = function (elem, content) {
    if (!content || !elem) {
        return;
    }
    var innerHtml = "innerHTML", scriptTag = "script", appendChild = "appendChild", length = "length", srcAttribute = "src", createElement = sj_ce;
    var div = createElement('div');
    // In IE9 and below innerHTML removes script and style tags if it is
    // not preceded by a visible node.
    div[innerHtml] = '<br>' + content;
    var childNodes = div.childNodes;
    div.removeChild(childNodes[0]);
    var scripts = div.getElementsByTagName(scriptTag);
    if (scripts) {
        for (var i = 0; i < scripts[length]; i++) {
            var newScript = createElement(scriptTag), oldScript = scripts[i];
            if (oldScript) {
                newScript.type = "text/javascript";
                var src = oldScript.getAttribute(srcAttribute);
                if (src) {
                    newScript.setAttribute(srcAttribute, src);
                }
                else {
                    newScript.text = oldScript[innerHtml];
                    newScript.setAttribute("data-bing-script", "1");
                }
                oldScript.parentNode.replaceChild(newScript, oldScript);
            }
        }
    }
    var frag = _d.createDocumentFragment();
    while (childNodes[length]) {
        frag[appendChild](childNodes[0]);
    }
    elem[appendChild](frag);
};
;///<reference path="..\..\..\..\answers\services\Shared\Content\Content\script\Declarations\Shared.d.ts"/>
/**
*   Friendly ajax handler for doing get requests and appending response to dom.
*   @Definition of sj_ajax function
*   @param  url <string>: The url of the site to be ajax loaded
*   @param settings <IAjaxSettings>: Settings defines the callback function
*       and the timeout value for the request.
*   @example sj_ajax("/ajaxload",{
         callback:function(success, response){
*           if(success) response.appendTo(_d.body);
*        },
*        timeout: 1000
*     });
*
*   @Definition of IAjaxSettings object
*   @member Callback <function(success, response)> : This is the function that is called
*               once the request is complete. The functions gets passed two parameters.
*            @param success <bool> - This indicates the sucess of the request.
*            @param response <IAjaxResponse> - A response object that contains the request,
*                a helper fuction to append to dom etc.
*   @member Timeout : Time period in ms to wait before timing out the request.
*
*   @Definition of IAjaxResponse
*   @member request<XMLHttpRequest> : The request object of the current request.
*   @member appendTo<function(domElem)> : If the ajax response is in the form of html then this
*              helper function can be used to attach the html content to the page. This fuction
*              takes care of applying all the style and script tags appropriately.
*              !!! For IE8 and below please make note that scripts would be immediately executed
*                  even if domElem is not in the Dom tree. !!!
*           @param domElem <HTMLElement> - The dom element to attach the html reponse to.
*/
var sj_ajax = function (url, settings) {
    var callback, request = sj_gx(), onreadystatechange = "onreadystatechange", timeout, timeoutHandler = null, setTimeout = sb_st, clearTimeout = sb_ct, empty = function () {
    };
    if (!url || !request) {
        doCallback(callback, false);
        return;
    }
    if (settings) {
        callback = settings.callback;
        timeout = settings.timeout;
    }
    request.open("get", url, true);
    request[onreadystatechange] = function () {
        if (request.readyState === 4) {
            var success = false;
            if (timeoutHandler !== null) {
                clearTimeout(timeoutHandler);
            }
            if (request.status === 200) {
                success = true;
                // Bug on chrome. Multiple onreadystatechange are triggered in debug mode
                request[onreadystatechange] = empty;
            }
            doCallback(callback, success);
        }
    };
    // For ajaxserp we need to cancel this request before loading a new page
    // or else a race condition can do this callback on the next page.
    sj_evt.bind("ajax.unload", cancelRequest);
    request.send();
    function cancelRequest() {
        request[onreadystatechange] = empty;
        if (request.abort) {
            request.abort();
        }
    }
    if (timeout > 0) {
        timeoutHandler = setTimeout(function () {
            cancelRequest();
            doCallback(callback, false);
        }, timeout);
    }
    /**
    *   Executes the callback function by passing it the status message
    *   @private
    *   @param callback - The callbacck function to be executed
    *   @param isSuccess - Bool value indicating if the ajax load was successful
    */
    function doCallback(callback, isSuccess) {
        if (typeof (callback) === "function") {
            callback(isSuccess, {
                request: request,
                appendTo: function (elem) {
                    if (request) {
                        sj_appHTML(elem, request.responseText);
                    }
                }
            });
        }
    }
};
;
//]]>--></div></div><script type="text/javascript">//<![CDATA[
_G.HT=new Date;
//]]></script><script type="text/javascript" data-rms="1">//@ sourceURL=BingDynamicScript0.js
//<![CDATA[
/// <reference path="../../../../Shared/Content/Content/script/Declarations/Shared.d.ts"/>
/// <reference path="../../../../Shared/Content/Content/script/Declarations/Threshold.Utilities.d.ts"/>
(function () {
    var kValueExtractionRegex = /ID=(\w+),(\d+(?:\.\d+)*)(&PR=(.*))?/i;
    function sendRequest(linkInfo, el, evt, typeOfClick) {
        if (linkInfo) {
            var gpingData = getGPingData(linkInfo, typeOfClick);
            var clickConfig = _w["ClickConfig"] || {};
            if (_w["Log2"]) {
                Log2.LogEvent(gpingData.eventType, gpingData.data, null, null, null, null, null, null);
                if (_w["ThresholdUtilities"]) {
                    var utilities = _w["ThresholdUtilities"];
                    utilities.uploadApiTimes("PCE");
                }
                if (clickConfig.ForceFlushOnClick || ((typeOfClick === 0) && clickLeavesPage())) {
                    // if we are leaving the page with this click we will flush all relevant logs
                    sj_evt.fire("visibility", document["hidden"]);
                    if (clickConfig.FlushSkipAbort) {
                        Log2.FlushMainQueueDontForce();
                    }
                    else {
                        Log2.ForceFlush();
                    }
                    _w["clickFlushedTime"] = sb_gt();
                }
            }
            else {
                si_t_b(linkInfo);
            }
        }
    }
    var siT = _w["si_T"];
    _w["si_T"] = sendRequest;
    function si_t_b(a) {
        if (siT) {
            siT(a);
        }
        else {
            if (document.images) {
                _G.GPImg = new Image;
                _G.GPImg.src = _G.gpUrl + 'IG=' + _G.IG + (_G.CID ? '&CID=' + _G.CID : '') + '&TS=' + (new Date().getTime()) + a;
            }
        }
    }
    function clickLeavesPage() {
        if (_w.event && _w.event.srcElement) {
            var linkToCheck = _w.event.srcElement;
            while (!linkToCheck.href) {
                if (linkToCheck.parentElement) {
                    linkToCheck = linkToCheck.parentElement;
                }
                else {
                    // we have no further up to go, this means the user didn't click on a link
                    return false;
                }
            }
            if (linkToCheck.href.split("#")[0] !== _d.URL.split("#")[0]) {
                return true;
            }
        }
        return false;
    }
    function getGPingData(linkInfo, typeOfClick) {
        var matches = linkInfo.match(kValueExtractionRegex);
        if (matches) {
            var gpingData = {
                eventType: "Click",
                data: {
                    AppNS: matches[1],
                    K: matches[2],
                    Case: typeOfClick
                }
            };
            if (matches[4]) {
                gpingData.data.Properties = JSON.parse(matches[4]);
            }
            return gpingData;
        }
        throw new Error("hValue passed to click tracking was unable to be parsed: " + linkInfo);
    }
})();
;///<amd-module name="onHTML" />
define("onHTML", ["require", "exports", "event.custom"], function (require, exports, customEvents) {
    customEvents.fire("onHTML");
});
;///<reference path="Declarations\Shared.d.ts"/>
// Prevent zooming via ctrl + mousewheel
sj_be(_d, "mousewheel", function (evt) {
    if (evt.ctrlKey == true) {
        sj_pd(evt);
    }
});
// Prevent zooming via ctrl +/-
sj_be(_d, "keydown", function (evt) {
    if (evt.ctrlKey == true && (evt.keyCode == 107 || evt.keyCode == 109 || evt.keyCode == 187 || evt.keyCode == 189)) {
        sj_pd(evt);
    }
});
;///<reference path="Declarations\Shared.d.ts" />
/*
Instrumentation library for server and client powered apps in Windows smartsearch
Per this design, Server sets the visibility to false (v=0) on all the app links and client sends the Merge update through MergeInstruction format
setting v=1 on link being shown and also sends the Datasource merge event setting correct installstate of the app.
*/
var AppInst;
(function (AppInst) {
    var kValueExtractionRegex = /ID=([\w]+),([\d]+\.[\d]+)/i;
    var kValueNew = 1;
    AppInst.layoutJson = [];
    AppInst.datasourceJson = [];
    (function (InstallState) {
        InstallState[InstallState["Installed"] = 0] = "Installed";
        InstallState[InstallState["NotInstalled"] = 1] = "NotInstalled";
    })(AppInst.InstallState || (AppInst.InstallState = {}));
    var InstallState = AppInst.InstallState;
    // queues for submission or submits the instrumentation log for server powered apps in smartsearch
    function queueServerAppLog(hVisibleLayout, appInfoDsKValue, installState, hideIfNotInstalled, canSubmit) {
        if (canSubmit === void 0) { canSubmit = true; }
        var namespace = "";
        if (hVisibleLayout) {
            var matches = hVisibleLayout.match(kValueExtractionRegex);
            if (matches && matches.length >= 3) {
                // Store the namespace and K value.
                namespace = matches[1];
                var kValue = matches[2];
                if (installState !== 1 /* NotInstalled */ || !hideIfNotInstalled) {
                    AppInst.layoutJson.push({
                        "T": "L.MI",
                        "Action": "Update",
                        "AppNS": namespace,
                        "K": kValue,
                        "V": "1"
                    });
                }
            }
        }
        if (appInfoDsKValue) {
            AppInst.datasourceJson.push({
                "T": "D.MI",
                "Action": "Update",
                "AppNS": namespace,
                "K": appInfoDsKValue,
                "InstallState": getInstallStateString(installState)
            });
        }
        if (canSubmit) {
            submitLog();
        }
    }
    AppInst.queueServerAppLog = queueServerAppLog;
    function getInstallStateString(installState) {
        switch (installState) {
            case 0 /* Installed */:
                return "Installed";
            case 1 /* NotInstalled */:
                return "NotInstalled";
            default:
                return "Unknown";
        }
    }
    function getUniqueId() {
        return kValueNew++;
    }
    AppInst.getUniqueId = getUniqueId;
    // submits the instrumentation log in Merge instruction (MI) format.
    function submitLog() {
        var data = [];
        if (AppInst.layoutJson.length > 0) {
            data.push({
                "Page": AppInst.layoutJson
            });
            AppInst.layoutJson = [];
        }
        if (AppInst.datasourceJson.length > 0) {
            data.push(AppInst.datasourceJson);
            AppInst.datasourceJson = [];
        }
        if (data.length > 0) {
            postLog(JSON.stringify(data));
        }
    }
    AppInst.submitLog = submitLog;
    function postLog(data) {
        if (data) {
            if (_w["Log2"]) {
                Log2.LogEvent("ClientInst", JSON.parse(data), null, null, null, null, null, null);
            }
            else {
                // If ClientInstV2 is not supported
                var time = sb_gt();
                var payload = "<E><T>Event.ClientInst</T><IG>" + _G.IG + "</IG><TS>" + time + "</TS><D>" + data + "</D></E>";
                var xml = "<ClientInstRequest><Events>" + payload + "</Events><STS>" + time + "</STS></ClientInstRequest>";
                var request = sj_gx();
                request.open("POST", "/fd/ls/lsp.aspx", true);
                request.setRequestHeader("Content-Type", "text/xml");
                request.send(xml);
            }
        }
    }
})(AppInst || (AppInst = {}));
;///<reference path="..\Declarations\Shared.d.ts"/>
///<reference path="..\AppInst.ts"/>
// this module is used to initialize the Hose page to have app context sense
var AppApi;
(function (AppApi) {
    // Adds a handler for the specified control name
    function AddControlHandler(controlName, handler) {
        if (!controlHandlers[controlName]) {
            controlHandlers[controlName] = handler;
        }
    }
    AppApi.AddControlHandler = AddControlHandler;
    // The map of handlers for each control type
    var controlHandlers = {};
    // holding a cache of current page apps
    var pageApps = null;
    var instrumentationEnabled = typeof (AppInst) != 'undefined';
    // update app
    function updateApp(app) {
        if (pageApps && app) {
            var elements = pageApps[app.id];
            if (elements) {
                for (var i = 0; i < elements.length; ++i) {
                    updateAppElement(elements[i], app);
                }
            }
        }
    }
    // Invokes the control-specific handler
    function updateAppElement(element, app) {
        var hideIfNotInstalled = Boolean(element.getAttribute("data-hideIfNotInstalled"));
        if (instrumentationEnabled) {
            // Setting canSubmit to 'false' here so that single payload can be submitted later for all the Apps through explicit call to AppInst.SubmitLog function.
            var canSubmit = false;
            var installState = app.installed ? 0 /* Installed */ : 1 /* NotInstalled */;
            AppInst.queueServerAppLog(element.getAttribute("h"), element.getAttribute("data-appInfoDsK"), installState, hideIfNotInstalled, canSubmit);
        }
        var controlName = element.getAttribute("data-controlName");
        if (controlName) {
            var handler = controlHandlers[controlName];
            if (handler) {
                var minVersionStr = element.getAttribute("data-minVersion");
                var additionalPropsStr = element.getAttribute("data-additionalProps");
                var installedVersion = app.installedAppVersion ? stringToVersion(app.installedAppVersion) : null;
                var requiredMinVersion = minVersionStr ? stringToVersion(minVersionStr) : null;
                var eventArgs = {
                    appElement: element,
                    appInfo: app,
                    installedVersion: installedVersion,
                    requiredMinVersion: requiredMinVersion,
                    // if the min version is not specified, no update is needed
                    updateRequired: requiredMinVersion && installedVersion ? compareAppVersions(installedVersion, requiredMinVersion) < 0 : false,
                    updateAvailable: app.updateAvailable,
                    hideIfNotInstalled: hideIfNotInstalled,
                    additionalProps: null
                };
                try {
                    eventArgs.additionalProps = additionalPropsStr ? JSON.parse(additionalPropsStr) : null;
                    handler(eventArgs);
                }
                catch (ex) {
                    // Nothing we can do, really...
                    Log.Log("Error", "AppApi", "Handler_" + controlName, false, "Tx", ex.message);
                }
                if (app.installed && hideIfNotInstalled) {
                    // Show previously hidden apps
                    element.classList.remove('b_hide');
                }
            }
        }
    }
    // Reads the app from current page
    function readApps() {
        // We create the list of apps on first call to UpdateApp
        if (pageApps) {
            return;
        }
        pageApps = {};
        var dataAttr = "data-appid";
        // Scrape the DOM to get all the DOM Elements related to apps
        var appLinks = _d.querySelectorAll("[" + dataAttr + "]");
        for (var i = 0; i < appLinks.length; i++) {
            var appLink = appLinks[i];
            if (appLink) {
                // Get the value of data - appid attribute
                var appId = appLink.getAttribute(dataAttr);
                // If the app id is valid, then add it to the collection
                if (appId) {
                    var appElementList = pageApps[appId];
                    if (appElementList) {
                        // add it to the existing collection
                        appElementList.push(appLink);
                    }
                    else {
                        // create a new list to hold apps
                        pageApps[appId] = [appLink];
                    }
                }
            }
        }
    }
    // Make an element a launch link with proper instrumentation
    function setLaunchLink(targetElement, appElement, appId, launchUrl) {
        targetElement.setAttribute("href", launchUrl);
        // This code sets proper instrumentation attribute on the launch link
        // We cannot have two identical apps within the same DOM element, for example in the same pivot. We can have two
        // identical apps on different pivots, e.g. OpenTable on About and Apps, however they will have different K values
        // so we need to select the correct sibling element which contains the launch K value to use.
        var siblingInstElement = querySelector(appElement.parentElement, "[data-launchappid='" + appId + "']");
        if (siblingInstElement) {
            var hAttr = "h";
            // data-inst will only be present behind FD
            var hValue = siblingInstElement.getAttribute(hAttr);
            if (hValue && hValue.length > 0) {
                targetElement.setAttribute(hAttr, hValue);
            }
        }
    }
    AppApi.setLaunchLink = setLaunchLink;
    function instrumentUpgradeLink(appElement) {
        // If upgrade link is instrumented with it's own InstLink and h value, then set that to be the h value of rendered link.
        // This is currently applicable for Windows app links which use separate link for upgrade state.
        var upgradeLinkElement = querySelector(appElement.parentElement, "[data-linkRole='Upgrade']");
        if (upgradeLinkElement) {
            var hUpgradeLink = upgradeLinkElement.getAttribute("h");
            if (hUpgradeLink) {
                appElement.setAttribute("h", hUpgradeLink);
            }
        }
    }
    AppApi.instrumentUpgradeLink = instrumentUpgradeLink;
    // Shell will call this method to update app info with app list
    // This function name and its namespace can't be changed.
    function UpdateAppInfo(apps) {
        if (apps) {
            // This will only read the app element list once, caching it for all subsequent calls
            readApps();
            for (var i = 0; i < apps.length; ++i) {
                updateApp(apps[i]);
            }
        }
        // At this point, we have enqueued the logs for all the app links through AppInst.queueServerAppLog function calls.
        // For perf reasons, we submit them all at once in single payload through the following function call.
        if (instrumentationEnabled) {
            AppInst.submitLog();
        }
    }
    AppApi.UpdateAppInfo = UpdateAppInfo;
    function stringToVersion(versionStr) {
        return versionStr.split('.').map(function (s) { return Number(s); });
    }
    // Version comparison function
    function compareAppVersions(version1, version2) {
        var commonLength = Math.min(version1.length, version2.length);
        for (var i = 0; i < commonLength; i++) {
            var diff = version1[i] - version2[i];
            if (diff != 0) {
                return diff;
            }
        }
        // The longer version number is considered greater
        return version1.length - version2.length;
    }
    function querySelector(element, query) {
        return element.querySelector(query);
    }
})(AppApi || (AppApi = {}));
;// ------------------------------------------------------------------------------
// <copyright file="SmartSearch.Navigation.ts" company="Microsoft Corporation">
//     Copyright (c) Microsoft Corporation. All Rights Reserved.
//     Information Contained Herein is Proprietary and Confidential.
// </copyright>
// ------------------------------------------------------------------------------
///<reference path="..\..\..\..\Shared\Content\Content\script\Declarations\Shared.d.ts"/>
///<reference path="..\..\..\..\Shared\Content\Content\Script\Declarations\Threshold.Utilities.d.ts" />
///<reference path="SearchApp.Mock.ts" />
///<reference path="Declarations\CortanaEnums.d.ts" />
var CachedDeviceItems = {};
var SmartSearch;
(function (SmartSearch) {
    var cortanaApp = SearchAppWrapper.CortanaApp;
    var _supportedPaths = null;
    var baseProtocol = null;
    var baseHostname = null;
    var launchApiAllowedLatency = 100;
    var bingToken = "bing";
    var apiNameAbbreviator = /(^.)|([A-Z])/g;
    function isSupportedPath(path, search) {
        var supportedPathsCollection = getSupportedPaths();
        path = cleanPath(path);
        // Cut off the leading ? in the search parameters
        if (search && search.substring) {
            search = search.substring(1);
        }
        // A path is supported if it's not blocked and there is a supported path for it
        // Check block lists first as they should be shorter
        return (!isPathSatisfied(supportedPathsCollection.Blocked, path, search) && isPathSatisfied(supportedPathsCollection.Supported, path, search));
    }
    SmartSearch.isSupportedPath = isSupportedPath;
    /// Called by test code to reset cached state between tests
    function reset() {
        _supportedPaths = null;
    }
    SmartSearch.reset = reset;
    function cleanPath(path) {
        var cleanPath = path;
        if (cleanPath) {
            var cleanPath = cleanPath.toLowerCase();
            var cutIndex = -1;
            for (var i = 0; i < cleanPath.length && cleanPath[i] === "/"; i++) {
                cutIndex = i;
            }
            if (cutIndex >= 0) {
                cleanPath = cleanPath.substring(cutIndex + 1);
            }
        }
        return cleanPath;
    }
    function getSupportedPaths() {
        if (!_supportedPaths) {
            var thresholdConfig = _TC;
            if (thresholdConfig) {
                var supportedPaths = null;
                var blockedPaths = null;
                if (thresholdConfig.SP) {
                    supportedPaths = parsePathList(thresholdConfig.SP);
                }
                if (thresholdConfig.BP) {
                    blockedPaths = parsePathList(thresholdConfig.BP);
                }
                _supportedPaths = { Supported: supportedPaths, Blocked: blockedPaths };
            }
        }
        return _supportedPaths;
    }
    function isPathSatisfied(supportedPathsMap, path, search) {
        for (var i in supportedPathsMap) {
            if (path.indexOf(i) >= 0) {
                var requiredParameters = supportedPathsMap[i];
                var allParametersPresent = true;
                // Check if this path requires specific querystring parameters
                if (requiredParameters.length > 0) {
                    // If we require some parameters we assume we don't have them until we succeed with parsing
                    allParametersPresent = false;
                    if (search) {
                        var parsedPathParameters = cleanArray(search.split("&"));
                        // If we require some parameters and have parameters in the input path then we assume we've got what we need until we find a parameter is missing
                        allParametersPresent = parsedPathParameters.length >= requiredParameters.length;
                        if (allParametersPresent) {
                            for (var requiredParameterIndex in requiredParameters) {
                                if (parsedPathParameters.indexOf(requiredParameters[requiredParameterIndex]) < 0) {
                                    // We've failed to find a required parameter, so we know this is not a match
                                    allParametersPresent = false;
                                    break;
                                }
                            }
                        }
                    }
                }
                // We found all required parameters or there were no required parameters.  This is a match.
                if (allParametersPresent) {
                    return true;
                }
            }
        }
        return false;
    }
    function parsePathList(supportedPaths) {
        var parsedPaths = {};
        supportedPaths = supportedPaths.toLowerCase();
        var supportedFullPaths = supportedPaths.split(",");
        var defaultRequiredQueryStrings = [];
        for (var supportedFullPathIndex in supportedFullPaths) {
            var pathAndQuery = cleanArray(supportedFullPaths[supportedFullPathIndex].split("?"));
            var requiredQueryStrings = defaultRequiredQueryStrings;
            if (pathAndQuery.length > 1) {
                requiredQueryStrings = cleanArray(pathAndQuery[1].split("&"));
            }
            parsedPaths[cleanPath(pathAndQuery[0])] = requiredQueryStrings;
        }
        return parsedPaths;
    }
    function cleanArray(inputArray) {
        var returnValue = inputArray;
        if (inputArray) {
            var startIndex = 0;
            var foundItemToClean = false;
            for (var i = startIndex; i < inputArray.length; i++) {
                if (!inputArray[i]) {
                    if (!foundItemToClean) {
                        returnValue = [];
                        foundItemToClean = true;
                    }
                    if (i > startIndex) {
                        returnValue.push.apply(returnValue, inputArray.slice(startIndex, i));
                    }
                    startIndex = i + 1;
                }
            }
        }
        return returnValue;
    }
    function signalComplete() {
        sj_evt.fire("NavigationComplete");
    }
    function navigateTo(targetElement, event) {
        var preventDefault = true;
        // Check if target element link is internal or external
        if (targetElement) {
            var searchUtils = ThresholdUtilities;
            var destinationPath = targetElement.pathname;
            var destinationHostname = getHostname(targetElement);
            var destinationProtocol = targetElement.protocol;
            var destinationSearch = targetElement.search;
            var destinationHash = targetElement.hash;
            if (!baseHostname || !baseProtocol) {
                getBaseUrl();
            }
            var destinationLink = targetElement.href;
            // If the link is really a javascript invocation (like "javascript:void(0)"), bail out.
            if (destinationProtocol.toLowerCase() === "javascript:") {
                return;
            }
            if (!destinationHostname) {
                destinationHostname = baseHostname; // automatically accquire current domain for relative links
            }
            // If both hosts contain bing, or neither host contains bing we'll treat them as potentially equivalent and force evaluation of all other properties.
            var destinationHostIsBing = destinationHostname && destinationHostname.toLowerCase().indexOf(bingToken) >= 0;
            var currentHostname = getHostname(_w.location);
            var currentHostIsBing = currentHostname && currentHostname.toLowerCase().indexOf(bingToken) >= 0;
            // We also respect protocol because http://www.bing.com is not the same page as https://www.bing.com (potentially different cookies and page content).
            if (destinationHostIsBing === currentHostIsBing && destinationProtocol.toLowerCase() === _w.location.protocol.toLowerCase() && destinationPath.toLowerCase() === _w.location.pathname.toLowerCase() && destinationSearch.toLowerCase() === _w.location.search.toLowerCase() && destinationHash.toLowerCase() === _w.location.hash.toLowerCase()) {
                SharedLogHelper.LogWarning("SelfNavigate");
            }
            else if (destinationLink) {
                // Determine if a link is relative.
                // Handle a weird case where the url is ms-windows-store:PDP?PFN=..., no host, and "ms-windows-store:" protocol
                var isRelative = (!destinationProtocol || destinationProtocol.indexOf("http") === 0) && (destinationHostname === baseHostname || destinationHostname === getHostname(location));
                var urlType = getUrlType(destinationPath, destinationSearch, destinationHostname, isRelative);
                var launcher = cortanaApp.launcher;
                switch (urlType) {
                    case 5 /* Search */:
                    case 3 /* Navigation */:
                        if (isRelative) {
                            rebaseLink(targetElement);
                            // Need to refresh after changing the link properties
                            destinationLink = targetElement.href;
                        }
                        if (urlType === 5 /* Search */) {
                            // Force Cat3b (search)
                            var joiningChar = destinationLink.indexOf("?") === -1 ? "?" : "&";
                            destinationLink += joiningChar + "persona=0";
                        }
                        var navigateWebViewFunctionName = "navigateWebViewAsync";
                        var launchWebContentFunctionName = "launchWebContent";
                        var thresholdConfig = _TC;
                        if (thresholdConfig && thresholdConfig.NW && launcher[launchWebContentFunctionName]) {
                            var launchOptions = launcher.createWebContentLaunchOptions();
                            launchOptions.uri = destinationLink;
                            searchUtils.wrapSynchronousApiCall(launcher, launchWebContentFunctionName, createInstrumentationKey(launchWebContentFunctionName), null, launchOptions);
                            signalComplete();
                        }
                        else if (cortanaApp[navigateWebViewFunctionName]) {
                            searchUtils.wrapApiCallWithTimeout(cortanaApp, navigateWebViewFunctionName, createInstrumentationKey(navigateWebViewFunctionName), destinationLink, launchApiAllowedLatency, null, destinationLink).done(signalComplete);
                        }
                        else {
                            // We're in charge of the actual navigation
                            preventDefault = false;
                        }
                        break;
                    case 0 /* App */:
                        var options = null;
                        var appContext = targetElement.getAttribute("data-appcontext");
                        if (appContext) {
                            options = launcher.createAppLaunchOptions();
                            options.appContext = appContext;
                        }
                        var itemId = targetElement.getAttribute("data-appid");
                        if (itemId) {
                            var itemSource = targetElement.getAttribute("data-source");
                            var deviceItem = CachedDeviceItems[itemId + ":" + itemSource];
                            if (deviceItem) {
                                var launchSearchItemAsyncPromise;
                                var functionName = "launchSearchItemAsync";
                                if (options) {
                                    launchSearchItemAsyncPromise = searchUtils.wrapApiCallWithTimeout(launcher, functionName, createInstrumentationKey(functionName), deviceItem.id, launchApiAllowedLatency, null, deviceItem, options);
                                }
                                else {
                                    launchSearchItemAsyncPromise = searchUtils.wrapApiCallWithTimeout(launcher, functionName, createInstrumentationKey(functionName), deviceItem.id, launchApiAllowedLatency, null, deviceItem);
                                }
                                launchSearchItemAsyncPromise.done(signalComplete);
                            }
                            else {
                                var itemType = targetElement.getAttribute("data-itemtype");
                                var functionName = itemType && itemType === "settings" ? "findSettingsAsync" : "findAppsAsync";
                                searchUtils.wrapApiCallWithTimeout(cortanaApp.searchResultsView.deviceSearch, functionName, createInstrumentationKey(functionName), "Navigation", launchApiAllowedLatency, null, [itemId]).then(sj_df(launchFirstFoundItem, options));
                            }
                        }
                        break;
                    case 4 /* Experience */:
                        var experienceName = targetElement.getAttribute("data-experiencename");
                        if (experienceName) {
                            SearchAppWrapper.CortanaApp.launchExperienceByName(experienceName, null);
                        }
                        break;
                    case 2 /* Explore */:
                        var destination = targetElement.getAttribute("data-dest");
                        if (destination) {
                            launcher.launchSearchInApp(destination, ThresholdUtilities.getDecodedQuery(_w.location.toString()));
                            signalComplete();
                        }
                        break;
                    case 1 /* Web */:
                        if (isRelative) {
                            rebaseLink(targetElement);
                            // Need to refresh after changing the link properties
                            destinationLink = targetElement.href;
                            // Instrument the time of the click to allow us to join the impressions. These requests are from two
                            // different apps, so will be seen as 2 different users, making it difficult to measure e2e perf from
                            // app click to browser page load without this query param.
                            var joiningChar = destinationLink.indexOf("?") === -1 ? "?" : "&";
                            destinationLink += joiningChar + "ts=" + sb_gt();
                            if (_G.nclid) {
                                destinationLink += "&nclid=" + _G.nclid;
                            }
                        }
                        var functionName = "launchUriAsync";
                        searchUtils.wrapApiCallWithTimeout(launcher, functionName, createInstrumentationKey(functionName), "Navigation", launchApiAllowedLatency, null, destinationLink).then(signalComplete);
                        break;
                }
            }
        }
        if (event && preventDefault) {
            event.preventDefault();
        }
    }
    ;
    function createInstrumentationKey(apiName) {
        return apiName.match(apiNameAbbreviator).join("").toUpperCase();
    }
    function launchFirstFoundItem(result, options) {
        if (result != null) {
            for (var i in result) {
                var currentResult = result[i];
                // This check seems unecessary, but the mapping returned maps IDs to empty objects when it fails to find it on the machine.
                if (currentResult && currentResult.id) {
                    var functionName = "launchSearchItemAsync";
                    ThresholdUtilities.wrapApiCallWithTimeout(SearchAppWrapper.CortanaApp.launcher, functionName, createInstrumentationKey(functionName), null, launchApiAllowedLatency, null, currentResult, options).then(signalComplete);
                    break;
                }
            }
        }
    }
    function getUrlType(destinationPath, destinationSearch, destinationHostname, isRelative) {
        if (isRelative && isSupportedPath(destinationPath, destinationSearch)) {
            // This is a requery on search
            if (destinationPath === "search" || destinationPath === "/search") {
                return 5 /* Search */;
            }
            // This is a navigation link to another bing page
            return 3 /* Navigation */;
        }
        else if (destinationHostname === "ms-smartsearch") {
            if (destinationPath === "app" || destinationPath === "/app") {
                return 0 /* App */;
            }
            else if (destinationPath === "searchInApp" || destinationPath === "/searchInApp") {
                return 2 /* Explore */;
            }
            else if (destinationPath === "experience" || destinationPath === "/experience") {
                return 4 /* Experience */;
            }
        }
        // Any other links should be launched in browser.
        return 1 /* Web */;
    }
    ;
    function onClickHandler(evt) {
        if (!evt.defaultPrevented) {
            var element = evt.target;
            var targetElement = getParentContainer(element, "A");
            if (targetElement) {
                navigateTo(targetElement, evt);
            }
        }
    }
    ;
    function getParentContainer(target, tagName) {
        for (; target && target !== document; target = target.parentNode) {
            if (target.tagName === tagName) {
                return target;
            }
        }
    }
    ;
    function getBaseUrl() {
        if (_w["_TH_BU"]) {
            var baseUrlPieces = _TH_BU.split("//", 2);
            if (baseUrlPieces.length === 2) {
                baseProtocol = baseUrlPieces[0];
                baseHostname = baseUrlPieces[1];
                return;
            }
        }
        baseProtocol = location.protocol;
        baseHostname = getHostname(location);
    }
    function rebaseLink(element) {
        element.protocol = baseProtocol;
        element.hostname = baseHostname;
        element.port = baseProtocol === "https:" ? "443" : "80";
    }
    function getHostname(element) {
        if (!element) {
            return null;
        }
        var hostname = element.hostname;
        if (!hostname) {
            return null;
        }
        // Microsoft Edge drops the [ ] for IPv6 urls, and we cannot actually navigate to IPv6 hosts without them.
        // Add them if they're missing.
        if (hostname.indexOf(":") >= 0 && hostname.indexOf("[") < 0) {
            hostname = "[" + hostname + "]";
        }
        return hostname;
    }
    sj_be(_w, "click", onClickHandler);
    var UrlType;
    (function (UrlType) {
        UrlType[UrlType["App"] = 0] = "App";
        UrlType[UrlType["Web"] = 1] = "Web";
        UrlType[UrlType["Explore"] = 2] = "Explore";
        UrlType[UrlType["Navigation"] = 3] = "Navigation";
        UrlType[UrlType["Experience"] = 4] = "Experience";
        UrlType[UrlType["Search"] = 5] = "Search";
    })(UrlType || (UrlType = {}));
})(SmartSearch || (SmartSearch = {}));
;// ------------------------------------------------------------------------------
// <copyright file="SmartSearch.ts" company="Microsoft Corporation">
//     Copyright (c) Microsoft Corporation. All Rights Reserved.
//     Information Contained Herein is Proprietary and Confidential.
// </copyright>
// ------------------------------------------------------------------------------
///<reference path="..\..\..\..\Shared\Content\Content\script\Declarations\AppApi.d.ts"/>
///<reference path="..\..\..\..\Shared\Content\Content\script\Declarations\Shared.d.ts"/>
///<reference path="..\..\..\..\Shared\Content\Content\Script\Declarations\Threshold.Utilities.d.ts" />
///<reference path="SmartSearch.Navigation.ts"/>
///<reference path="SearchApp.Mock.ts"/>
(function () {
    var appIdAttribute = "data-appid";
    if (typeof AppApi === "undefined" || !AppApi.UpdateAppInfo || !SearchAppWrapper.CortanaApp || !SearchAppWrapper.CortanaApp.searchResultsView) {
        return;
    }
    // Get app ids
    var appIds = [];
    var appLinks = document.querySelectorAll("[" + appIdAttribute + "]");
    for (var i = 0; i < appLinks.length; i++) {
        var appId = appLinks[i].getAttribute(appIdAttribute);
        if (appIds.indexOf(appId) < 0) {
            appIds.push(appId);
        }
    }
    var processApplicationMap = function (results) {
        var apps = [];
        for (var index in appIds) {
            var appId = appIds[index];
            if (results.hasKey(appId)) {
                var item = results[appId];
                if (item) {
                    var app = {
                        id: appId,
                        installedAppVersion: item.version,
                        installed: true
                    };
                    apps.push(app);
                    if (CachedDeviceItems && !CachedDeviceItems[appId]) {
                        CachedDeviceItems[appId] = item;
                    }
                }
            }
        }
        AppApi.UpdateAppInfo(apps);
        ThresholdUtilities.uploadApiTimes("ALR");
    };
    // Check the app install state and update app info, only if we have some apps to check
    if (appIds.length > 0) {
        ThresholdUtilities.wrapApiCall(SearchAppWrapper.CortanaApp.searchResultsView.deviceSearch, "findAppsAsync", "AL", "AppLinking", appIds).then(processApplicationMap);
    }
})();
;///<reference path="..\..\..\answers\services\Shared\Content\Content\script\Declarations\Shared.d.ts"/>
// Sets a persistent cookie crumb with javascsript observations.  The browser's inner width and height, the device pixel ratio, and the UTC offset.
(function () {
    var clientCookie = "SRCHHPGUSR";
    function setHeightAndWidthCrumbs() {
        var cwCookie = sj_cook.get(clientCookie, "CW");
        if (!cwCookie || (window["sj_b"] && cwCookie != sj_b.clientWidth)) {
            sj_cook.set(clientCookie, "CW", (sb_de.clientWidth || sj_b.clientWidth).toString(), true, "/", null);
        }
        var chCookie = sj_cook.get(clientCookie, "CH");
        var clientHeight = sb_de.clientHeight.toString();
        if (!chCookie || chCookie !== clientHeight) {
            sj_cook.set(clientCookie, "CH", clientHeight, true, "/", null);
        }
    }
    function setClientCookieDataOnLoad() {
        var dprCookie = sj_cook.get(clientCookie, "DPR");
        var dpr = _w["devicePixelRatio"];
        if (dpr && (!dprCookie || parseInt(dprCookie) !== dpr)) {
            sj_cook.set(clientCookie, "DPR", dpr.toString(), true, "/", null);
        }
        var utcCookie = sj_cook.get(clientCookie, "UTC");
        var utcOffset = (new Date().getTimezoneOffset() * -1).toString();
        if (utcCookie == null || utcCookie !== utcOffset) {
            sj_cook.set(clientCookie, "UTC", utcOffset, true, "/", null);
        }
    }
    function setClientCookie() {
        setHeightAndWidthCrumbs();
        setClientCookieDataOnLoad();
    }
    sj_be(_w, "load", setClientCookie);
    sj_be(_w, "resize", setHeightAndWidthCrumbs);
})();
;/// <reference path="..\..\..\..\Shared\Content\Content\Script\Declarations\Shared.d.ts" />
/// <reference path='..\..\..\..\Shared\Content\Content\Script\Declarations\Threshold.Utilities.d.ts' />
/// <reference path="..\..\..\..\Threshold\src\Content\Script\Declarations\SearchAppWrapper.d.ts" />
/*This is a hack and temporary fix. TFS 5405929 tracks its removal as soon as LG issue is fixed for entity carousel from the backend.
invocation of "respond" API is necessary from the Cortana client perspective as it requres this API for removal of thinking canvas.
So this change is to unblock mobile2cortana flight while the right fix is being worked upon from backend side. */
(function () {
    if (SearchAppWrapper && SearchAppWrapper.CortanaApp) {
        var cat3AAnswer = _d.querySelector(".b_cat3a");
        var languageGenerationElement = cat3AAnswer && cat3AAnswer.querySelector("div[data-ssml]");
        if (languageGenerationElement) {
            ThresholdUtilities.wrapSynchronousApiCall(SearchAppWrapper.CortanaApp, "respond", null, "respond", languageGenerationElement.getAttribute("data-ssml"), languageGenerationElement.getAttribute("data-postssmlaction"), languageGenerationElement.getAttribute("data-secondarytext-small"), languageGenerationElement.getAttribute("data-secondarytext-medium"), languageGenerationElement.getAttribute("data-secondarytext-large"));
        }
        else {
            var emptySpaceString = " ";
            ThresholdUtilities.wrapSynchronousApiCall(SearchAppWrapper.CortanaApp, "respond", null, "respond", emptySpaceString, emptySpaceString, emptySpaceString, emptySpaceString, emptySpaceString);
        }
        var emotionElement = cat3AAnswer && cat3AAnswer.querySelector("div[data-emot]");
        if (emotionElement) {
            ThresholdUtilities.wrapSynchronousApiCall(SearchAppWrapper.CortanaApp, "setEmotion", null, "setEmotion", emotionElement.getAttribute("data-emot"), emotionElement.getAttribute("data-emot-size") === "large", emotionElement.hasAttribute("data-emot-overridespeaking"));
        }
    }
})();
;///<reference path="..\Declarations\Shared.d.ts" />
// Please don't change this module name - it's part of Cortana spec
var BMPage;
(function (BMPage) {
    function UpdateUserDisplayName(name) {
        if (!name) {
            return;
        }
        var userNameContainers = _d.querySelectorAll("[data-userDisplayName]");
        for (var i = 0; i < userNameContainers.length; i++) {
            var userNameContainer = userNameContainers[i];
            userNameContainer.innerText = name;
        }
    }
    BMPage.UpdateUserDisplayName = UpdateUserDisplayName;
})(BMPage || (BMPage = {}));
;CUDialog.sendAction({"Cat3AAction":"{\"Uri\":\"action://CuOutput\",\"SystemAction\":{\"Uri\":\"action://Conversation/LaunchSPA\",\"Version\":\"1.0\"},\"ConversationId\":\"52173f4c-795f-69c5-10c0-8083187df6ad\",\"TraceId\":\"8F51D2F040854E27BAEA1780BD005BDC\",\"ImpressionId\":\"4aed71533adb72fa437ea2a3e14abcac\",\"LgObject\":null}","Cat3BAction":""});;/// <reference path='..\..\..\..\Shared\Content\Content\Script\Declarations\Threshold.Utilities.d.ts' />
var ThemablePage;
(function (ThemablePage) {
    // Find the themable page indicator and apply theme classname(s) to body element.
    // We do this in script because the body element already rendered in the first chunk before we found out we needed a different theme in the second chunk.
    var themeIndicator = _ge("b_thp");
    if (themeIndicator) {
        sb_de.classList.add("b_theme");
        var themeClasses = themeIndicator.classList;
        for (var additionalClass = 0; additionalClass < themeClasses.length; additionalClass++) {
            sb_de.classList.add(themeClasses[additionalClass]);
        }
    }
})(ThemablePage || (ThemablePage = {}));
;var SPAClientLoggingConfig = {};
;define("ajax.shared", ["require", "exports"], function (require, exports) {
    ///<reference path="..\ajax.keymap.d.ts"/>
    ///<reference path="..\..\..\..\..\Shared\Content\Content\Script\Declarations\Shared.d.ts"/>
    function getPlaceholder(key) {
        var placeholderKey = keyMap[key] ? keyMap[key] : keyMap.Prefix + key;
        var placeholder = document.getElementById(placeholderKey);
        if (!placeholder && document.getElementsByClassName) {
            var holderClass = document.getElementsByClassName(placeholderKey);
            placeholder = holderClass && holderClass.length ? holderClass[0] : null;
        }
        return placeholder;
    }
    exports.getPlaceholder = getPlaceholder;
    function getRelativeUrl(url) {
        var a = sj_ce('a');
        a.href = url;
        var allowedPath = a.pathname;
        if (allowedPath[0] !== '/') {
            allowedPath = "/" + allowedPath;
        }
        var relativeUrl = "";
        if (allowedPath === "/") {
            relativeUrl = allowedPath;
        }
        else {
            var index = url.indexOf(allowedPath);
            relativeUrl = index > -1 ? url.substr(index) : "";
        }
        return relativeUrl;
    }
    exports.getRelativeUrl = getRelativeUrl;
    function getParentContainer(target, tagName, tag) {
        for (; target && target !== document; target = target.parentNode) {
            if (target[tagName] === tag) {
                return target;
            }
            if (target === undefined) {
                break;
            }
        }
    }
    exports.getParentContainer = getParentContainer;
    ;
});
;///<amd-module name="ajax.render" />
define("ajax.render", ["require", "exports", "ajax.shared"], function (require, exports, ajaxShared) {
    var dom = require("dom");
    var customEvents = require("event.custom");
    var queue = [];
    var isScriptDownloading = false;
    var pendingStyleBackup = true;
    customEvents.bind("ajax.unload", function () { return pendingStyleBackup = true; });
    function renderJson(json, renderItem) {
        for (var key in json) {
            if (key === "Script") {
                for (var i = 0; i < json[key].length; i++) {
                    queueForRendering(key, json[key][i], renderItem);
                }
            }
            else {
                queueForRendering(key, json[key], renderItem);
            }
        }
    }
    exports.renderJson = renderJson;
    function queueForRendering(key, value, render) {
        if (!isScriptDownloading) {
            checkAndRender(key, value, render);
        }
        else {
            queue.push({ k: key, v: value, r: render });
        }
    }
    function checkAndRender(key, value, render) {
        // Do default rendering action if render function does not exist or render function
        // explicitly asks to invoke the default action.
        if (!render || render(key, value)) {
            renderItem(key, value);
        }
    }
    function backupStyles() {
        if (pendingStyleBackup) {
            var backupCssHolder = dom.getCssHolder();
            backupCssHolder.id = "ajaxStylesBackup";
            var cssHolder = dom.getCssHolder();
            var backupCssHolderSibling = backupCssHolder.nextSibling;
            if (backupCssHolderSibling) {
                backupCssHolder.parentNode.insertBefore(cssHolder, backupCssHolderSibling);
            }
            pendingStyleBackup = false;
        }
    }
    function cleanupStyles() {
        var backupCssHolder = document.getElementById("ajaxStylesBackup");
        if (backupCssHolder)
            backupCssHolder.parentNode.removeChild(backupCssHolder);
    }
    function renderItem(key, value) {
        switch (key) {
            case "Script":
                appendScripts(value);
                break;
            case "Style":
                backupStyles();
                dom.getCssHolder().innerHTML += '<div></div>' + value;
                break;
            case "IG":
                _G.IG = value;
                break;
            case "PageName":
                _G.PN = value;
                break;
            case "Title":
                document.title = value;
                break;
            case "HBop":
                var div = document.createElement("div");
                document.getElementById(keyMap.Content).appendChild(div);
                div.outerHTML = value;
                break;
            case "RmsDefer":
                var rmsContainer = ajaxShared.getPlaceholder(key);
                if (!rmsContainer) {
                    rmsContainer = document.createElement("div");
                    document.body.appendChild(rmsContainer);
                }
                rmsContainer.outerHTML = value;
                break;
            case "Content":
                appendContent(key, value);
                break;
            case "EOS":
                cleanupStyles();
                break;
            case "EOC":
                if (value === "1") {
                    customEvents.fire("ajax.firstChunkEnd");
                }
                break;
            default:
                appendContent(key, value);
        }
    }
    function appendContent(key, value) {
        var placeholder = ajaxShared.getPlaceholder(key);
        if (placeholder) {
            if (typeof value === "string") {
                placeholder.outerHTML = value;
            }
            else {
                placeholder.parentNode.replaceChild(value, placeholder);
            }
        }
    }
    function appendScripts(script) {
        var value = script;
        if (value["Method"] === "reference") {
            fetchReferenceScript(value["Content"]);
        }
        else {
            dom.includeScript(value["Content"]);
        }
    }
    function continueRender() {
        while (queue.length) {
            if (isScriptDownloading) {
                break;
            }
            var obj = queue.shift();
            checkAndRender(obj.k, obj.v, obj.r);
        }
    }
    function fetchReferenceScript(url) {
        isScriptDownloading = true;
        var request = new XMLHttpRequest();
        var timeoutHandler;
        request.open("get", url, true);
        request.onreadystatechange = function () {
            if (request.readyState === 4) {
                if (timeoutHandler !== null) {
                    clearTimeout(timeoutHandler);
                }
                if (request.status === 200) {
                    dom.includeScript(request.responseText);
                }
                isScriptDownloading = false;
                continueRender();
            }
        };
        request.send();
        timeoutHandler = setTimeout(function () {
            request.abort();
            isScriptDownloading = false;
            continueRender();
        }, 10000);
    }
});
;///<amd-module name="ajax.providers" />
///<reference path="..\Declarations\ajax.d.ts"/>
define("ajax.providers", ["require", "exports"], function (require, exports) {
    var providers = [];
    function registerProvider(responseCreator) {
        if (!responseCreator.sanitizeUrl) {
            responseCreator.sanitizeUrl = dummySanitizeUrl;
        }
        providers.push(responseCreator);
    }
    exports.registerProvider = registerProvider;
    function getAjaxController(url, origin, elem) {
        var length = providers.length;
        for (var i = 0; i < length; i++) {
            var responseCreator = providers[i];
            if (responseCreator.shouldAjax(url, origin, elem)) {
                return responseCreator;
            }
        }
        return null;
    }
    exports.getAjaxController = getAjaxController;
    function dummySanitizeUrl(url) {
        return url;
    }
});
;///<amd-module name="ajax.lifeCycle" />
///<reference path="..\ajax.keymap.d.ts"/>
///<reference path="..\Declarations\ajax.d.ts"/>
define("ajax.lifeCycle", ["require", "exports", "ajax.shared", "ajax.history", "ajax.providers", "ajax.render"], function (require, exports, ajaxShared, history, ajaxProviders, ajaxRender) {
    var dom = require("dom");
    var env = require("env");
    var cookies = require("cookies");
    var nativeEvents = require("event.native");
    var customEvents = require("event.custom");
    var hasOnPPFired = false;
    var rms = require("rmsajax");
    var shared = require("shared");
    var jsNamespaceBlacklist = ["Bnp", "RMS_IACL", "sched", "TP", "bepns", "Identity", "initComCtrl", "ccal", "ccal_bundle", "expitem", "si_sendCReq"];
    var divClassNameBlackList = ["bubblePlaceholder", "irhc", "vrhc"];
    var _undefined;
    var lastRenderedOrigin = 1 /* Click */;
    var lastRenderedUrl = ajaxShared.getRelativeUrl(window.location.href);
    var pendingRequestUrls = [];
    // Value to check if autosuggest is turned on.
    var autoSuggest;
    // For checking if query has at least one non whitespace character
    var queryRegex = /\S/;
    // For removing sid, format and jsoncbid parameters
    var urlRegex = /(&|%26)sid(=|%3d)\w+(&|%26)format(=|%3d)jsonv2(&|%26)jsoncbid(=|%3d)\d+/gm;
    function init() {
        autoSuggest = cookies.get("SRCHHPGUSR", "AS");
        wireup();
        customEvents.bind("ajax.state", handleHistoryChange);
        // Disabling escape key for ajax scenario
        nativeEvents.bind(document, "keydown", function (evt) {
            if (evt.keyCode === 27) {
                shared.preventDefault(evt);
            }
        });
        // this is used in GPing redirection code to check whether it's running on an AJAX SERP page
        _w["sj_isAjax"] = true;
        customEvents.fire("ajaxReady");
        customEvents.unbind("onP1", init);
    }
    function wireup() {
        var searchForm = document.getElementById("sb_form");
        nativeEvents.bind(searchForm, "submit", handleSearchForm);
        customEvents.bind("autoSugLoaded", function () {
            nativeEvents.unbind(searchForm, "submit", handleSearchForm);
            searchForm.submit = handleSearchForm;
        }, true);
        document.onclick = clickHandler;
        nativeEvents.bind(_w, "hashchange", handleHashChange, false);
        // Wireup location change script
        window["sj_lc"] = function (url, originInput) {
            var originValue = originInput;
            if (!originValue) {
                originValue = 3 /* AS */;
            }
            handleLocationChange(url, originValue);
        };
    }
    // Wireup onClick handler to activate AJAX experience
    function clickHandler(evt) {
        // We ignore handling the click for the following cases
        // 1) The click was already prevented from doing default behavior by some other feature on the page.
        // 2) The control key/shift key was pressed along with click, which indicates user was trying to open in new tab/window
        // 3) The click was due to a right button click. (Firefox fires the click event even for a right click)
        // 4) The url pointed to by the anchor tag is not going to serp vertical.
        // 5) The url pointed to by the anchor tag is same as the current page url.
        if (!evt.defaultPrevented && !evt.ctrlKey && !evt.shiftKey && evt.button === 0) {
            var element = evt.target;
            var targetElement = ajaxShared.getParentContainer(element, "tagName", "A");
            if (targetElement) {
                var ajaxController = ajaxProviders.getAjaxController(targetElement.href, 1 /* Click */, targetElement);
                if (!ajaxController) {
                    return;
                }
                var destinationPath = targetElement.pathname;
                var destionationProtocol = targetElement.protocol ? targetElement.protocol : location.protocol;
                var destinationHostname = targetElement.hostname ? targetElement.hostname : location.hostname; // automatically accquire current domain for relative links
                var destinationLink = targetElement.href;
                // If any links have a sid, format and jsoncbid property on them, we need to remove it
                destinationLink = ajaxController.sanitizeUrl(destinationLink);
                if (destinationLink) {
                    targetElement.href = destinationLink;
                }
                if (destinationHostname === location.hostname && location.protocol === destionationProtocol) {
                    // Make link relative
                    destinationLink = destinationLink.substr(destinationLink.indexOf(destinationPath));
                    loadPage(destinationLink, 1 /* Click */, ajaxController);
                    evt.preventDefault();
                }
            }
        }
    }
    // Autosuggest & Searchbox
    function getSearchUrl(query) {
        return _w.location.pathname + "?q=" + encodeURIComponent(query);
    }
    function getFormParameters(form) {
        var value = "";
        var inputFields = form.getElementsByTagName("input");
        for (var i = 0; i < inputFields.length; i++) {
            if (inputFields[i]["type"] === "hidden") {
                value += "&" + inputFields[i]["name"] + "=" + encodeURIComponent(inputFields[i]["value"]);
            }
        }
        return value;
    }
    function handleSearchForm(evt) {
        var form = document.getElementById(keyMap.SearchForm);
        var query = document.getElementById(keyMap.SBoxId)["value"];
        if (queryRegex.test(query)) {
            // Query is not empty and not just whitespace
            shared.preventDefault(evt);
            var relativeUrl = getSearchUrl(query) + getFormParameters(form);
            renderPage(relativeUrl, 3 /* AS */);
        }
    }
    function handleHistoryChange(data) {
        if (data && data.length > 1) {
            var currentUrl = data[1];
            // prevent re-rendering same page twice
            if (currentUrl) {
                renderPage(currentUrl, 2 /* History */);
            }
        }
    }
    function handleHashChange() {
        handleLocationChange(_w.location.toString(), 5 /* Hash */);
    }
    function handleLocationChange(url, originValue) {
        var relativeUrl = ajaxShared.getRelativeUrl(url);
        var ajaxController = ajaxProviders.getAjaxController(url, originValue);
        if (ajaxController) {
            loadPage(relativeUrl, originValue, ajaxController);
        }
        else if (window.location.href !== url) {
            window.location.assign(url);
        }
    }
    // First run operations
    customEvents.bind("onP1", init, true);
    function sendPerfPing() {
        // In case si_PP doesn't fire onPP by itself we need to make sure onPP fires.
        hasOnPPFired = false;
        customEvents.bind("onPP", function () { return hasOnPPFired = true; });
        _G.PPS = false;
        si_PP(new Date());
    }
    function isPendingUrl(url) {
        return pendingRequestUrls.indexOf(url) !== -1;
    }
    // Ajax Load Page
    function beforeRender(url, origin) {
        pendingRequestUrls.push(url);
        lastRenderedOrigin = origin;
        lastRenderedUrl = url;
        if (origin === 4 /* DirectNav */) {
            return;
        }
        customEvents.fire("unload");
        customEvents.fire("ajax.unload");
        env.clear();
        // Clear out black listed javascript namespaces
        shared.forEach(jsNamespaceBlacklist, function (jsNamespace) {
            if (window.hasOwnProperty(jsNamespace)) {
                window[jsNamespace] = _undefined;
                delete window[jsNamespace];
            }
        });
        shared.forEach(divClassNameBlackList, function (className) {
            var el = document.getElementsByClassName(className);
            for (var i = 0; i < el.length; i++) {
                var element = el[i];
                element.parentNode.removeChild(element);
            }
        });
        clearMaps();
        removeNotification();
        customEvents.reset();
        rms.reset();
    }
    function afterRender() {
        if (lastRenderedOrigin === 4 /* DirectNav */) {
            updateLocation(lastRenderedUrl);
            customEvents.fire("directNavComplete");
            return;
        }
        sendPerfPing();
        updateLocation(lastRenderedUrl);
        wireup();
        // Only fire post load events after perfping has had a chance to
        // upload data immediately.
        env.setTimeout(function () { return fireEvents(); }, 1);
    }
    function fireEvents() {
        customEvents.fire("ajax.load");
        customEvents.fire("onHTML");
        if (!hasOnPPFired) {
            customEvents.fire("onPP");
        }
        customEvents.fire("onP1Lazy");
        customEvents.fire("ajax.postload");
    }
    // Short-term solutions
    function removeNotification() {
        var div = document.getElementById(keyMap.Notification);
        if (div) {
            div.parentNode.removeChild(div);
            var identity = document.getElementById("id_h");
            if (identity)
                identity.style.top = "0";
        }
    }
    // Bug 1060372: Cleanup once there is a more effective way to clear out unnecessary global variables.
    // Clear namespaces related to maps. Needed for map pins to work properly.
    function clearMaps() {
        if (window["Bing"] && Bing.hasOwnProperty("MapControl")) {
            Bing.MapControl = _undefined;
            delete Bing.MapControl;
        }
        if (window["$MapsNamespace"]) {
            if (window.hasOwnProperty($MapsNamespace)) {
                window[$MapsNamespace] = _undefined;
                delete window[$MapsNamespace];
            }
        }
    }
    // Basic navigation methods to clean up existing page, change location and update history
    function updateLocation(url) {
        nativeEvents.unbind(_w, "hashchange", handleHashChange, false);
        if (lastRenderedOrigin !== 2 /* History */ && lastRenderedOrigin !== 4 /* DirectNav */ && lastRenderedOrigin !== 5 /* Hash */) {
            history.pushState(url);
        }
        // Clear out all pending URLs now that we're starting a fresh page
        pendingRequestUrls = [];
    }
    function renderPage(url, origin) {
        var ajaxController = ajaxProviders.getAjaxController(url, origin);
        if (ajaxController) {
            var sanitizedUrl = ajaxShared.getRelativeUrl(ajaxController.sanitizeUrl(url));
            loadPage(sanitizedUrl, origin, ajaxController);
        }
    }
    exports.renderPage = renderPage;
    function loadPage(url, origin, ajaxController) {
        if (isPendingUrl(url)) {
            return;
        }
        beforeRender(url, origin);
        customEvents.fire("ajax.navigateStart", url);
        ajaxController.createJsonAsync(url, function (json, renderItem) { return callback(url, json, renderItem); });
    }
    function callback(url, json, renderItem) {
        var endOfStream = "EOS";
        var renderFunc = json[endOfStream] ? function (k, v) {
            var retval = !renderItem || renderItem(k, v);
            if (k === endOfStream) {
                afterRender();
            }
            return retval;
        } : renderItem;
        ajaxRender.renderJson(json, renderFunc);
    }
});
;///<amd-module name="ajax.cortanaprovider" />
///<reference path="..\ajax.lifecycle.ts"/>
///<reference path="..\..\Declarations\ajax.d.ts"/>
define("ajax.cortanaprovider", ["require", "exports", "ajax.providers", "ajax.lifeCycle"], function (require, exports, ajaxProviders, pageLifeCycle) {
    var currentUrl;
    window["AjaxCB"] = [];
    var requestBuilder;
    function navigate(url, loader, origin) {
        currentUrl = url;
        if (!origin) {
            origin = 4 /* DirectNav */;
        }
        requestBuilder = loader;
        pageLifeCycle.renderPage(url, origin);
    }
    exports.navigate = navigate;
    function addJsonParameters(url) {
        if (url.indexOf("?") <= 0) {
            url += "?";
        }
        return "" + url + "&format=snrjson&jsoncbid=" + (window["AjaxCB"].length - 1);
    }
    function createJsonAsync(relativeUrl, callback) {
        window["AjaxCB"].push(callback);
        if (requestBuilder) {
            requestBuilder(relativeUrl, function (response, isJsonReponse) {
                var container = document.body;
                if (response && container) {
                    sj_appHTML(container, response);
                }
                if (!isJsonReponse) {
                    callback({ "EOS": 1 });
                }
            }, addJsonParameters);
            requestBuilder = null;
        }
        currentUrl = "";
    }
    function shouldAjax(url, origin, elem) {
        return url === currentUrl;
    }
    ajaxProviders.registerProvider({
        "shouldAjax": shouldAjax,
        "createJsonAsync": createJsonAsync
    });
});
;///<reference path="..\..\..\..\Shared\Content\Content\Script\Declarations\Shared.d.ts" />
///<reference path="..\..\..\..\Threshold\src\Content\Script\Declarations\SearchAppWrapper.d.ts" />
///<reference path="..\..\..\..\Shared\Content\Content\Script\Declarations\Threshold.Utilities.d.ts" />
///<reference path="..\..\..\..\..\..\Sparkle\src\content\Sparkle.d.ts" />
var ReminderClickAction;
(function (ReminderClickAction) {
    function createReminderAction(SPAAction, ImpressionId) {
        //var remindButton = <HTMLElement>_ge('remindButton');
        //var title = <string>_ge('remindTitle').nodeValue.toString();
        //var date = <string>_ge('remindDate').nodeValue.toString();
        //var time = <string>_ge('remindTime').nodeValue.toString();
        //remindButton.onclick = ev => {
        //    SearchAppWrapper.CortanaApp.processNLCommandAsync(SPAAction, ImpressionId);
        //};
        //navigateToNewCard("PortableCortanaReminder:PortableCortanaReminderCreate",
        //    "PortableCortanaReminderCreateViewModel",
        //    "remindButton");
        SearchAppWrapper.CortanaApp.processNLCommandAsync(SPAAction, ImpressionId);
    }
    ReminderClickAction.createReminderAction = createReminderAction;
    function cancelReminderAction() {
        navigateToNewCard("PortableCortanaReminder:PortableCortanaReminderCancel", "PortableCortanaReminderCancelViewModel", "cancelButton");
    }
    ReminderClickAction.cancelReminderAction = cancelReminderAction;
    function navigateToNewCard(viewName, viewModel, containerId) {
        Sparkle.render(viewName, {
            uiCulture: SearchAppWrapper.CortanaApp.uiLanguage,
            properties: {
                ViewModel: viewModel
            },
            viewData: {}
        }, _ge(containerId));
    }
    ReminderClickAction.navigateToNewCard = navigateToNewCard;
    function openFirstTurnSearchRemindMeToLink(url) {
        var link = _ge('legacyRecourse');
        link.onclick = function (ev) {
            openUri(url);
        };
    }
    ReminderClickAction.openFirstTurnSearchRemindMeToLink = openFirstTurnSearchRemindMeToLink;
    function openUri(uri) {
        return ThresholdUtilities.wrapApiCall(SearchAppWrapper.CortanaApp.launcher, "launchUriAsync", uri, "SearchRemindMeTo", uri).then(closeCortana);
    }
    function closeCortana() {
        SearchAppWrapper.CortanaApp.dismissApp();
    }
})(ReminderClickAction || (ReminderClickAction = {}));
;(function () {
    function Promote() {
        var isBingSE = _w["isBingCurrentSearchDefault"];
        var setSE = _w["setBingCurrentSearchDefault"];
        if (setSE && isBingSE) {
            var promptNow = false;
            var currDate = new Date();
            if (typeof (Storage) !== "undefined" && _w.localStorage) {
                var tempFlagData = localStorage.getItem("lastSEPromptShownFlag");
                if (tempFlagData != null && tempFlagData != "false") {
                    if (isBingSE() == false) {
                        Log.Log("SetSE", "SetSE", "setBingCurrentSearchDefault", true, "PSE", "Non-Bing", "SE", "Non-Bing", "UA", "Denied");
                    }
                    else {
                        Log.Log("SetSE", "SetSE", "setBingCurrentSearchDefault", true, "PSE", "Non-Bing", "SE", "Bing", "UA", "Accepted");
                    }
                    localStorage.setItem("lastSEPromptShownFlag", false);
                }
                if (!localStorage.getItem("lastSEPromptDate")) {
                    promptNow = true;
                }
                else {
                    if (currDate.getTime() - new Date(localStorage.getItem("lastSEPromptDate")).getTime() > 1000 * 60 * 60 * 24 * 7) {
                        promptNow = true;
                    }
                    else {
                        promptNow = false;
                    }
                }
            }
            if (promptNow && isBingSE() == false) {
                try {
                    localStorage.setItem("lastSEPromptDate", currDate);
                    localStorage.setItem("lastSEPromptShownFlag", true);
                    var result = setSE();
                }
                catch (err) {
                    promptNow = false;
                }
            }
        }
    }
    sj_be(_w, "load", Promote);
})();
;///<reference path="Declarations\Shared.d.ts" />
var SelectorHelper;
(function (SelectorHelper) {
    // This method is intended to work cross-browser. On down-level browsers without native javascript support, the DOM is walked to find a match.  Please be mindful of performance when calling this for down-level browsers.
    function selectorMatches(e, selector) {
        if (e["matches"]) {
            return e["matches"](selector);
        }
        else if (e["webkitMatchesSelector"]) {
            return e["webkitMatchesSelector"](selector);
        }
        else if (e["mozMatchesSelector"]) {
            return e["mozMatchesSelector"](selector);
        }
        else if (e["msMatchesSelector"]) {
            return e["msMatchesSelector"](selector);
        }
        else {
            var eles = _d.querySelectorAll(selector);
            if (eles) {
                for (var i = 0; i < eles.length; i++) {
                    if (eles[i] === e) {
                        return true;
                    }
                }
            }
            return false;
        }
    }
    SelectorHelper.selectorMatches = selectorMatches;
    function findFirstAncestorWithSelector(e, selector) {
        var p = e;
        do {
            p = p.parentElement;
        } while (p != null && !selectorMatches(p, selector));
        return p;
    }
    SelectorHelper.findFirstAncestorWithSelector = findFirstAncestorWithSelector;
})(SelectorHelper || (SelectorHelper = {}));
;///<reference path="..\Declarations\Shared.d.ts" />
///<reference path="..\SelectorHelper.ts" />
var AnswerActionsHelper;
(function (AnswerActionsHelper) {
    function createUndoContainer(undoText, confirmText) {
        if (undoText == null || confirmText == null) {
            return null;
        }
        var msgContainer = sj_ce("div", null, "b_undoContainer b_hide");
        var confirmContainer = sj_ce("div", null, "confirmMsg");
        confirmContainer.innerHTML = confirmText;
        var undoLink = sj_ce("a");
        undoLink.setAttribute("href", "javascript:void(0);");
        undoLink.innerText = undoText;
        msgContainer.appendChild(confirmContainer);
        msgContainer.appendChild(undoLink);
        return msgContainer;
    }
    AnswerActionsHelper.createUndoContainer = createUndoContainer;
    function createErrorHandler(actionLink, errorString, isButtons) {
        return function () {
            // Let the action link be functional again and set error text
            actionLink["isHandling"] = false;
            actionLink.innerText = errorString;
            actionLink.classList.remove("b_demoteText");
            if (!isButtons) {
                actionLink.classList.add("b_accentColor");
            }
        };
    }
    AnswerActionsHelper.createErrorHandler = createErrorHandler;
    // For a given element, find the answer card it's contained within.
    function findContainingCard(element) {
        var card = SelectorHelper.findFirstAncestorWithSelector(element, "#b_pole,.b_ans,.b_ansSlice,.answer,.b_inlActions");
        var isInlineActionContainer = card.classList.contains("b_inlActions");
        if (isInlineActionContainer) {
            var ansCard = SelectorHelper.findFirstAncestorWithSelector(card, "#b_pole,.b_ans,.b_ansSlice,.answer");
            if (ansCard) {
                card = ansCard;
            }
        }
        return card;
    }
    AnswerActionsHelper.findContainingCard = findContainingCard;
    // Determines whether an element is a wrapper used for swapping.
    function isSwapWrapper(element) {
        return element.getAttribute("data-type") === "wrapper";
    }
    AnswerActionsHelper.isSwapWrapper = isSwapWrapper;
    function fade(element) {
        if (element == null) {
            return;
        }
        element.classList.add("b_anim");
        // For the animation to work correctly, it has to transition from one property to another.
        // So to transition to zero properly, we need to set the height explicitly first.
        element.style.height = _w.getComputedStyle(element).height;
        // Start the animation. We need a miniscule amount of time to have the above style change repaint.
        sb_st(function () {
            element.classList.add("b_hide");
            sj_evt.fire('elementgone', element);
        }, 1);
    }
    AnswerActionsHelper.fade = fade;
    function createResponseCard(content, oldCard) {
        if (!oldCard) {
            return null;
        }
        var container = sj_ce(oldCard.tagName, "", oldCard.className);
        container.innerHTML = content;
        return container;
    }
    AnswerActionsHelper.createResponseCard = createResponseCard;
    function swapElements(newElement, oldElement, fadeIfNoReplacement) {
        if (newElement == null || oldElement == null) {
            if (oldElement != null && fadeIfNoReplacement) {
                fade(oldElement);
            }
            return;
        }
        // Create a wrapper element that houses both the new and old elements.
        // Try to reuse an existing wrapper if we find one to keep the DOM shallow.
        var parent = oldElement.parentElement;
        var container;
        if (isSwapWrapper(parent)) {
            container = parent;
        }
        else {
            container = sj_ce("div");
            container.setAttribute("data-type", "wrapper");
            container.classList.add('b_anim');
            parent.insertBefore(container, oldElement);
            container.appendChild(oldElement);
        }
        // Move the new element to the wrapper too
        container.appendChild(newElement);
        // We want to ensure the container animates the height change. To do this we:
        //   1. Set the height to the old element's height
        //   2. Set the height to the new element's height after the above height change goes into effect.
        //   3. When the height has animated, reset the value so that the style is not affecting other transformations on page
        container.style.height = getTotalHeight(oldElement) + "px";
        sb_st(function () {
            container.style.height = getTotalHeight(newElement) + "px";
            sb_st(function () { return container.style.height = ''; }, 0);
        }, 0);
        // Fade out the old element
        fade(oldElement);
    }
    AnswerActionsHelper.swapElements = swapElements;
    function findImmediateChild(parent, descendant) {
        while (descendant && descendant.parentElement !== parent) {
            descendant = descendant.parentElement;
        }
        return descendant;
    }
    function wrapWithDiv(elements, excludedElements) {
        var wrapper = sj_ce("div");
        var i = 0;
        while (i < elements.length) {
            var child = elements[i];
            if (excludedElements == null || excludedElements.indexOf(child) < 0) {
                wrapper.appendChild(child);
            }
            else {
                i++;
            }
        }
        return wrapper;
    }
    function getTotalHeight(element) {
        return convertStyleToPixels(_w.getComputedStyle(element).height) + convertStyleToPixels(_w.getComputedStyle(element).paddingBottom);
    }
    function convertStyleToPixels(style) {
        // Cut off the "px" suffix
        return parseInt(style.substring(0, style.length - 2));
    }
    function insertScriptIntoHead(script) {
        var returnScript = sj_ce("script", "");
        returnScript.type = "text/javascript";
        if (script.src) {
            returnScript.src = script.src;
        }
        else {
            returnScript.innerHTML = script.innerHTML;
        }
        insertNodeIntoHead(returnScript);
    }
    function dismissCard(action) {
        var lastClickedCard = AnswerActionsHelper.findContainingCard(action);
        AnswerActionsHelper.fade(lastClickedCard);
        var answerContainer = SelectorHelper.findFirstAncestorWithSelector(lastClickedCard, "#b_pole,.b_ans");
        if (answerContainer) {
            sb_st(function () {
                var subAnswers = AnswerActionsHelper.findInCard(answerContainer, ".b_ansSlice", false);
                if (!subAnswers) {
                    AnswerActionsHelper.fade(answerContainer);
                }
                sj_evt.fire("dismissCard");
            }, 1);
        }
    }
    AnswerActionsHelper.dismissCard = dismissCard;
    function replaceCard(action, newContent) {
        // Find the old and new answer cards
        var oldCard = findContainingCard(action);
        var newCard = createResponseCard(newContent, oldCard);
        if (oldCard == null || newCard == null) {
            if (oldCard != null) {
                // No new card came back but the action was successfull. Just dismiss the card.
                fade(oldCard);
            }
            return;
        }
        var isSearchReversed = false;
        var ansSlices = oldCard.querySelectorAll("div.b_ansSlice");
        if (ansSlices) {
            isSearchReversed = true;
        }
        // Extract styles and throw them into the DOM
        var styles = newCard.querySelectorAll("style, link");
        if (styles) {
            for (var i = 0; i < styles.length; i++) {
                insertNodeIntoHead(styles[i]);
            }
        }
        // Find the old explanation
        var newExplanation = findExplanation(newCard, false);
        var oldExplanation = findExplanation(oldCard, isSearchReversed);
        // Find the old and new annotations
        var newAnnotation = findAnnotation(newCard, false);
        var oldAnnotation = findAnnotation(oldCard, false);
        // Find the old and new actions
        var newActions = findActions(newCard, false);
        var oldActions = findActions(oldCard, isSearchReversed);
        // Find and swap the old and new captions
        var newCaption = wrapCaption(newAnnotation, newActions, newExplanation);
        var oldCaption = wrapCaption(oldAnnotation, oldActions, oldExplanation);
        // Extract scripts to later throw them into the DOM
        var scripts = newCard.querySelectorAll("script");
        // All animations go! Note that each of these animate independantly.
        swapElements(newAnnotation, oldAnnotation, false);
        swapElements(newCaption, oldCaption, false);
        swapElements(newActions, oldActions, true);
        swapElements(newExplanation, oldExplanation, true);
        if (scripts) {
            for (var i = 0; i < scripts.length; i++) {
                insertScriptIntoHead(scripts[i]);
            }
        }
        sj_evt.fire("replaceCard");
    }
    AnswerActionsHelper.replaceCard = replaceCard;
    // Find the element having a parent with data-type = "infoldAction"
    function findInlineActionContainer(action) {
        while (action != null) {
            var parent = action.parentElement;
            if (parent && parent.getAttribute && parent.getAttribute("data-type") === "InlineActionsWrapper") {
                return action;
            }
            action = parent;
        }
        return null;
    }
    AnswerActionsHelper.findInlineActionContainer = findInlineActionContainer;
    function insertNodeIntoHead(node) {
        _d.head.appendChild(node);
    }
    function findAnnotation(card, isSearchReversed) {
        return findInCard(card, '.b_anno,[data-anno]', isSearchReversed);
    }
    AnswerActionsHelper.findAnnotation = findAnnotation;
    function findTitle(card) {
        return findInCard(card, '.b_anno~h2,.b_anno~.b_focusLabel', false);
    }
    AnswerActionsHelper.findTitle = findTitle;
    function nodeListContains(nodelist, elem) {
        for (var i = 0; i < nodelist.length; i++) {
            if (nodelist[i] == elem) {
                return true;
            }
        }
        return false;
    }
    AnswerActionsHelper.nodeListContains = nodeListContains;
    function findActions(card, isSearchReversed) {
        var expandableActions = findInCard(card, '[data-type="expandableActions"]', isSearchReversed);
        return expandableActions ? expandableActions : findInCard(card, '[data-type="actions"]', isSearchReversed);
    }
    AnswerActionsHelper.findActions = findActions;
    function findExplanation(card, isSearchReversed) {
        return findInCard(card, '.actExpl', isSearchReversed);
    }
    AnswerActionsHelper.findExplanation = findExplanation;
    function findInCard(card, selector, isSearchReversed) {
        if (card) {
            var elements = card.querySelectorAll(selector);
            for (var i = (isSearchReversed ? elements.length - 1 : 0); (!isSearchReversed && i < elements.length) || (isSearchReversed && i >= 0); isSearchReversed ? i-- : i++) {
                var element = elements[i];
                if (element.classList.contains('b_hide')) {
                    // If we find an already faded element, go ahead and do some housekeeping to just remove it from the DOM.
                    element.parentNode.removeChild(element);
                }
                else {
                    return element;
                }
            }
        }
        return null;
    }
    AnswerActionsHelper.findInCard = findInCard;
    function wrapCaption(annotation, actions, explanation) {
        if (!annotation) {
            return null;
        }
        var parent = findContainingCard(annotation);
        var annotationImmediateChild = findImmediateChild(parent, annotation);
        var caption = wrapWithDiv(parent.childNodes, [annotationImmediateChild, findImmediateChild(parent, actions), findImmediateChild(parent, explanation)]);
        return parent.insertBefore(caption, annotationImmediateChild.nextSibling);
    }
})(AnswerActionsHelper || (AnswerActionsHelper = {}));
;///<reference path="..\..\..\..\Shared\Content\Content\Script\Declarations\Shared.d.ts" />
///<reference path="..\..\..\..\Shared\Content\Content\Script\Declarations\Animation.d.ts" />
///<reference path="..\..\..\..\Threshold\src\Content\Script\Declarations\SearchAppWrapper.d.ts" />
var SearchPeek;
(function (SearchPeek) {
    // const aliases for perf
    var Load = "load";
    var Peek = "peek";
    var PeekExpand = "peekExpand";
    var HideClass = "b_hide";
    var content = _ge("b_content");
    var results = _ge("b_results");
    var resultsItems = results.querySelectorAll(".b_ans,.b_algo,.b_ad");
    var poleAnswer = _ge("b_pole");
    var isCat3a = poleAnswer != null && poleAnswer.querySelector(".b_anno") != null;
    var annotation = isCat3a ? poleAnswer.querySelector(".b_anno") : null;
    var title = isCat3a ? poleAnswer.querySelector(".b_anno~h2,.b_anno~.b_focusLabel") : null;
    var header = _ge("b_header");
    var pagination = results.querySelector(".b_pag");
    var footer = _d.querySelector(".b_footer");
    var messageModules = results.querySelectorAll(".b_msg");
    var recourseLink = results.querySelector(".recourseLink").parentNode;
    var feedbackDiv = _ge("sb_feedback");
    var feedbackBadge = feedbackDiv ? feedbackDiv.parentNode : null;
    var hasPeekActivated = false;
    function activatePeek() {
        if (hasPeekActivated) {
            return;
        }
        hasPeekActivated = true;
        // change the background color
        _d.documentElement.classList.remove(Peek);
        sj_b.classList.remove(Peek);
        _d.documentElement.classList.add(PeekExpand);
        sj_b.classList.add(PeekExpand);
        // hide the pole answer based on a flag set by the answer
        if (annotation.getAttribute("data-mainContent") === "1") {
            Animation.toggleSlide(poleAnswer);
        }
        else {
            // answer will be shown in Cat3B, show/hide/animate the elements
            if (title) {
                title.classList.remove(HideClass);
            }
            annotation.classList.add(HideClass);
        }
        // Hide the recourse links        
        recourseLink.classList.add(HideClass);
        // Fade in the header, results, pagination, footer, etc.
        Animation.toggleSlideTranslate(header);
        content.classList.add(PeekExpand);
        results.classList.add("b_slideListHide");
        for (var i = 0; i < resultsItems.length; i++) {
            var result = resultsItems[i];
            result.classList.remove(HideClass);
        }
        if (pagination != null) {
            pagination.classList.remove(HideClass);
        }
        footer.classList.remove(HideClass);
        Animation.cascadeList(results);
        // Hide the client header
        SearchAppWrapper.CortanaApp.setChromeState(7 /* NoHeader */);
        // Let others know the peek happened
        sj_evt.fire("peekexpand", true);
    }
    function showPeek() {
        if (isCat3a) {
            // The title stays hidden
            if (title != null) {
                title.classList.add(HideClass);
                title.classList.add(Peek);
            }
            annotation.classList.remove("b_anim");
            // The scope bar stays hidden
            header.classList.add(HideClass);
            header.classList.add(Peek);
            // results stay hidden
            results.classList.add(Peek);
            for (var i = 0; i < resultsItems.length; i++) {
                var result = resultsItems[i];
                result.classList.add(HideClass);
            }
            for (var i = 0; i < messageModules.length; i++) {
                var messageModule = messageModules[i];
                if (messageModule !== recourseLink && messageModule !== feedbackBadge) {
                    messageModule.classList.add(HideClass);
                }
            }
            // pagination stays hidden
            if (pagination != null) {
                pagination.classList.add(HideClass);
            }
            // The footer stays hidden
            footer.classList.add(HideClass);
            footer.classList.add(Peek);
            // Wait for user to click the recourse link.
            sj_evt.bind("peekactivate", activatePeek, true);
        }
        else {
            // Hide the recourse link
            recourseLink.classList.add(HideClass);
            // Fade in the header, results, footer, etc.
            header.classList.add(Peek);
            content.classList.add(PeekExpand);
            results.classList.add(PeekExpand);
            results.classList.add(Peek);
            footer.classList.add(Peek);
        }
        // Clean up event binding
        sj_ue(_w, Load, showPeek);
    }
    if (content != null && results != null && header != null && recourseLink != null && footer != null) {
        // Because of timing and dimensions-related issues related to the browser itself sliding up from the bottom of the screen,
        // we should just hide the results until after we load and have a chance to properly set peek padding.
        sj_be(_w, Load, showPeek);
    }
    // background color needs to be applied before onload so the initial paint gets the right background for cat3a
    if (isCat3a) {
        _d.documentElement.classList.add(Peek);
        sj_b.classList.add(Peek);
    }
})(SearchPeek || (SearchPeek = {}));
;sj_evt.bind("ajax.feedback.initialized", function(args) { args[1].debugCollector.setContextValue("FederationDebugInfo", "QueryID : f37e5489713849c787f805b462a1513f"); });;
//]]></script><script type="text/javascript" data-rms="1" src="/rms/Framework/nj/92342395/b2d8ec0a.js?bu=rms+answers+BoxModel+config.threshold%2ccore%2ccore%24viewport%2ccore%24layout%2ccore%24metrics%2cmodules%24mutation%2cmodules%24error%2cmodules%24network%2cmodules%24cursor%2cmodules%24keyboard%2cmodules%24bot"></script><script type="text/javascript" data-rms="1">//@ sourceURL=BingDynamicScript1.js
//<![CDATA[
///<reference path="..\..\..\..\answers\services\Shared\Content\Content\script\Declarations\Shared.d.ts"/>
/**
*   Parses the content as HTML and attaches it to the given element.
*   The function takes care of attaching styles and scripts as well.
*   !!! For IE8 and below please make sure dom element passed to the
*       function is part of the DOM tree. !!!
*   @private
*   @param elem - The element to which the parsed content is appended
*   @param content - html content that has to be parsed
*   @example - sj_appHTML(_d.body,"<div>hello</div>");
*/
// BUGBUG: TFS 780914: TypeScript throws build error when two ts file declare the same variable
var sj_appHTML = function (elem, content) {
    if (!content || !elem) {
        return;
    }
    var innerHtml = "innerHTML", scriptTag = "script", appendChild = "appendChild", length = "length", srcAttribute = "src", createElement = sj_ce;
    var div = createElement('div');
    // In IE9 and below innerHTML removes script and style tags if it is
    // not preceded by a visible node.
    div[innerHtml] = '<br>' + content;
    var childNodes = div.childNodes;
    div.removeChild(childNodes[0]);
    var scripts = div.getElementsByTagName(scriptTag);
    if (scripts) {
        for (var i = 0; i < scripts[length]; i++) {
            var newScript = createElement(scriptTag), oldScript = scripts[i];
            if (oldScript) {
                newScript.type = "text/javascript";
                var src = oldScript.getAttribute(srcAttribute);
                if (src) {
                    newScript.setAttribute(srcAttribute, src);
                }
                else {
                    newScript.text = oldScript[innerHtml];
                    newScript.setAttribute("data-bing-script", "1");
                }
                oldScript.parentNode.replaceChild(newScript, oldScript);
            }
        }
    }
    var frag = _d.createDocumentFragment();
    while (childNodes[length]) {
        frag[appendChild](childNodes[0]);
    }
    elem[appendChild](frag);
};
;///<reference path="..\..\..\..\answers\services\Shared\Content\Content\script\Declarations\Shared.d.ts"/>
/**
*   Friendly ajax handler for doing get requests and appending response to dom.
*   @Definition of sj_ajax function
*   @param  url <string>: The url of the site to be ajax loaded
*   @param settings <IAjaxSettings>: Settings defines the callback function
*       and the timeout value for the request.
*   @example sj_ajax("/ajaxload",{
         callback:function(success, response){
*           if(success) response.appendTo(_d.body);
*        },
*        timeout: 1000
*     });
*
*   @Definition of IAjaxSettings object
*   @member Callback <function(success, response)> : This is the function that is called
*               once the request is complete. The functions gets passed two parameters.
*            @param success <bool> - This indicates the sucess of the request.
*            @param response <IAjaxResponse> - A response object that contains the request,
*                a helper fuction to append to dom etc.
*   @member Timeout : Time period in ms to wait before timing out the request.
*
*   @Definition of IAjaxResponse
*   @member request<XMLHttpRequest> : The request object of the current request.
*   @member appendTo<function(domElem)> : If the ajax response is in the form of html then this
*              helper function can be used to attach the html content to the page. This fuction
*              takes care of applying all the style and script tags appropriately.
*              !!! For IE8 and below please make note that scripts would be immediately executed
*                  even if domElem is not in the Dom tree. !!!
*           @param domElem <HTMLElement> - The dom element to attach the html reponse to.
*/
var sj_ajax = function (url, settings) {
    var callback, request = sj_gx(), onreadystatechange = "onreadystatechange", timeout, timeoutHandler = null, setTimeout = sb_st, clearTimeout = sb_ct, empty = function () {
    };
    if (!url || !request) {
        doCallback(callback, false);
        return;
    }
    if (settings) {
        callback = settings.callback;
        timeout = settings.timeout;
    }
    request.open("get", url, true);
    request[onreadystatechange] = function () {
        if (request.readyState === 4) {
            var success = false;
            if (timeoutHandler !== null) {
                clearTimeout(timeoutHandler);
            }
            if (request.status === 200) {
                success = true;
                // Bug on chrome. Multiple onreadystatechange are triggered in debug mode
                request[onreadystatechange] = empty;
            }
            doCallback(callback, success);
        }
    };
    // For ajaxserp we need to cancel this request before loading a new page
    // or else a race condition can do this callback on the next page.
    sj_evt.bind("ajax.unload", cancelRequest);
    request.send();
    function cancelRequest() {
        request[onreadystatechange] = empty;
        if (request.abort) {
            request.abort();
        }
    }
    if (timeout > 0) {
        timeoutHandler = setTimeout(function () {
            cancelRequest();
            doCallback(callback, false);
        }, timeout);
    }
    /**
    *   Executes the callback function by passing it the status message
    *   @private
    *   @param callback - The callbacck function to be executed
    *   @param isSuccess - Bool value indicating if the ajax load was successful
    */
    function doCallback(callback, isSuccess) {
        if (typeof (callback) === "function") {
            callback(isSuccess, {
                request: request,
                appendTo: function (elem) {
                    if (request) {
                        sj_appHTML(elem, request.responseText);
                    }
                }
            });
        }
    }
};
;
//]]></script></body></html>